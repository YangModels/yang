module ietf-netconf-acm {

  namespace &quot;urn:ietf:params:xml:ns:yang:ietf-netconf-acm&quot;;

  prefix &quot;nacm&quot;;

  import ietf-yang-types {
    prefix yang;
  }

  organization
    &quot;IETF NETCONF (Network Configuration) Working Group&quot;;

  contact
    &quot;WG Web:   &lt;<a href="https://tools.ietf.org/wg/netconf/">http://tools.ietf.org/wg/netconf/</a>&gt;
     WG List:  &lt;mailto:<a href="mailto:netconf@ietf.org">netconf@ietf.org</a>&gt;

     WG Chair: Mehmet Ersue
               &lt;mailto:<a href="mailto:mehmet.ersue@nsn.com">mehmet.ersue@nsn.com</a>&gt;

     WG Chair: Bert Wijnen
               &lt;mailto:<a href="mailto:bertietf@bwijnen.net">bertietf@bwijnen.net</a>&gt;

     Editor:   Andy Bierman
               &lt;mailto:<a href="mailto:andy@yumaworks.com">andy@yumaworks.com</a>&gt;

     Editor:   Martin Bjorklund
               &lt;mailto:<a href="mailto:mbj@tail-f.com">mbj@tail-f.com</a>&gt;&quot;;

  description
    &quot;NETCONF Access Control Model.

     Copyright (c) 2012 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD
     License set forth in <a href="#section-4">Section 4</a>.c of the IETF Trust&#x27;s
     Legal Provisions Relating to IETF Documents
     (<a href="https://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>).

     This version of this YANG module is part of <a href="/doc/html/rfc6536">RFC 6536</a>; see
     the RFC itself for full legal notices.&quot;;

  revision &quot;2012-02-22&quot; {
<span class="grey"><a href="/doc/html/rfc6536">RFC 6536</a>                          NACM                        March 2012</span>

       description
         &quot;Initial version&quot;;
       reference
         &quot;<a href="/doc/html/rfc6536">RFC 6536</a>: Network Configuration Protocol (NETCONF)
                    Access Control Model&quot;;
     }

     /*
      * Extension statements
      */

     extension default-deny-write {
       description
         &quot;Used to indicate that the data model node
          represents a sensitive security system parameter.

          If present, and the NACM module is enabled (i.e.,
          /nacm/enable-nacm object equals &#x27;true&#x27;), the NETCONF server
          will only allow the designated &#x27;recovery session&#x27; to have
          write access to the node.  An explicit access control rule is
          required for all other users.

          The &#x27;default-deny-write&#x27; extension MAY appear within a data
          definition statement.  It is ignored otherwise.&quot;;
     }

     extension default-deny-all {
       description
         &quot;Used to indicate that the data model node
          controls a very sensitive security system parameter.

          If present, and the NACM module is enabled (i.e.,
          /nacm/enable-nacm object equals &#x27;true&#x27;), the NETCONF server
          will only allow the designated &#x27;recovery session&#x27; to have
          read, write, or execute access to the node.  An explicit
          access control rule is required for all other users.

          The &#x27;default-deny-all&#x27; extension MAY appear within a data
          definition statement, &#x27;rpc&#x27; statement, or &#x27;notification&#x27;
          statement.  It is ignored otherwise.&quot;;
     }

     /*
      * Derived types
      */

     typedef user-name-type {
       type string {
<span class="grey"><a href="/doc/html/rfc6536">RFC 6536</a>                          NACM                        March 2012</span>

         length &quot;1..max&quot;;
       }
       description
         &quot;General Purpose Username string.&quot;;
     }

     typedef matchall-string-type {
       type string {
         pattern &quot;\*&quot;;
       }
       description
         &quot;The string containing a single asterisk &#x27;*&#x27; is used
          to conceptually represent all possible values
          for the particular leaf using this data type.&quot;;
     }

     typedef access-operations-type {
       type bits {
         bit create {
           description
             &quot;Any protocol operation that creates a
              new data node.&quot;;
         }
         bit read {
           description
             &quot;Any protocol operation or notification that
              returns the value of a data node.&quot;;
         }
         bit update {
           description
             &quot;Any protocol operation that alters an existing
              data node.&quot;;
         }
         bit delete {
           description
             &quot;Any protocol operation that removes a data node.&quot;;
         }
         bit exec {
           description
             &quot;Execution access to the specified protocol operation.&quot;;
         }
       }
       description
         &quot;NETCONF Access Operation.&quot;;
     }

     typedef group-name-type {
       type string {
<span class="grey"><a href="/doc/html/rfc6536">RFC 6536</a>                          NACM                        March 2012</span>

         length &quot;1..max&quot;;
         pattern &quot;[^\*].*&quot;;
       }
       description
         &quot;Name of administrative group to which
          users can be assigned.&quot;;
     }

     typedef action-type {
       type enumeration {
         enum permit {
           description
             &quot;Requested action is permitted.&quot;;
         }
         enum deny {
           description
             &quot;Requested action is denied.&quot;;
         }
       }
       description
         &quot;Action taken by the server when a particular
          rule matches.&quot;;
     }

     typedef node-instance-identifier {
       type yang:xpath1.0;
       description
         &quot;Path expression used to represent a special
          data node instance identifier string.

          A node-instance-identifier value is an
          unrestricted YANG instance-identifier expression.
          All the same rules as an instance-identifier apply
          except predicates for keys are optional.  If a key
          predicate is missing, then the node-instance-identifier
          represents all possible server instances for that key.

          This XPath expression is evaluated in the following context:

           o  The set of namespace declarations are those in scope on
              the leaf element where this type is used.

           o  The set of variable bindings contains one variable,
              &#x27;USER&#x27;, which contains the name of the user of the current
               session.

           o  The function library is the core function library, but
              note that due to the syntax restrictions of an
<span class="grey"><a href="/doc/html/rfc6536">RFC 6536</a>                          NACM                        March 2012</span>

              instance-identifier, no functions are allowed.

           o  The context node is the root node in the data tree.&quot;;
     }

     /*
      * Data definition statements
      */

     container nacm {
       nacm:default-deny-all;

       description
         &quot;Parameters for NETCONF Access Control Model.&quot;;

       leaf enable-nacm {
         type boolean;
         default true;
         description
           &quot;Enables or disables all NETCONF access control
            enforcement.  If &#x27;true&#x27;, then enforcement
            is enabled.  If &#x27;false&#x27;, then enforcement
            is disabled.&quot;;
       }

       leaf read-default {
         type action-type;
         default &quot;permit&quot;;
         description
           &quot;Controls whether read access is granted if
            no appropriate rule is found for a
            particular read request.&quot;;
       }

       leaf write-default {
         type action-type;
         default &quot;deny&quot;;
         description
           &quot;Controls whether create, update, or delete access
            is granted if no appropriate rule is found for a
            particular write request.&quot;;
       }

       leaf exec-default {
         type action-type;
         default &quot;permit&quot;;
         description
           &quot;Controls whether exec access is granted if no appropriate
<span class="grey"><a href="/doc/html/rfc6536">RFC 6536</a>                          NACM                        March 2012</span>

            rule is found for a particular protocol operation request.&quot;;
       }

       leaf enable-external-groups {
         type boolean;
         default true;
         description
           &quot;Controls whether the server uses the groups reported by the
            NETCONF transport layer when it assigns the user to a set of
            NACM groups.  If this leaf has the value &#x27;false&#x27;, any group
            names reported by the transport layer are ignored by the
            server.&quot;;
       }

       leaf denied-operations {
         type yang:zero-based-counter32;
         config false;
         mandatory true;
         description
           &quot;Number of times since the server last restarted that a
            protocol operation request was denied.&quot;;
       }

       leaf denied-data-writes {
         type yang:zero-based-counter32;
         config false;
         mandatory true;
         description
           &quot;Number of times since the server last restarted that a
            protocol operation request to alter
            a configuration datastore was denied.&quot;;
       }

       leaf denied-notifications {
         type yang:zero-based-counter32;
         config false;
         mandatory true;
         description
           &quot;Number of times since the server last restarted that
            a notification was dropped for a subscription because
            access to the event type was denied.&quot;;
       }

       container groups {
         description
           &quot;NETCONF Access Control Groups.&quot;;

         list group {
<span class="grey"><a href="/doc/html/rfc6536">RFC 6536</a>                          NACM                        March 2012</span>

           key name;

           description
             &quot;One NACM Group Entry.  This list will only contain
              configured entries, not any entries learned from
              any transport protocols.&quot;;

           leaf name {
             type group-name-type;
             description
               &quot;Group name associated with this entry.&quot;;
           }

           leaf-list user-name {
             type user-name-type;
             description
               &quot;Each entry identifies the username of
                a member of the group associated with
                this entry.&quot;;
           }
         }
       }

       list rule-list {
         key &quot;name&quot;;
         ordered-by user;
         description
           &quot;An ordered collection of access control rules.&quot;;

         leaf name {
           type string {
             length &quot;1..max&quot;;
           }
           description
             &quot;Arbitrary name assigned to the rule-list.&quot;;
         }
         leaf-list group {
           type union {
             type matchall-string-type;
             type group-name-type;
           }
           description
             &quot;List of administrative groups that will be
              assigned the associated access rights
              defined by the &#x27;rule&#x27; list.

              The string &#x27;*&#x27; indicates that all groups apply to the
              entry.&quot;;
<span class="grey"><a href="/doc/html/rfc6536">RFC 6536</a>                          NACM                        March 2012</span>

         }

         list rule {
           key &quot;name&quot;;
           ordered-by user;
           description
             &quot;One access control rule.

              Rules are processed in user-defined order until a match is
              found.  A rule matches if &#x27;module-name&#x27;, &#x27;rule-type&#x27;, and
              &#x27;access-operations&#x27; match the request.  If a rule
              matches, the &#x27;action&#x27; leaf determines if access is granted
              or not.&quot;;

           leaf name {
             type string {
               length &quot;1..max&quot;;
             }
             description
               &quot;Arbitrary name assigned to the rule.&quot;;
           }

           leaf module-name {
             type union {
               type matchall-string-type;
               type string;
             }
             default &quot;*&quot;;
             description
               &quot;Name of the module associated with this rule.

                This leaf matches if it has the value &#x27;*&#x27; or if the
                object being accessed is defined in the module with the
                specified module name.&quot;;
           }
           choice rule-type {
             description
               &quot;This choice matches if all leafs present in the rule
                match the request.  If no leafs are present, the
                choice matches all requests.&quot;;
             case protocol-operation {
               leaf rpc-name {
                 type union {
                   type matchall-string-type;
                   type string;
                 }
                 description
                   &quot;This leaf matches if it has the value &#x27;*&#x27; or if
<span class="grey"><a href="/doc/html/rfc6536">RFC 6536</a>                          NACM                        March 2012</span>

                    its value equals the requested protocol operation
                    name.&quot;;
               }
             }
             case notification {
               leaf notification-name {
                 type union {
                   type matchall-string-type;
                   type string;
                 }
                 description
                   &quot;This leaf matches if it has the value &#x27;*&#x27; or if its
                    value equals the requested notification name.&quot;;
               }
             }
             case data-node {
               leaf path {
                 type node-instance-identifier;
                 mandatory true;
                 description
                   &quot;Data Node Instance Identifier associated with the
                    data node controlled by this rule.

                    Configuration data or state data instance
                    identifiers start with a top-level data node.  A
                    complete instance identifier is required for this
                    type of path value.

                    The special value &#x27;/&#x27; refers to all possible
                    datastore contents.&quot;;
               }
             }
           }

           leaf access-operations {
             type union {
               type matchall-string-type;
               type access-operations-type;
             }
             default &quot;*&quot;;
             description
               &quot;Access operations associated with this rule.

                This leaf matches if it has the value &#x27;*&#x27; or if the
                bit corresponding to the requested operation is set.&quot;;
           }

           leaf action {
<span class="grey"><a href="/doc/html/rfc6536">RFC 6536</a>                          NACM                        March 2012</span>

             type action-type;
             mandatory true;
             description
               &quot;The access control action associated with the
                rule.  If a rule is determined to match a
                particular request, then this object is used
                to determine whether to permit or deny the
                request.&quot;;
           }

           leaf comment {
             type string;
             description
               &quot;A textual description of the access rule.&quot;;
           }
         }
       }
     }
   }
