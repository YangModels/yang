module ietf-alarms {
  yang-version 1.1;
  namespace &quot;urn:ietf:params:xml:ns:yang:ietf-alarms&quot;;
  prefix al;

  import ietf-yang-types {
    prefix yang;
    reference
      &quot;<a href="/doc/html/rfc6991">RFC 6991</a>: Common YANG Data Types.&quot;;
  }

  organization
    &quot;IETF CCAMP Working Group&quot;;
  contact
    &quot;WG Web:   &lt;<a href="https://trac.ietf.org/trac/ccamp">https://trac.ietf.org/trac/ccamp</a>&gt;
     WG List:  &lt;mailto:<a href="mailto:ccamp@ietf.org">ccamp@ietf.org</a>&gt;

     Editor:   Stefan Vallin
               &lt;mailto:<a href="mailto:stefan@wallan.se">stefan@wallan.se</a>&gt;

     Editor:   Martin Bjorklund
               &lt;mailto:<a href="mailto:mbj@tail-f.com">mbj@tail-f.com</a>&gt;&quot;;
  description
    &quot;This module defines an interface for managing alarms.  Main
     inputs to the module design are the 3GPP Alarm Integration
     Reference Point (IRP), ITU-T X.733, and ANSI/ISA-18.2 alarm
     standards.
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

       Main features of this module include:

         * Alarm list:
                   A list of all alarms.  Cleared alarms stay in
                   the list until explicitly purged.

         * Operator actions on alarms:
                   Acknowledging and closing alarms.

         * Administrative actions on alarms:
                   Purging alarms from the list according to specific
                   criteria.

         * Alarm inventory:
                   A management application can read all
                   alarm types implemented by the system.

         * Alarm shelving:
                   Shelving (blocking) alarms according
                   to specific criteria.

         * Alarm profiles:
                   A management system can attach further
                   information to alarm types, for example,
                   overriding system-default severity
                   levels.

       This module uses a stateful view on alarms.  An alarm is a state
       for a specific resource (note that an alarm is not a
       notification).  An alarm type is a possible alarm state for a
       resource.  For example, the tuple:

         (&#x27;link-alarm&#x27;, &#x27;GigabitEthernet0/25&#x27;)

       is an alarm of type &#x27;link-alarm&#x27; on the resource
       &#x27;GigabitEthernet0/25&#x27;.

       Alarm types are identified using YANG identities and an optional
       string-based qualifier.  The string-based qualifier allows for
       dynamic extension of the statically defined alarm types.  Alarm
       types identify a possible alarm state and not the individual
       notifications.  For example, the traditional &#x27;link-down&#x27; and
       &#x27;link-up&#x27; notifications are two notifications referring to the
       same alarm type &#x27;link-alarm&#x27;.

       With this design, there is no ambiguity about how alarm and
       alarm clear correlation should be performed; notifications that
       report the same resource and alarm type are considered updates
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

       of the same alarm, e.g., clearing an active alarm or changing
       the severity of an alarm.  The instrumentation can update the
       severity and alarm text on an existing alarm.  The above alarm
       example can therefore look like the following:

         ((&#x27;link-alarm&#x27;, &#x27;GigabitEthernet0/25&#x27;),
          warning,
          &#x27;interface down while interface admin state is up&#x27;)

       There is a clear separation between updates on the alarm from
       the underlying resource, like clear, and updates from an
       operator, like acknowledging or closing an alarm:

         ((&#x27;link-alarm&#x27;, &#x27;GigabitEthernet0/25&#x27;),
          warning,
          &#x27;interface down while interface admin state is up&#x27;,
          cleared,
          closed)

       Administrative actions like removing closed alarms older than a
       given time is supported.

       This YANG module does not define how the underlying
       instrumentation detects and clears the specific alarms.  That
       belongs to the Standards Development Organization (SDO) or
       enterprise that owns that specific technology.

       The key words &#x27;MUST&#x27;, &#x27;MUST NOT&#x27;, &#x27;REQUIRED&#x27;, &#x27;SHALL&#x27;, &#x27;SHALL
       NOT&#x27;, &#x27;SHOULD&#x27;, &#x27;SHOULD NOT&#x27;, &#x27;RECOMMENDED&#x27;, &#x27;NOT RECOMMENDED&#x27;,
       &#x27;MAY&#x27;, and &#x27;OPTIONAL&#x27; in this document are to be interpreted as
       described in <a href="/doc/html/bcp14">BCP 14</a> (<a href="/doc/html/rfc2119">RFC 2119</a>) (<a href="/doc/html/rfc8174">RFC 8174</a>) when, and only when,
       they appear in all capitals, as shown here.

       Copyright (c) 2019 IETF Trust and the persons identified as
       authors of the code.  All rights reserved.

       Redistribution and use in source and binary forms, with or
       without modification, is permitted pursuant to, and subject to
       the license terms contained in, the Simplified BSD License set
       forth in <a href="#section-4">Section 4</a>.c of the IETF Trust&#x27;s Legal Provisions
       Relating to IETF Documents
       (<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>).

       This version of this YANG module is part of <a href="/doc/html/rfc8632">RFC 8632</a>; see
       the RFC itself for full legal notices.&quot;;

    revision 2019-09-11 {
      description
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

        &quot;Initial revision.&quot;;
      reference
        &quot;<a href="/doc/html/rfc8632">RFC 8632</a>: A YANG Data Model for Alarm Management&quot;;
    }

    /*
     * Features
     */

    feature operator-actions {
      description
        &quot;This feature indicates that the system supports operator
         states on alarms.&quot;;
    }

    feature alarm-shelving {
      description
        &quot;This feature indicates that the system supports shelving
         (blocking) alarms.

         Alarm shelving may have an impact on server processing
         resources in order to match alarms against shelf
         criteria.&quot;;
    }

    feature alarm-history {
      description
        &quot;This feature indicates that the server maintains a history
         of state changes for each alarm.  For example, if an alarm
         toggles between cleared and active 10 times, these state
         changes are present in a separate list in the alarm.

         Keeping the alarm history may have an impact on server
         memory resources.&quot;;
    }

    feature alarm-summary {
      description
        &quot;This feature indicates that the server summarizes the number
         of alarms per severity and operator state.&quot;;
    }

    feature alarm-profile {
      description
        &quot;The system enables clients to configure further information
         to each alarm type.&quot;;
    }

<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

    feature severity-assignment {
      description
        &quot;The system supports configurable alarm severity levels.&quot;;
      reference
        &quot;ITU-T Recommendation M.3100:
           Generic network information model
         ITU-T Recommendation M.3160:
           Generic, protocol-neutral management information model&quot;;
    }

    feature root-cause-analysis {
      description
        &quot;The system supports identifying candidate root-cause
         resources for an alarm, for example, a disk partition
         root cause for a logger failure alarm.&quot;;
    }

    feature service-impact-analysis {
      description
        &quot;The system supports identifying candidate-impacted
         resources for an alarm, for example, an interface state change
         resulting in a link alarm, which can refer to a link as being
         impacted.&quot;;
    }

    feature alarm-correlation {
      description
        &quot;The system supports correlating/grouping alarms
         that belong together.&quot;;
    }

    /*
     * Identities
     */

    identity alarm-type-id {
      description
        &quot;Base identity for alarm types.  A unique identification of
         the alarm, not including the resource.  Different resources
         can share alarm types.  If the resource reports the same
         alarm type, it is considered to be the same alarm.  The alarm
         type is a simplification of the different X.733 and 3GPP Alarm
         IRP correlation mechanisms, and it allows for
         hierarchical extensions.

         A string-based qualifier can be used in addition to the
         identity in order to have different alarm types based on
         information not known at design time, such as values in
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

         textual SNMP Notification varbinds.

         Standards and vendors can define sub-identities to clearly
         identify specific alarm types.

         This identity is abstract and MUST NOT be used for alarms.&quot;;
    }

    /*
     * Common types
     */

    typedef resource {
      type union {
        type instance-identifier {
          require-instance false;
        }
        type yang:object-identifier;
        type string;
        type yang:uuid;
      }
      description
        &quot;This is an identification of the alarming resource, such as an
         interface.  It should be as fine-grained as possible to both
         guide the operator and guarantee uniqueness of the alarms.

         If the alarming resource is modeled in YANG, this type will
         be an instance-identifier.

         If the resource is an SNMP object, the type will be an
         &#x27;object-identifier&#x27;.

         If the resource is anything else, for example, a distinguished
         name or a Common Information Model (CIM) path, this type will
         be a string.

         If the alarming object is identified by a Universally Unique
         Identifier (UUID), use the uuid type.  Be cautious when using
         this type, since a UUID is hard to use for an operator.

         If the server supports several models, the precedence should
         be in the order as given in the union definition.&quot;;
    }

    typedef resource-match {
      type union {
        type yang:xpath1.0;
        type yang:object-identifier;
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

        type string;
      }
      description
        &quot;This type is used to match resources of type &#x27;resource&#x27;.
         Since the type &#x27;resource&#x27; is a union of different types, the
         &#x27;resource-match&#x27; type is also a union of corresponding types.

         If the type is given as an XPath 1.0 expression, a resource
         of type &#x27;instance-identifier&#x27; matches if the instance is part
         of the node set that is the result of evaluating the XPath 1.0
         expression.  For example, the XPath 1.0 expression:

          /ietf-interfaces:interfaces/ietf-interfaces:interface
              [ietf-interfaces:type=&#x27;ianaift:ethernetCsmacd&#x27;]

         would match the resource instance-identifier:

          /if:interfaces/if:interface[if:name=&#x27;eth1&#x27;],

         assuming that the interface &#x27;eth1&#x27; is of type
         &#x27;ianaift:ethernetCsmacd&#x27;.

         If the type is given as an object identifier, a resource of
         type &#x27;object-identifier&#x27; matches if the match object
         identifier is a prefix of the resource&#x27;s object identifier.
         For example, the value:

          1.3.6.1.2.1.2.2

         would match the resource object identifier:

          1.3.6.1.2.1.2.2.1.1.5

         If the type is given as an UUID or a string, it is interpreted
         as an XML Schema regular expression, which matches a resource
         of type &#x27;yang:uuid&#x27; or &#x27;string&#x27; if the given regular
         expression matches the resource string.

         If the type is given as an XPath expression, it is evaluated
         in the following XPath context:

           o  The set of namespace declarations is the set of prefix
              and namespace pairs for all YANG modules implemented by
              the server, where the prefix is the YANG module name and
              the namespace is as defined by the &#x27;namespace&#x27; statement
              in the YANG module.

              If a leaf of this type is encoded in XML, all namespace
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

              declarations in scope on the leaf element are added to
              the set of namespace declarations.  If a prefix found in
              the XML is already present in the set of namespace
              declarations, the namespace in the XML is used.

           o  The set of variable bindings is empty.

           o  The function library is the core function library, and
              the functions are defined in <a href="/doc/html/rfc7950#section-10">Section&amp;nbsp;10 of RFC 7950</a>.

           o  The context node is the root node in the data tree.&quot;;
      reference
        &quot;XML Schema Part 2: Datatypes Second Edition,
           World Wide Web Consortium Recommendation
           REC-xmlschema-2-20041028&quot;;
    }

    typedef alarm-text {
      type string;
      description
        &quot;The string used to inform operators about the alarm.  This
         MUST contain enough information for an operator to be able to
         understand the problem and how to resolve it.  If this string
         contains structure, this format should be clearly documented
         for programs to be able to parse that information.&quot;;
    }

    typedef severity {
      type enumeration {
        enum indeterminate {
          value 2;
          description
            &quot;Indicates that the severity level could not be
             determined.  This level SHOULD be avoided.&quot;;
        }
        enum warning {
          value 3;
          description
            &quot;The &#x27;warning&#x27; severity level indicates the detection of a
             potential or impending service-affecting fault, before any
             significant effects have been felt.  Action should be
             taken to further diagnose (if necessary) and correct the
             problem in order to prevent it from becoming a more
             serious service-affecting fault.&quot;;
        }
        enum minor {
          value 4;
          description
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

            &quot;The &#x27;minor&#x27; severity level indicates the existence of a
             non-service-affecting fault condition and that corrective
             action should be taken in order to prevent a more serious
             (for example, service-affecting) fault.  Such a severity
             can be reported, for example, when the detected alarm
             condition is not currently degrading the capacity of the
             resource.&quot;;
        }
        enum major {
          value 5;
          description
            &quot;The &#x27;major&#x27; severity level indicates that a service-
             affecting condition has developed and an urgent corrective
             action is required.  Such a severity can be reported, for
             example, when there is a severe degradation in the
             capability of the resource and its full capability must be
             restored.&quot;;
        }
        enum critical {
          value 6;
          description
            &quot;The &#x27;critical&#x27; severity level indicates that a service-
             affecting condition has occurred and an immediate
             corrective action is required.  Such a severity can be
             reported, for example, when a resource becomes totally out
             of service and its capability must be restored.&quot;;
        }
      }
      description
        &quot;The severity level of the alarm.  Note well that the value
         &#x27;clear&#x27; is not included.  Whether or not an alarm is cleared
         is a separate boolean flag.&quot;;
      reference
        &quot;ITU-T Recommendation X.733: Information Technology
           - Open Systems Interconnection
           - System Management: Alarm Reporting Function&quot;;
    }

    typedef severity-with-clear {
      type union {
        type enumeration {
          enum cleared {
            value 1;
            description
              &quot;The alarm is cleared by the instrumentation.&quot;;
          }
        }
        type severity;
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

      }
      description
        &quot;The severity level of the alarm including clear.  This is used
         only in notifications reporting state changes for an alarm.&quot;;
    }

    typedef writable-operator-state {
      type enumeration {
        enum none {
          value 1;
          description
            &quot;The alarm is not being taken care of.&quot;;
        }
        enum ack {
          value 2;
          description
            &quot;The alarm is being taken care of.  Corrective action not
             taken yet or has failed&quot;;
        }
        enum closed {
          value 3;
          description
            &quot;Corrective action taken successfully.&quot;;
        }
      }
      description
        &quot;Operator states on an alarm.  The &#x27;closed&#x27; state indicates
         that an operator considers the alarm being resolved.  This is
         separate from the alarm&#x27;s &#x27;is-cleared&#x27; leaf.&quot;;
    }

    typedef operator-state {
      type union {
        type writable-operator-state;
        type enumeration {
          enum shelved {
            value 4;
            description
              &quot;The alarm is shelved.  Alarms in /alarms/shelved-alarms/
               MUST be assigned this operator state by the server as
               the last entry in the &#x27;operator-state-change&#x27; list.  The
               text for that entry SHOULD include the shelf name.&quot;;
          }
          enum un-shelved {
            value 5;
            description
              &quot;The alarm is moved back to &#x27;alarm-list&#x27; from a shelf.
               Alarms that are moved from /alarms/shelved-alarms/ to
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

               /alarms/alarm-list MUST be assigned this state by the
               server as the last entry in the &#x27;operator-state-change&#x27;
               list.  The text for that entry SHOULD include the shelf
               name.&quot;;
          }
        }
      }
      description
        &quot;Operator states on an alarm.  The &#x27;closed&#x27; state indicates
         that an operator considers the alarm being resolved.  This is
         separate from the alarm&#x27;s &#x27;is-cleared&#x27; leaf.&quot;;
    }

    /* Alarm type */

    typedef alarm-type-id {
      type identityref {
        base alarm-type-id;
      }
      description
        &quot;Identifies an alarm type.  The description of the alarm type
         id MUST indicate whether or not the alarm type is abstract.
         An abstract alarm type is used as a base for other alarm type
         ids and will not be used as a value for an alarm or be present
         in the alarm inventory.&quot;;
    }

    typedef alarm-type-qualifier {
      type string;
      description
        &quot;If an alarm type cannot be fully specified at design time by
         &#x27;alarm-type-id&#x27;, this string qualifier is used in addition to
         fully define a unique alarm type.

         The definition of alarm qualifiers is considered to be part of
         the instrumentation and is out of scope for this module.  An
         empty string is used when this is part of a key.&quot;;
    }

    /*
     * Groupings
     */

    grouping common-alarm-parameters {
      description
        &quot;Common parameters for an alarm.

         This grouping is used both in the alarm list and in the
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

         notification representing an alarm-state change.&quot;;
      leaf resource {
        type resource;
        mandatory true;
        description
          &quot;The alarming resource.  See also &#x27;alt-resource&#x27;.  This could
           be, for example, a reference to the alarming interface&quot;;
      }
      leaf alarm-type-id {
        type alarm-type-id;
        mandatory true;
        description
          &quot;This leaf and the leaf &#x27;alarm-type-qualifier&#x27; together
           provide a unique identification of the alarm type.&quot;;
      }
      leaf alarm-type-qualifier {
        type alarm-type-qualifier;
        description
          &quot;This leaf is used when the &#x27;alarm-type-id&#x27; leaf cannot
           uniquely identify the alarm type.  Normally, this is not the
           case, and this leaf is the empty string.&quot;;
      }
      leaf-list alt-resource {
        type resource;
        description
          &quot;Used if the alarming resource is available over other
           interfaces.  This field can contain SNMP OIDs, CIM paths, or
           3GPP distinguished names, for example.&quot;;
      }
      list related-alarm {
        if-feature &quot;alarm-correlation&quot;;
        key &quot;resource alarm-type-id alarm-type-qualifier&quot;;
        description
          &quot;References to related alarms.  Note that the related alarm
           might have been purged from the alarm list.&quot;;
        leaf resource {
          type leafref {
            path &quot;/alarms/alarm-list/alarm/resource&quot;;
            require-instance false;
          }
          description
            &quot;The alarming resource for the related alarm.&quot;;
        }
        leaf alarm-type-id {
          type leafref {
            path &quot;/alarms/alarm-list/alarm&quot;
               + &quot;[resource=current()/../resource]&quot;
               + &quot;/alarm-type-id&quot;;
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

            require-instance false;
          }
          description
            &quot;The alarm type identifier for the related alarm.&quot;;
        }
        leaf alarm-type-qualifier {
          type leafref {
            path &quot;/alarms/alarm-list/alarm&quot;
               + &quot;[resource=current()/../resource]&quot;
               + &quot;[alarm-type-id=current()/../alarm-type-id]&quot;
               + &quot;/alarm-type-qualifier&quot;;
            require-instance false;
          }
          description
            &quot;The alarm qualifier for the related alarm.&quot;;
        }
      }
      leaf-list impacted-resource {
        if-feature &quot;service-impact-analysis&quot;;
        type resource;
        description
          &quot;Resources that might be affected by this alarm.  If the
           system creates an alarm on a resource and also has a mapping
           to other resources that might be impacted, these resources
           can be listed in this leaf-list.  In this way, the system
           can create one alarm instead of several.  For example, if an
           interface has an alarm, the &#x27;impacted-resource&#x27; can
           reference the aggregated port channels.&quot;;
      }
      leaf-list root-cause-resource {
        if-feature &quot;root-cause-analysis&quot;;
        type resource;
        description
          &quot;Resources that are candidates for causing the alarm.  If the
           system has a mechanism to understand the candidate root
           causes of an alarm, this leaf-list can be used to list the
           root-cause candidate resources.  In this way, the system can
           create one alarm instead of several.  An example might be a
           logging system (alarm resource) that fails; the alarm can
           reference the file system in the &#x27;root-cause-resource&#x27;
           leaf-list.  Note that the intended use is not to also send
           an alarm with the &#x27;root-cause-resource&#x27; as an alarming
           resource.  The &#x27;root-cause-resource&#x27; leaf-list is a hint and
           should not also generate an alarm for the same problem.&quot;;
      }
    }

    grouping alarm-state-change-parameters {
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

      description
        &quot;Parameters for an alarm-state change.

         This grouping is used both in the alarm list&#x27;s status-change
         list and in the notification representing an alarm-state
         change.&quot;;
      leaf time {
        type yang:date-and-time;
        mandatory true;
        description
          &quot;The time the status of the alarm changed.  The value
           represents the time the real alarm-state change appeared in
           the resource and not when it was added to the alarm
           list.  The /alarm-list/alarm/last-changed MUST be set to the
           same value.&quot;;
      }
      leaf perceived-severity {
        type severity-with-clear;
        mandatory true;
        description
          &quot;The severity of the alarm as defined by X.733.  Note that
           this may not be the original severity since the alarm may
           have changed severity.&quot;;
        reference
          &quot;ITU-T Recommendation X.733: Information Technology
             - Open Systems Interconnection
             - System Management: Alarm Reporting Function&quot;;
      }
      leaf alarm-text {
        type alarm-text;
        mandatory true;
        description
          &quot;A user-friendly text describing the alarm-state change.&quot;;
        reference
          &quot;ITU-T Recommendation X.733: Information Technology
             - Open Systems Interconnection
             - System Management: Alarm Reporting Function&quot;;
      }
    }

    grouping operator-parameters {
      description
        &quot;This grouping defines parameters that can be changed by an
         operator.&quot;;
      leaf time {
        type yang:date-and-time;
        mandatory true;
        description
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

          &quot;Timestamp for operator action on the alarm.&quot;;
      }
      leaf operator {
        type string;
        mandatory true;
        description
          &quot;The name of the operator that has acted on this alarm.&quot;;
      }
      leaf state {
        type operator-state;
        mandatory true;
        description
          &quot;The operator&#x27;s view of the alarm state.&quot;;
      }
      leaf text {
        type string;
        description
          &quot;Additional optional textual information provided by the
           operator.&quot;;
      }
    }

    grouping resource-alarm-parameters {
      description
        &quot;Alarm parameters that originate from the resource view.&quot;;
      leaf is-cleared {
        type boolean;
        mandatory true;
        description
          &quot;Indicates the current clearance state of the alarm.  An
           alarm might toggle from active alarm to cleared alarm and
           back to active again.&quot;;
      }
      leaf last-raised {
        type yang:date-and-time;
        mandatory true;
        description
          &quot;An alarm may change severity level and toggle between
           active and cleared during its lifetime.  This leaf indicates
           the last time it was raised (&#x27;is-cleared&#x27; = &#x27;false&#x27;).&quot;;
      }
      leaf last-changed {
        type yang:date-and-time;
        mandatory true;
        description
          &quot;A timestamp when the &#x27;status-change&#x27; or
           &#x27;operator-state-change&#x27; list was last changed.&quot;;
      }
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

      leaf perceived-severity {
        type severity;
        mandatory true;
        description
          &quot;The last severity of the alarm.

           If an alarm was raised with severity &#x27;warning&#x27; but later
           changed to &#x27;major&#x27;, this leaf will show &#x27;major&#x27;.&quot;;
      }
      leaf alarm-text {
        type alarm-text;
        mandatory true;
        description
          &quot;The last reported alarm text.  This text should contain
           information for an operator to be able to understand the
           problem and how to resolve it.&quot;;
      }
      list status-change {
        if-feature &quot;alarm-history&quot;;
        key &quot;time&quot;;
        min-elements 1;
        description
          &quot;A list of status-change events for this alarm.

           The entry with latest timestamp in this list MUST
           correspond to the leafs &#x27;is-cleared&#x27;, &#x27;perceived-severity&#x27;,
           and &#x27;alarm-text&#x27; for the alarm.

           This list is ordered according to the timestamps of alarm
           state changes.  The first item corresponds to the latest
           state change.

           The following state changes create an entry in this
           list:
           - changed severity (warning, minor, major, critical)
           - clearance status; this also updates the &#x27;is-cleared&#x27;
             leaf
           - alarm-text update&quot;;
        uses alarm-state-change-parameters;
      }
    }

    grouping filter-input {
      description
        &quot;Grouping to specify a filter construct on alarm information.&quot;;
      leaf alarm-clearance-status {
        type enumeration {
          enum any {
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

            description
              &quot;Ignore alarm-clearance status.&quot;;
          }
          enum cleared {
            description
              &quot;Filter cleared alarms.&quot;;
          }
          enum not-cleared {
            description
              &quot;Filter not-cleared alarms.&quot;;
          }
        }
        mandatory true;
        description
          &quot;The clearance status of the alarm.&quot;;
      }
      container older-than {
        presence &quot;Age specification&quot;;
        description
          &quot;Matches the &#x27;last-status-change&#x27; leaf in the alarm.&quot;;
        choice age-spec {
          description
            &quot;Filter using date and time age.&quot;;
          case seconds {
            leaf seconds {
              type uint16;
              description
                &quot;Age expressed in seconds.&quot;;
            }
          }
          case minutes {
            leaf minutes {
              type uint16;
              description
                &quot;Age expressed in minutes.&quot;;
            }
          }
          case hours {
            leaf hours {
              type uint16;
              description
                &quot;Age expressed in hours.&quot;;
            }
          }
          case days {
            leaf days {
              type uint16;
              description
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

                &quot;Age expressed in days.&quot;;
            }
          }
          case weeks {
            leaf weeks {
              type uint16;
              description
                &quot;Age expressed in weeks.&quot;;
            }
          }
        }
      }
      container severity {
        presence &quot;Severity filter&quot;;
        choice sev-spec {
          description
            &quot;Filter based on severity level.&quot;;
          leaf below {
            type severity;
            description
              &quot;Severity less than this leaf.&quot;;
          }
          leaf is {
            type severity;
            description
              &quot;Severity level equal to this leaf.&quot;;
          }
          leaf above {
            type severity;
            description
              &quot;Severity level higher than this leaf.&quot;;
          }
        }
        description
          &quot;Filter based on severity.&quot;;
      }
      container operator-state-filter {
        if-feature &quot;operator-actions&quot;;
        presence &quot;Operator state filter&quot;;
        leaf state {
          type operator-state;
          description
            &quot;Filter on operator state.&quot;;
        }
        leaf user {
          type string;
          description
            &quot;Filter based on which operator.&quot;;
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

        }
        description
          &quot;Filter based on operator state.&quot;;
      }
    }

    /*
     * The /alarms data tree
     */

    container alarms {
      description
        &quot;The top container for this module.&quot;;
      container control {
        description
          &quot;Configuration to control the alarm behavior.&quot;;
        leaf max-alarm-status-changes {
          type union {
            type uint16;
            type enumeration {
              enum infinite {
                description
                  &quot;The status-change entries are accumulated
                   infinitely.&quot;;
              }
            }
          }
          default &quot;32&quot;;
          description
            &quot;The &#x27;status-change&#x27; entries are kept in a circular list
             per alarm.  When this number is exceeded, the oldest
             status change entry is automatically removed.  If the
             value is &#x27;infinite&#x27;, the status-change entries are
             accumulated infinitely.&quot;;
        }
        leaf notify-status-changes {
          type enumeration {
            enum all-state-changes {
              description
                &quot;Send notifications for all status changes.&quot;;
            }
            enum raise-and-clear {
              description
                &quot;Send notifications only for raise, clear, and
                 re-raise.  Notifications for severity-level changes or
                 alarm-text changes are not sent.&quot;;
            }
            enum severity-level {
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

              description
                &quot;Only send notifications for alarm-state changes
                 crossing the level specified in
                 &#x27;notify-severity-level&#x27;.  Always send clear
                 notifications.&quot;;
            }
          }
          must &#x27;. != &quot;severity-level&quot; or ../notify-severity-level&#x27; {
            description
              &quot;When notify-status-changes is &#x27;severity-level&#x27;, a value
               must be given for &#x27;notify-severity-level&#x27;.&quot;;
          }
          default &quot;all-state-changes&quot;;
          description
            &quot;This leaf controls the notifications sent for alarm status
             updates.  There are three options:

             1.  Notifications are sent for all updates, severity-level
                 changes, and alarm-text changes.

             2.  Notifications are only sent for alarm raise and clear.

             3.  Notifications are sent for status changes equal to or
                 above the specified severity level.  Clear
                 notifications shall always be sent.  Notifications
                 shall also be sent for state changes that make an
                 alarm less severe than the specified level.

             For example, in option 3, assume that the severity level
             is set to major and that the alarm has the following state
             changes:

             [(Time, severity, clear)]:
             [(T1, major, -), (T2, minor, -), (T3, warning, -),
              (T4, minor, -), (T5, major, -), (T6, critical, -),
              (T7, major.  -), (T8, major, clear)]

             In that case, notifications will be sent at times
             T1, T2, T5, T6, T7, and T8.&quot;;
        }
        leaf notify-severity-level {
          when &#x27;../notify-status-changes = &quot;severity-level&quot;&#x27;;
          type severity;
          description
            &quot;Only send notifications for alarm-state changes crossing
             the specified level.  Always send clear notifications.&quot;;
        }
        container alarm-shelving {
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

          if-feature &quot;alarm-shelving&quot;;
          description
            &quot;The &#x27;alarm-shelving/shelf&#x27; list is used to shelve
             (block/filter) alarms.  The conditions in the shelf
             criteria are logically ANDed.  The first matching shelf is
             used, and an alarm is shelved only for this first match.
             Matching alarms MUST appear in the
             /alarms/shelved-alarms/shelved-alarm list, and
             non-matching /alarms MUST appear in the
             /alarms/alarm-list/alarm list.  The server does not send
             any notifications for shelved alarms.

             The server MUST maintain states (e.g., severity
             changes) for the shelved alarms.

             Alarms that match the criteria shall have an
             operator state &#x27;shelved&#x27;.  When the shelf
             configuration removes an alarm from the shelf, the server
             shall add the operator state &#x27;un-shelved&#x27;.&quot;;
          list shelf {
            key &quot;name&quot;;
            ordered-by user;
            leaf name {
              type string;
              description
                &quot;An arbitrary name for the alarm shelf.&quot;;
            }
            description
              &quot;Each entry defines the criteria for shelving alarms.
               Criteria are ANDed.  If no criteria are specified,
               all alarms will be shelved.&quot;;
            leaf-list resource {
              type resource-match;
              description
                &quot;Shelve alarms for matching resources.&quot;;
            }
            list alarm-type {
              key &quot;alarm-type-id alarm-type-qualifier-match&quot;;
              description
                &quot;Any alarm matching the combined criteria of
                 &#x27;alarm-type-id&#x27; and &#x27;alarm-type-qualifier-match&#x27;
                 MUST be matched.&quot;;
              leaf alarm-type-id {
                type alarm-type-id;
                description
                  &quot;Shelve all alarms that have an &#x27;alarm-type-id&#x27; that
                   is equal to or derived from the given
                   &#x27;alarm-type-id&#x27;.&quot;;
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

              }
              leaf alarm-type-qualifier-match {
                type string;
                description
                  &quot;An XML Schema regular expression that is used to
                   match an alarm type qualifier.  Shelve all alarms
                   that match this regular expression for the alarm
                   type qualifier.&quot;;
                reference
                  &quot;XML Schema Part 2: Datatypes Second Edition,
                     World Wide Web Consortium Recommendation
                     REC-xmlschema-2-20041028&quot;;
              }
            }
            leaf description {
              type string;
              description
                &quot;An optional textual description of the shelf.  This
                 description should include the reason for shelving
                 these alarms.&quot;;
            }
          }
        }
      }
      container alarm-inventory {
        config false;
        description
          &quot;The &#x27;alarm-inventory/alarm-type&#x27; list contains all possible
           alarm types for the system.

           If the system knows for which resources a specific alarm
           type can appear, it is also identified in the inventory.
           The list also tells if each alarm type has a corresponding
           clear state.  The inventory shall only contain concrete
           alarm types.

           The alarm inventory MUST be updated by the system when new
           alarms can appear.  This can be the case when installing new
           software modules or inserting new card types.  A
           notification &#x27;alarm-inventory-changed&#x27; is sent when the
           inventory is changed.&quot;;
        list alarm-type {
          key &quot;alarm-type-id alarm-type-qualifier&quot;;
          description
            &quot;An entry in this list defines a possible alarm.&quot;;
          leaf alarm-type-id {
            type alarm-type-id;
            description
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

              &quot;The statically defined alarm type identifier for this
               possible alarm.&quot;;
          }
          leaf alarm-type-qualifier {
            type alarm-type-qualifier;
            description
              &quot;The optionally dynamically defined alarm type identifier
               for this possible alarm.&quot;;
          }
          leaf-list resource {
            type resource-match;
            description
              &quot;Optionally, specifies for which resources the alarm type
               is valid.&quot;;
          }
          leaf will-clear {
            type boolean;
            mandatory true;
            description
              &quot;This leaf tells the operator if the alarm will be
               cleared when the correct corrective action has been
               taken.  Implementations SHOULD strive for detecting the
               cleared state for all alarm types.

               If this leaf is &#x27;true&#x27;, the operator can monitor the
               alarm until it becomes cleared after the corrective
               action has been taken.

               If this leaf is &#x27;false&#x27;, the operator needs to validate
               that the alarm is no longer active using other
               mechanisms.  Alarms can lack a corresponding clear due
               to missing instrumentation or no logical
               corresponding clear state.&quot;;
          }
          leaf-list severity-level {
            type severity;
            description
              &quot;This leaf-list indicates the possible severity levels of
               this alarm type.  Note well that &#x27;clear&#x27; is not part of
               the severity type.  In general, the severity level
               should be defined by the instrumentation based on the
               dynamic state, rather than being defined statically by
               the alarm type, in order to provide a relevant severity
               level based on dynamic state and context.  However, most
               alarm types have a defined set of possible severity
               levels, and this should be provided here.&quot;;
          }
          leaf description {
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

            type string;
            mandatory true;
            description
              &quot;A description of the possible alarm.  It SHOULD include
               information on possible underlying root causes and
               corrective actions.&quot;;
          }
        }
      }
      container summary {
        if-feature &quot;alarm-summary&quot;;
        config false;
        description
          &quot;This container gives a summary of the number of alarms.&quot;;
        list alarm-summary {
          key &quot;severity&quot;;
          description
            &quot;A global summary of all alarms in the system.  The summary
             does not include shelved alarms.&quot;;
          leaf severity {
            type severity;
            description
              &quot;Alarm summary for this severity level.&quot;;
          }
          leaf total {
            type yang:gauge32;
            description
              &quot;Total number of alarms of this severity level.&quot;;
          }
          leaf not-cleared {
            type yang:gauge32;
            description
              &quot;Total number of alarms of this severity level
               that are not cleared.&quot;;
          }
          leaf cleared {
            type yang:gauge32;
            description
              &quot;For this severity level, the number of alarms that are
               cleared.&quot;;
          }
          leaf cleared-not-closed {
            if-feature &quot;operator-actions&quot;;
            type yang:gauge32;
            description
              &quot;For this severity level, the number of alarms that are
               cleared but not closed.&quot;;
          }
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

          leaf cleared-closed {
            if-feature &quot;operator-actions&quot;;
            type yang:gauge32;
            description
              &quot;For this severity level, the number of alarms that are
               cleared and closed.&quot;;
          }
          leaf not-cleared-closed {
            if-feature &quot;operator-actions&quot;;
            type yang:gauge32;
            description
              &quot;For this severity level, the number of alarms that are
               not cleared but closed.&quot;;
          }
          leaf not-cleared-not-closed {
            if-feature &quot;operator-actions&quot;;
            type yang:gauge32;
            description
              &quot;For this severity level, the number of alarms that are
               not cleared and not closed.&quot;;
          }
        }
        leaf shelves-active {
          if-feature &quot;alarm-shelving&quot;;
          type empty;
          description
            &quot;This is a hint to the operator that there are active
             alarm shelves.  This leaf MUST exist if the
             /alarms/shelved-alarms/number-of-shelved-alarms is &gt; 0.&quot;;
        }
      }
      container alarm-list {
        config false;
        description
          &quot;The alarms in the system.&quot;;
        leaf number-of-alarms {
          type yang:gauge32;
          description
            &quot;This object shows the total number of
             alarms in the system, i.e., the total number
             of entries in the alarm list.&quot;;
        }
        leaf last-changed {
          type yang:date-and-time;
          description
            &quot;A timestamp when the alarm list was last
             changed.  The value can be used by a manager to
             initiate an alarm resynchronization procedure.&quot;;
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

        }
        list alarm {
          key &quot;resource alarm-type-id alarm-type-qualifier&quot;;
          description
            &quot;The list of alarms.  Each entry in the list holds one
             alarm for a given alarm type and resource.  An alarm can
             be updated from the underlying resource or by the user.
             The following leafs are maintained by the resource:
             &#x27;is-cleared&#x27;, &#x27;last-change&#x27;, &#x27;perceived-severity&#x27;, and
             &#x27;alarm-text&#x27;.  An operator can change &#x27;operator-state&#x27; and
             &#x27;operator-text&#x27;.

             Entries appear in the alarm list the first time an alarm
             becomes active for a given alarm type and resource.
             Entries do not get deleted when the alarm is cleared.
             Clear status is represented as a boolean flag.

             Alarm entries are removed, i.e., purged, from the list by
             an explicit purge action.  For example, purge all alarms
             that are cleared and in closed operator state that are
             older than 24 hours.  Purged alarms are removed from the
             alarm list.  If the alarm resource state changes after a
             purge, the alarm will reappear in the alarm list.

             Systems may also remove alarms based on locally configured
             policies; this is out of scope for this module.&quot;;
          uses common-alarm-parameters;
          leaf time-created {
            type yang:date-and-time;
            mandatory true;
            description
              &quot;The timestamp when this alarm entry was created.  This
               represents the first time the alarm appeared; it can
               also represent that the alarm reappeared after a purge.
               Further state changes of the same alarm do not change
               this leaf; these changes will update the &#x27;last-changed&#x27;
               leaf.&quot;;
          }
          uses resource-alarm-parameters;
          list operator-state-change {
            if-feature &quot;operator-actions&quot;;
            key &quot;time&quot;;
            description
              &quot;This list is used by operators to indicate the state of
               human intervention on an alarm.  For example, if an
               operator has seen an alarm, the operator can add a new
               item to this list indicating that the alarm is
               acknowledged.&quot;;
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

            uses operator-parameters;
          }
          action set-operator-state {
            if-feature &quot;operator-actions&quot;;
            description
              &quot;This is a means for the operator to indicate the level
               of human intervention on an alarm.&quot;;
            input {
              leaf state {
                type writable-operator-state;
                mandatory true;
                description
                  &quot;Set this operator state.&quot;;
              }
              leaf text {
                type string;
                description
                  &quot;Additional optional textual information.&quot;;
              }
            }
          }
          notification operator-action {
            if-feature &quot;operator-actions&quot;;
            description
              &quot;This notification is used to report that an operator
               acted upon an alarm.&quot;;
            uses operator-parameters;
          }
        }
        action purge-alarms {
          description
            &quot;This operation requests that the server delete entries
             from the alarm list according to the supplied criteria.

             Typically, this operation is used to delete alarms that
             are in closed operator state and older than a specified
             time.

             The number of purged alarms is returned as an output
             parameter.&quot;;
          input {
            uses filter-input;
          }
          output {
            leaf purged-alarms {
              type uint32;
              description
                &quot;Number of purged alarms.&quot;;
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

            }
          }
        }
        action compress-alarms {
          if-feature &quot;alarm-history&quot;;
          description
            &quot;This operation requests that the server compress
             entries in the alarm list by removing all but the
             latest &#x27;status-change&#x27; entry for all matching alarms.
             Conditions in the input are logically ANDed.  If no
             input condition is given, all alarms are compressed.&quot;;
          input {
            leaf resource {
              type resource-match;
              description
                &quot;Compress the alarms matching this resource.&quot;;
            }
            leaf alarm-type-id {
              type leafref {
                path &quot;/alarms/alarm-list/alarm/alarm-type-id&quot;;
                require-instance false;
              }
              description
                &quot;Compress alarms with this &#x27;alarm-type-id&#x27;.&quot;;
            }
            leaf alarm-type-qualifier {
              type leafref {
                path &quot;/alarms/alarm-list/alarm/alarm-type-qualifier&quot;;
                require-instance false;
              }
              description
                &quot;Compress the alarms with this
                 &#x27;alarm-type-qualifier&#x27;.&quot;;
            }
          }
          output {
            leaf compressed-alarms {
              type uint32;
              description
                &quot;Number of compressed alarm entries.&quot;;
            }
          }
        }
      }
      container shelved-alarms {
        if-feature &quot;alarm-shelving&quot;;
        config false;
        description
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

          &quot;The shelved alarms.  Alarms appear here if they match the
           criteria in /alarms/control/alarm-shelving.  This list does
           not generate any notifications.  The list represents alarms
           that are considered not relevant by the operator.  Alarms in
           this list have an &#x27;operator-state&#x27; of &#x27;shelved&#x27;.  This
           cannot be changed.&quot;;
        leaf number-of-shelved-alarms {
          type yang:gauge32;
          description
            &quot;This object shows the total number of current
             alarms, i.e., the total number of entries
             in the alarm list.&quot;;
        }
        leaf shelved-alarms-last-changed {
          type yang:date-and-time;
          description
            &quot;A timestamp when the shelved-alarm list was last changed.
             The value can be used by a manager to initiate an alarm
             resynchronization procedure.&quot;;
        }
        list shelved-alarm {
          key &quot;resource alarm-type-id alarm-type-qualifier&quot;;
          description
            &quot;The list of shelved alarms.  Shelved alarms can only be
             updated from the underlying resource; no operator actions
             are supported.&quot;;
          uses common-alarm-parameters;
          leaf shelf-name {
            type leafref {
              path &quot;/alarms/control/alarm-shelving/shelf/name&quot;;
              require-instance false;
            }
            description
              &quot;The name of the shelf.&quot;;
          }
          uses resource-alarm-parameters;
          list operator-state-change {
            if-feature &quot;operator-actions&quot;;
            key &quot;time&quot;;
            description
              &quot;This list is used by operators to indicate the state of
               human intervention on an alarm.  For shelved alarms, the
               system has set the list item in the list to &#x27;shelved&#x27;.&quot;;
            uses operator-parameters;
          }
        }
        action purge-shelved-alarms {
          description
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

            &quot;This operation requests that the server delete entries from
             the shelved-alarm list according to the supplied criteria.
             In the shelved-alarm list, it makes sense to delete alarms
             that are not relevant anymore.

             The number of purged alarms is returned as an output
             parameter.&quot;;
          input {
            uses filter-input;
          }
          output {
            leaf purged-alarms {
              type uint32;
              description
                &quot;Number of purged alarms.&quot;;
            }
          }
        }
        action compress-shelved-alarms {
          if-feature &quot;alarm-history&quot;;
          description
            &quot;This operation requests that the server compress entries
             in the shelved-alarm list by removing all but the latest
             &#x27;status-change&#x27; entry for all matching shelved alarms.
             Conditions in the input are logically ANDed.  If no input
             condition is given, all alarms are compressed.&quot;;
          input {
            leaf resource {
              type leafref {
                path &quot;/alarms/shelved-alarms/shelved-alarm/resource&quot;;
                require-instance false;
              }
              description
                &quot;Compress the alarms with this resource.&quot;;
            }
            leaf alarm-type-id {
              type leafref {
                path &quot;/alarms/shelved-alarms/shelved-alarm&quot;
                   + &quot;/alarm-type-id&quot;;
                require-instance false;
              }
              description
                &quot;Compress alarms with this &#x27;alarm-type-id&#x27;.&quot;;
            }
            leaf alarm-type-qualifier {
              type leafref {
                path &quot;/alarms/shelved-alarms/shelved-alarm&quot;
                   + &quot;/alarm-type-qualifier&quot;;
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

                require-instance false;
              }
              description
                &quot;Compress the alarms with this
                 &#x27;alarm-type-qualifier&#x27;.&quot;;
            }
          }
          output {
            leaf compressed-alarms {
              type uint32;
              description
                &quot;Number of compressed alarm entries.&quot;;
            }
          }
        }
      }
      list alarm-profile {
        if-feature &quot;alarm-profile&quot;;
        key &quot;alarm-type-id alarm-type-qualifier-match resource&quot;;
        ordered-by user;
        description
          &quot;This list is used to assign further information or
           configuration for each alarm type.  This module supports a
           mechanism where the client can override the system-default
           alarm severity levels.  The &#x27;alarm-profile&#x27; is also a useful
           augmentation point for specific additions to alarm types.&quot;;
        leaf alarm-type-id {
          type alarm-type-id;
          description
            &quot;The alarm type identifier to match.&quot;;
        }
        leaf alarm-type-qualifier-match {
          type string;
          description
            &quot;An XML Schema regular expression that is used to match the
             alarm type qualifier.&quot;;
          reference
            &quot;XML Schema Part 2: Datatypes Second Edition,
               World Wide Web Consortium Recommendation
               REC-xmlschema-2-20041028&quot;;
        }
        leaf resource {
          type resource-match;
          description
            &quot;Specifies which resources to match.&quot;;
        }
        leaf description {
          type string;
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

          mandatory true;
          description
            &quot;A description of the alarm profile.&quot;;
        }
        container alarm-severity-assignment-profile {
          if-feature &quot;severity-assignment&quot;;
          description
            &quot;The client can override the system-default severity
             level.&quot;;
          reference
            &quot;ITU-T Recommendation M.3100:
               Generic network information model
             ITU-T Recommendation M.3160:
               Generic, protocol-neutral management information model&quot;;
          leaf-list severity-level {
            type severity;
            ordered-by user;
            description
              &quot;Specifies the configured severity level(s) for the
               matching alarm.  If the alarm has several severity
               levels, the leaf-list shall be given in rising severity
               order.  The original M3100/M3160 ASAP function only
               allows for a one-to-one mapping between alarm type and
               severity, but since YANG module supports stateful
               alarms, the mapping must allow for several severity
               levels.

               Assume a high-utilization alarm type with two thresholds
               with the system-default severity levels of threshold1 =
               warning and threshold2 = minor.  Setting this leaf-list
               to (minor, major) will assign the severity levels as
               threshold1 = minor and threshold2 = major&quot;;
          }
        }
      }
    }

    /*
     * Notifications
     */

    notification alarm-notification {
      description
        &quot;This notification is used to report a state change for an
         alarm.  The same notification is used for reporting a newly
         raised alarm, a cleared alarm, or changing the text and/or
         severity of an existing alarm.&quot;;
      uses common-alarm-parameters;
<span class="grey"><a href="/doc/html/rfc8632">RFC 8632</a>         A YANG Data Model for Alarm Management   September 2019</span>

      uses alarm-state-change-parameters;
    }

    notification alarm-inventory-changed {
      description
        &quot;This notification is used to report that the list of possible
         alarms has changed.  This can happen when, for example, a new
         software module is installed or a new physical card is
         inserted.&quot;;
    }
  }
