module ietf-i2rs-rib {
  namespace "urn:ietf:params:xml:ns:yang:ietf-i2rs-rib";
  // replace with iana namespace when assigned
  prefix "iir";

  import ietf-inet-types {
    prefix inet;
    //rfc6991
  }

  import ietf-interfaces {
    prefix "if";
  }

  import ietf-yang-types {
    prefix yang;
  }

  organization
    "IETF I2RS (Interface to Routing System) Working Group";
  contact
    "WG Web:   <http://tools.ietf.org/wg/i2rs/>
     WG List:  <mailto:i2rs@ietf.org>

     WG Chair: Susan Hares
               <mailto:shares@ndzh.com>

     WG Chair: Russ White
               <mailto:russ@riw.us>

     Editor:   Lixing Wang
               <mailto:wang_little_star@sina.com>

     Editor:   Hariharan Ananthakrishnan
               <mailto:hari@packetdesign.com>

     Editor:   Mach(Guoyi) Chen
               <mailto:mach.chen@huawei.com>

     Editor:   Amit Dass
               <mailto:amit.dass@ericsson.com>

     Editor:   Sriganesh Kini
               <mailto:sriganesh.kini@ericsson.com>
     Editor:   Nitin Bahadur
               <mailto:nitin_bahadur@yahoo.com>";
  description
    "This module defines a YANG data model for
     Routing Information Base (RIB) that aligns
     with the I2RS RIB information model.";
  revision "2016-07-04" {
    description "initial revision";
    reference "draft-ietf-i2rs-data-model-06";
  }

  //Features
  feature nexthop-tunnel {
    description
      "This feature means that a node supports
       tunnel nexthop capability.";
  }

  feature nexthop-chain {
    description
      "This feature means that a node supports
       chain nexthop capability.";
  }

  feature nexthop-protection {
    description
      "This feature means that a node supports
       protection nexthop capability.";
  }

  feature nexthop-replicates {
    description
      "This feature means that a node supports
       replicates nexthop capability.";
  }

  feature nexthop-load-balance {
    description
      "This feature means that a node supports
       load balance nexthop capability.";
  }

  feature ipv4-tunnel {
    description
      "This feature means that a node supports
       IPv4 tunnel encapsulation capability.";
  }

  feature ipv6-tunnel {
    description
      "This feature means that a node supports
       IPv6 tunnel encapsulation capability.";
  }

  feature mpls-tunnel {
    description
      "This feature means that a node supports
       MPLS tunnel encapsulation capability.";
  }

  feature vxlan-tunnel {
    description
      "This feature means that a node supports
       VxLAN tunnel encapsulation capability.";
  }

  feature gre-tunnel {
    description
      "This feature means that a node supports
       GRE tunnel encapsulation capability.";
  }

  feature nvgre-tunnel {
    description
      "This feature means that a node supports
       NvGRE tunnel encapsulation capability.";
  }

  feature route-vendor-attributes {
    description
      "This feature means that a node supports
       route vendor attributes.";
  }

  //Identities and Type Definitions
  identity mpls-label-action {
    description
      "Base identity from which all MPLS label
       operations are derived.
       The MPLS label stack operations include:
       push - to add a new label to a label stack,
       pop - to pop the top label from a label stack,
       swap - to exchange the top label of a label
              stack with new label.";
  }

  identity label-push {
    base "mpls-label-action";
     description
      "MPLS label stack operation: push.";
  }

  identity label-pop {
    base "mpls-label-action";
    description
      "MPLS label stack operation: pop.";
  }

  identity label-swap {
    base "mpls-label-action";
    description
      "MPLS label stack operation: swap.";
  }

  typedef mpls-label-action-def {
    type identityref {
      base "mpls-label-action";
    }
    description
      "MPLS label action def.";
  }

  identity tunnel-decap-action {
    description
      "Base identity from which all tunnel decap
       actions are derived.
       Tunnel decap actions include:
       ipv4-decap - to decap an IPv4 tunnel,
       ipv6-decap - to decap an IPv6 tunnel.";
  }

  identity ipv4-decap {
    base "tunnel-decap-action";
    description
      "IPv4 tunnel decap.";
  }

  identity ipv6-decap {
    base "tunnel-decap-action";
    description
      "IPv4 tunnel decap.";
  }

  typedef tunnel-decap-action-def {
    type identityref {
      base "tunnel-decap-action";
    }
    description
      "Tunnel decap def.";
  }

  identity ttl-action {
    description
      "Base identity from which all TTL
       actions are derived.";
  }

  identity no-action {
    base "ttl-action";
    description
      "Do nothing regarding the TTL.";
  }

  identity copy-to-inner {
    base "ttl-action";
    description
      "Copy the TTL of the outer header
       to the inner header.";
  }

  identity decrease-and-copy-to-inner {
    base "ttl-action";
    description
      "Decrease TTL by one and copy the TTL
       to the inner header.";
  }

  identity decrease-and-copy-to-next {
    base "ttl-action";
    description
      "Decrease TTL by one and copy the TTL
       to the next header.For example: when
       MPLS label swapping, decrease the TTL
       of the inner label and copy it to the
       outer label.";
  }

  typedef ttl-action-def {
    type identityref {
      base "ttl-action";
    }
    description
      "TTL action def.";
  }

  identity hop-limit-action {
    description
      "Base identity from which all hop limit
       actions are derived.";
  }

  identity hop-limit-no-action {
    base "hop-limit-action";
    description
      "Do nothing regarding the hop limit.";
  }

  identity hop-limit-copy-to-inner {
    base "hop-limit-action";
    description
      "Copy the hop limit of the outer header
       to the inner header.";
  }

  typedef hop-limit-action-def {
    type identityref {
      base "hop-limit-action";
    }
    description
      "IPv6 hop limit action def.";
  }

  identity special-nexthop {
    description
      "Base identity from which all special
       nexthops are derived.";
  }

  identity discard {
    base "special-nexthop";
    description
      "This indicates that the network
       device should drop the packet and
       increment a drop counter.";
  }

  identity discard-with-error {
    base "special-nexthop";
    description
      "This indicates that the network
       device should drop the packet,
       increment a drop counter and send
       back an appropriate error message
       (like ICMP error).";
  }

  identity receive {
    base "special-nexthop";
    description
      "This indicates that the traffic is
       destined for the network device.  For
       example, protocol packets or OAM packets.
       All locally destined traffic SHOULD be
       throttled to avoid a denial of service
       attack on the router's control plane. An
       optional rate-limiter can be specified
       to indicate how to throttle traffic
       destined for the control plane.";
  }

  identity cos-value {
    base "special-nexthop";
    description
      "Cos-value special nexthop.";
  }

  typedef special-nexthop-def {
    type identityref {
      base "special-nexthop";
    }
    description
      "Special nexthop def.";
  }

  identity ip-route-match-type {
    description
      "Base identity from which all route
       match types are derived.
       Route match type could be:
       match source, or
       match destination, or
       match source and destination.";
  }

  identity match-ip-src {
    base "ip-route-match-type";
    description
      "Source route match type.";
  }
  identity match-ip-dest {
    base "ip-route-match-type";
    description
      "Destination route match type";
  }
  identity match-ip-src-dest {
    base "ip-route-match-type";
    description
      "Source and Destination route match type";
  }

  typedef ip-route-match-type-def {
    type identityref {
      base "ip-route-match-type";
    }
    description
      "IP route match type def.";
  }

  identity rib-family {
    description
      "Base identity from which all RIB
       address families are derived.";
  }

  identity ipv4-rib-family {
    base "rib-family";
    description
      "IPv4 RIB address family.";
  }

  identity ipv6-rib-family {
    base "rib-family";
    description
      "IPv6 RIB address family.";
  }

  identity mpls-rib-family {
    base "rib-family";
    description
      "MPLS RIB address family.";
  }

  identity ieee-mac-rib-family {
    base "rib-family";
    description
      "MAC RIB address family.";
  }

  typedef rib-family-def {
    type identityref {
      base "rib-family";
    }
    description
      "Rib address family def.";
  }

  identity route-type {
    description
      "Base identity from which all route types
       are derived.";
  }

  identity ipv4-route {
    base "route-type";
    description
      "IPv4 route type.";
  }

  identity ipv6-route {
    base "route-type";
    description
      "IPv6 route type.";
  }

  identity mpls-route {
    base "route-type";
    description
      "MPLS route type.";
  }

  identity ieee-mac {
    base "route-type";
    description
      "MAC route type.";
  }

  identity interface {
    base "route-type";
    description
      "Interface route type.";
  }

  typedef route-type-def {
    type identityref {
      base "route-type";
    }
    description
      "Route type def.";
  }

  identity tunnel-type {
    description
      "Base identity from which all tunnel
       types are derived.";
  }

  identity ipv4-tunnel {
    base "tunnel-type";
    description
      "IPv4 tunnel type";
  }

  identity ipv6-tunnel {
    base "tunnel-type";
    description
      "IPv6 Tunnel type";
  }

  identity mpls-tunnel {
    base "tunnel-type";
    description
      "MPLS tunnel type";
  }

  identity gre-tunnel {
    base "tunnel-type";
    description
      "GRE tunnel type";
  }

  identity vxlan-tunnel {
    base "tunnel-type";
    description
      "VxLAN tunnel type";
  }

  identity nvgre-tunnel {
    base "tunnel-type";
    description
      "NVGRE tunnel type";
  }

  typedef tunnel-type-def {
    type identityref {
      base "tunnel-type";
    }
    description
      "Tunnel type def.";
  }

  identity route-state {
    description
      "Base identity from which all route
       states are derived.";
  }

  identity active {
    base "route-state";
    description
      "Active state.";
  }

  identity inactive {
    base "route-state";
    description
      "Inactive state.";
  }

  typedef route-state-def {
    type identityref {
      base "route-state";
    }
    description
      "Route state def.";
  }

  identity nexthop-state {
    description
      "Base identity from which all nexthop
       states are derived.";
  }

  identity resolved {
    base "nexthop-state";
    description
      "Reolved nexthop state.";
  }

  identity unresolved {
    base "nexthop-state";
    description
      "Unresolved nexthop state.";
  }

  typedef nexthop-state-def {
    type identityref {
      base "nexthop-state";
    }
    description
      "Nexthop state def.";
  }

  identity route-installed-state {
    description
      "Base identity from which all route
       installed states are derived.";
  }

  identity uninstalled {
    base "route-installed-state";
    description
      "Uninstalled state.";
  }

  identity installed {
    base "route-installed-state";
    description
      "Installed state.";
  }

  typedef route-installed-state-def {
    type identityref {
      base "route-installed-state";
    }
    description
      "Route installed state def.";
  }

//Route change reason identities

  identity route-change-reason {
    description
      "Base identity from which all route change
       reasons are derived.";
  }

  identity lower-route-preference {
    base "route-change-reason";
    description
      "This route was installed in the FIB because it had
       a lower route preference value (and thus was more
       preferred) than the route it replaced.";
  }

  identity higher-route-preference {
    base "route-change-reason";
    description
      "This route was uninstalled from the FIB because it had
       a higher route preference value (and thus was less
       preferred) than the route that replaced it.";
  }

  identity resolved-nexthop {
    base "route-change-reason";
    description
      "This route was made active because at least
       one of its nexthops was resolved.";
  }

  identity unresolved-nexthop {
    base "route-change-reason";
    description
      "This route was made inactive because all of
       its nexthops are unresolved.";
  }

  typedef route-change-reason-def {
    type identityref {
      base "route-change-reason";
    }
    description
      "Route change reason def.";
  }

  typedef nexthop-preference-def {
    type uint8 {
      range "1..99";
    }
    description
      "Nexthop-preference is used for protection schemes.
       It is an integer value between 1 and 99. Lower
       values are more preferred. To download N
       nexthops to the FIB, the N nexthops with the lowest
       value are selected. If there are more than N
       nexthops that have the same preference, an
       implementation of i2rs client should select N
       nexthops and download them, as for how to select
       the nexthops is left to the implementations.";
  }
  typedef nexthop-lb-weight-def {
    type uint8 {
      range "1..99";
    }
    description
      "Nexthop-lb-weight is used for load-balancing.
       Each list member MUST be assigned a weight
       between 1 and 99. The weight determines the
       proportion of traffic to be sent over a nexthop
       used for forwarding as a ratio of the weight of
       this nexthop divided by the weights of all the
       nexthops of this route that are used for forwarding.
       To perform equal load-balancing, one MAY specify
       a weight of 0 for all the member nexthops.  The
       value 0 is reserved for equal load-balancing
       and if applied, MUST be applied to all member nexthops.";
  }

  typedef nexthop-ref {
    type leafref {
      path  "/iir:routing-instance" +
            "/iir:rib-list" +
            "/iir:route-list" +
            "/iir:nexthop" +
            "/iir:nexthop-id";
    }
    description
      "A nexthop reference that provides
       an indirection reference to a nexthop.";
  }

  //Groupings
  grouping route-prefix {
    description
      "The common attributes used for all types of route prefix.";
    leaf route-index {
      type uint64 ;
      mandatory true;
      description
        "Route index.";
    }
    container match {
      description
        "The match condition specifies the
         kind of route (IPv4, MPLS, etc.)
         and the set of fields to match on.";
      choice route-type {
        description
          "Route types: IPv4, IPv6, MPLS, MAC etc.";
        case ipv4 {
          description
            "IPv4 route case.";
          container ipv4 {
            description
              "IPv4 route match.";
            choice ip-route-match-type {
              description
                "IP route match type options:
                 match source, or
                 match destination, or
                 match source and destination.";
              case dest-ipv4-address {
                leaf dest-ipv4-prefix {
                  type inet:ipv4-prefix;
                  mandatory true;
                  description
                    "An IPv4 destination address as the match.";
                }
              }
              case src-ipv4-address {
                leaf src-ipv4-prefix {
                  type inet:ipv4-prefix;
                  mandatory true;
                  description
                    "An IPv4 source address as the match.";
                }
              }
              case dest-src-ipv4-address {
                container dest-src-ipv4-address {
                  description
                    "A combination of an IPv4 source and
                     an IPv4 destination address as the match.";
                  leaf dest-ipv4-prefix {
                    type inet:ipv4-prefix;
                    mandatory true;
                    description
                      "The IPv4 destination address of the match.";
                  }
                  leaf src-ipv4-prefix {
                    type inet:ipv4-prefix;
                    mandatory true;
                    description
                      "The IPv4 source address of the match";
                  }
                }
              }
            }
          }
        }
        case ipv6 {
          description
            "IPv6 route case.";
          container ipv6 {
            description
              "IPv6 route match.";
            choice ip-route-match-type {
              description
                "IP route match type options:
                 match source, or
                 match destination, or
                 match source and destination.";
              case dest-ipv6-address {
                leaf dest-ipv6-prefix {
                  type inet:ipv6-prefix;
                  mandatory true;
                  description
                    "An IPv6 destination address as the match.";
                }
              }
              case src-ipv6-address {
                leaf src-ipv6-prefix {
                  type inet:ipv6-prefix;
                  mandatory true;
                  description
                    "An IPv6 source address as the match.";
                }
              }
              case dest-src-ipv6-address {
                container dest-src-ipv6-address {
                  description
                    "A combination of an IPv6 source and
                     an IPv6 destination address as the match.";
                  leaf dest-ipv6-prefix {
                    type inet:ipv6-prefix;
                    mandatory true;
                    description
                      "The IPv6 destination address of the match";
                  }
                  leaf src-ipv6-prefix {
                    type inet:ipv6-prefix;
                    mandatory true;
                    description
                      "The IPv6 source address of the match.";
                  }
                }
              }
            }
          }
        }
        case mpls-route {
          description
            "MPLS route case.";
          leaf mpls-label {
            type uint32 ;
            mandatory true;
            description
              "The label used for matching.";
          }
        }
        case mac-route {
          description
            "MAC route case.";
          leaf mac-address {
            type uint32 ;
            mandatory true;
            description
              "The MAC address used for matching.";
          }
        }
        case interface-route {
          description
            "Interface route case.";
          leaf interface-identifier {
            type if:interface-ref;
            mandatory true;
            description
              "The interface used for matching.";
          }
        }
      }
    }
  }

  grouping route {
    description
      "The common attributes used for all types of routes.";
    uses route-prefix;
    container nexthop {
      description
        "The nexthop of the route.";
      uses nexthop;
    }
    //In the information model, it is called route-statistic
    container route-status {
      description
        "The status information of the route.";
      leaf route-state {
        type route-state-def;
        config false;
        description
          "Indicate a route's state: Active or Inactive.";
      }
      leaf route-installed-state {
        type route-installed-state-def;
        config false;
        description
          "Indicate that a route's installed states:
           Installed or uninstalled.";
      }
      leaf route-reason {
        type route-change-reason-def;
        config false;
        description
          "Indicate the reason that causes the route change.";
      }
    }
    container route-attributes {
      description
        "Route attributes.";
      uses route-attributes;
    }
    container route-vendor-attributes {
      description
        "Route vendor attributes.";
      uses route-vendor-attributes;
    }
  }

  grouping nexthop-list {
    description
      "A generic nexthop list.";
    list nexthop-list {
      key "nexthop-member-id";
      description
        "A list of nexthops.";
      leaf nexthop-member-id {
        type uint32;
        mandatory true;
        description
          "A nexthop identifier that points
           to a nexthop list member.
           A nexthop list member is a nexthop.";
      }
    }
  }

  grouping nexthop-list-p {
    description
      "A nexthop list with preference parameter.";
    list nexthop-list {
      key "nexthop-member-id";
      description
        "A list of nexthop.";
      leaf nexthop-member-id {
        type uint32;
        mandatory true;
        description
          "A nexthop identifier that points
           to a nexthop list member.
           A nexthop list member is a nexthop.";
      }
      leaf nexthop-preference {
        type nexthop-preference-def;
        mandatory true;
        description
          "Nexthop-preference is used for protection schemes.
           It is an integer value between 1 and 99.  Lower
           values are more preferred. To download a
           primary/standby/tertiary group to the FIB, the
           nexthops that are resolved and are most preferred
           are selected.";
      }
    }
  }

  grouping nexthop-list-w {
    description
      "A nexthop list with weight parameter.";
    list nexthop-list {
      key "nexthop-member-id";
      description
        "A list of nexthop.";
      leaf nexthop-member-id {
        type uint32;
        mandatory true;
        description
          "A nexthop identifier that points
           to a nexthop list member.
           A nexthop list member is a nexthop.";
      }
      leaf nexthop-lb-weight {
        type nexthop-lb-weight-def;
        mandatory true;
        description
          "The weight of a nexthop of
           the load balance nexthops.";
      }
    }
  }

  grouping nexthop {
    description
      "The nexthop structure.";
    leaf nexthop-id {
      type uint32;
      description
        "An identifier that refers to a nexthop.";
    }
    leaf sharing-flag {
      type boolean;
      description
        "To indicate whether a nexthop is sharable
         or non-sharable.
         true - sharable, means the nexthop can be shared
                with other routes
         false - non-sharable, means the nexthop can not
                be shared with other routes.";
    }
    choice nexthop-type {
      description
        "Nexthop type options.";
      case nexthop-base {
        container nexthop-base {
          description
            "The base nexthop.";
          uses nexthop-base;
        }
      }
      case nexthop-chain {
        if-feature nexthop-chain;
        container nexthop-chain {
          description
            "A chain nexthop.";
          uses nexthop-list;
        }
      }
      case nexthop-replicates {
        if-feature nexthop-replicates;
        container nexthop-replicates {
          description
            "A replicates nexthop.";
          uses nexthop-list;
        }
      }
      case nexthop-protection {
        if-feature nexthop-protection;
        container nexthop-protection {
          description
            "A protection nexthop.";
          uses nexthop-list-p;
        }
      }
      case nexthop-load-balance {
        if-feature nexthop-load-balance;
        container nexthop-lb {
          description
            "A load balance nexthop.";
          uses nexthop-list-w;
        }
      }
    }
  }

  grouping nexthop-base {
    description
      "The base nexthop.";
    choice nexthop-base-type {
      description
        "Nexthop base type options.";
      case special-nexthop {
        leaf special {
          type special-nexthop-def;
          description
            "A special nexthop.";
        }
      }
      case egress-interface-nexthop {
         leaf outgoing-interface {
           type if:interface-ref;
           mandatory true;
           description
             "The nexthop is an outgoing interface.";
         }
      }
      case ipv4-address-nexthop {
        leaf ipv4-address {
          type inet:ipv4-address;
          mandatory true;
          description
            "The nexthop is an IPv4 address.";
        }
      }
      case ipv6-address-nexthop {
        leaf ipv6-address {
          type inet:ipv6-address;
          mandatory true;
          description
            "The nexthop is an IPv6 address.";
        }
      }
      case egress-interface-ipv4-nexthop {
        container egress-interface-ipv4-address{
          leaf outgoing-interface {
            type if:interface-ref;
            mandatory true;
            description
              "Name of the outgoing interface.";
          }
          leaf ipv4-address {
            type inet:ipv4-address;
            mandatory true;
            description
              "The nexthop points to an interface with
               an IPv4 address.";
          }
          description
            "The nexthop is an egress-interface and an IP
             address. This can be used in cases e.g. where
             the IP address is a link-local address.";
        }
      }
      case egress-interface-ipv6-nexthop {
        container egress-interface-ipv6-address {
          leaf outgoing-interface {
            type if:interface-ref;
            mandatory true;
            description
              "Name of the outgoing interface.";
          }
          leaf ipv6-address {
            type inet:ipv6-address;
            mandatory true;
            description
              "The nexthop points to an interface with
               an IPv6 address.";
          }
          description
            "The nexthop is an egress-interface and an IP
             address. This can be used in cases e.g. where
             the IP address is a link-local address.";
        }
      }
      case egress-interface-mac-nexthop {
        container egress-interface-mac-address {
          leaf outgoing-interface {
            type if:interface-ref;
            mandatory true;
            description
              "Name of the outgoing interface.";
          }
          leaf ieee-mac-address {
            type uint32;
            mandatory true;
            description
              "The nexthop points to an interface with
               a specific mac-address.";
          }
          description
            "The egress interface must be an Ethernet
             interface. Address resolution is not required
             for this nexthop.";
        }
      }
      case tunnel-encap-nexthop {
        if-feature nexthop-tunnel;
        container tunnel-encap {
          uses tunnel-encap;
          description
            "This can be an encap representing an IP tunnel or
             MPLS tunnel or others as defined in info model.
             An optional egress interface can be chained to the
             tunnel encap to indicate which interface to send
             the packet out on.  The egress interface is useful
             when the network device contains Ethernet interfaces
             and one needs to perform address resolution for the
             IP packet.";
        }
      }
      case tunnel-decap-nexthop {
        if-feature nexthop-tunnel;
        container tunnel-decap {
          uses tunnel-decap;
          description
            "This is to specify decapsulating a tunnel header.";
        }
      }
      case logical-tunnel-nexthop {
        if-feature nexthop-tunnel;
        container logical-tunnel {
          uses logical-tunnel;
          description
            "This can be a MPLS LSP or a GRE tunnel (or others
             as defined in this document), that is represented
             by a unique identifier (e.g. name).";
        }
      }
      case rib-name-nexthop {
        leaf rib-name {
          type string;
          description
            "A nexthop pointing to a RIB indicates that the
             route lookup needs to continue in the specified
             rib. This is a way to perform chained lookups.";
        }
      }
      case nexthop-identifier {
        leaf nexthop-ref {
          type nexthop-ref;
          mandatory true;
          description
            "A nexthop reference that points to a nexthop.";
        }
      }
    }
  }

  grouping route-vendor-attributes {
    description
      "Route vendor attributes.";
  }

  grouping logical-tunnel {
    description
      "A logical tunnel that is identified
       by a type and a tunnel name.";
    leaf tunnel-type {
      type tunnel-type-def;
      mandatory true;
      description
        "A tunnel type.";
    }
    leaf tunnel-name {
      type string;
      mandatory true;
      description
        "A tunnel name that points to a logical tunnel.";
    }
  }

  grouping ipv4-header {
    description
      "The IPv4 header encapsulation information.";
    leaf src-ipv4-address {
      type inet:ipv4-address;
      mandatory true;
      description
        "The source IP address of the header.";
    }
    leaf dest-ipv4-address {
      type inet:ipv4-address;
      mandatory true;
      description
        "The destination IP address of the header.";
    }
    leaf protocol {
      type uint8;
      mandatory true;
      description
        "The protocol id of the header.";
    }
    leaf ttl {
      type uint8;
      description
        "The TTL of the header.";
    }
    leaf dscp {
      type uint8;
      description
        "The DSCP field of the header.";
    }
  }

  grouping ipv6-header {
    description
      "The IPv6 header encapsulation information.";
    leaf src-ipv6-address {
      type inet:ipv6-address;
      mandatory true;
      description
        "The source IP address of the header.";
    }
    leaf dest-ipv6-address {
      type inet:ipv6-address;
      mandatory true;
      description
        "The destination IP address of the header.";
    }
    leaf next-header {
      type uint8;
      mandatory true;
      description
        "The next header of the IPv6 header.";
    }
    leaf traffic-class {
      type uint8;
      description
        "The traffic class value of the header.";
    }
    leaf flow-label {
      type uint16;
      description
        "The flow label of the header.";
    }
    leaf hop-limit {
      type uint8;
      description
        "The hop limit the header.";
    }
  }

  grouping nvgre-header {
    description
      "The NvGRE header encapsulation information.";
    choice nvgre-type {
      description
        "NvGRE can use eigher IPv4
         or IPv6 header for encapsulation.";
      case ipv4 {
        uses ipv4-header;
      }
      case ipv6 {
        uses ipv6-header;
      }
    }
    leaf virtual-subnet-id {
      type uint32;
      mandatory true;
      description
        "The subnet identifier of the NvGRE header.";
    }
    leaf flow-id {
      type uint16;
      description
        "The flow identifier of the NvGRE header.";
    }
  }

  grouping vxlan-header {
    description
      "The VxLAN encapsulation header information.";
    choice vxlan-type {
      description
        "NvGRE can use either IPv4
         or IPv6 header for encapsulation.";
      case ipv4 {
        uses ipv4-header;
      }
      case ipv6 {
        uses ipv6-header;
      }
    }
    leaf vxlan-identifier {
      type uint32;
      mandatory true;
      description
        "The VxLAN identifier of the VxLAN header.";
    }
  }

  grouping gre-header {
    description
      "The GRE encapsulation header information.";
    choice dest-address-type {
      description
        "GRE options: IPv4 and IPv6";
      case ipv4 {
        leaf ipv4-dest {
          type inet:ipv4-address;
          mandatory true;
          description
            "The destination IP address of the GRE header.";
        }
      }
      case ipv6 {
        leaf ipv6-dest {
          type inet:ipv6-address;
          mandatory true;
          description
            "The destination IP address of the GRE header.";
        }
      }
    }
    leaf protocol-type {
      type uint16;
      mandatory true;
      description
        "The protocol type of the GRE header.";
    }
    leaf key {
      type uint64;
      description
        "The GRE key of the GRE header.";
    }
  }

  grouping mpls-header {
    description
      "The MPLS encapsulation header information.";
    list label-operations {
      key "label-oper-id";
      description
        "Label operations.";
      leaf label-oper-id {
        type uint32;
        description
          "An optional identifier that points
           to a label operation.";
      }
      choice label-actions {
        description
          "Label action options.";
        case label-push {
          container label-push {
            description
              "Label push operation.";
            leaf label {
              type uint32;
              mandatory true;
              description
                "The label to be pushed.";
            }
            leaf s-bit {
              type boolean;
              description
                "The s-bit of the label to be pushed. ";
            }
            leaf tc-value {
              type uint8;
              description
                "The traffic class value of the label to be pushed.";
            }
            leaf ttl-value {
              type uint8;
              description
                "The TTL value of the label to be pushed.";
            }
          }
        }
        case label-swap {
          container label-swap {
            description
              "Label swap operation.";
            leaf in-label {
              type uint32;
              mandatory true;
              description
                "The label to be swapped.";
            }
            leaf out-label {
              type uint32;
              mandatory true;
              description
                "The out MPLS label.";
            }
            leaf ttl-action {
              type ttl-action-def;
              description
                "The label ttl actions:
                 - No-action, or
                 - Copy to inner label,or
                 - Decrease (the in label) by 1 and
                   copy to the out label.";
            }
          }
        }
      }
    }
  }

  grouping tunnel-encap{
    description
      "Tunnel encapsulation information.";
    choice tunnel-type {
      description
        "Tunnel options for next-hops.";
      case ipv4 {
        if-feature ipv4-tunnel;
        container ipv4-header {
          uses ipv4-header;
          description
            "IPv4 header.";
        }
      }
      case ipv6 {
        if-feature ipv6-tunnel;
        container ipv6-header {
          uses ipv6-header;
          description
            "IPv6 header.";
        }
      }
      case mpls {
        if-feature mpls-tunnel;
        container mpls-header {
          uses mpls-header;
          description
            "MPLS header.";
        }
      }
      case gre {
        if-feature gre-tunnel;
        container gre-header {
          uses gre-header;
          description
            "GRE header.";
        }
      }
      case nvgre {
        if-feature nvgre-tunnel;
        container nvgre-header {
          uses nvgre-header;
          description
            "NvGRE header.";
        }
      }
      case vxlan {
        if-feature vxlan-tunnel;
        container vxlan-header {
          uses vxlan-header;
          description
            "VxLAN header.";
        }
      }
    }
  }

  grouping tunnel-decap {
    description
      "Tunnel decapsulation information.";
    choice tunnel-type {
      description
        "Nexthop tunnel type options.";
      case ipv4 {
        if-feature ipv4-tunnel;
        container ipv4-decap {
          description
            "IPv4 decap.";
          leaf ipv4-decap  {
            type tunnel-decap-action-def;
            mandatory true;
            description
              "IPv4 decap operations.";
          }
          leaf ttl-action {
            type ttl-action-def;
            description
              "The ttl actions:
               no-action or copy to inner header.";
          }
        }
      }
      case ipv6 {
        if-feature ipv6-tunnel;
        container ipv6-decap {
          description
            "IPv6 decap.";
          leaf ipv6-decap {
            type tunnel-decap-action-def;
            mandatory true;
            description
              "IPv6 decap operations.";
          }
          leaf hop-limit-action {
            type hop-limit-action-def;
            description
              "The hop limit actions:
               no-action or copy to inner header.";
          }
        }
      }
      case mpls {
        if-feature mpls-tunnel;
        container label-pop {
          description
            "MPLS decap.";
          leaf label-pop {
            type mpls-label-action-def;
            mandatory true;
            description
              "Pop a label from the label stack.";
          }
          leaf ttl-action {
            type ttl-action-def;
            description
              "The label ttl action.";
          }
        }
      }
    }
  }

  grouping route-attributes {
    description
      "Route attributes.";
    leaf route-preference {
      type uint32;
      mandatory true;
      description
        "ROUTE_PREFERENCE: This is a numerical value that
         allows for comparing routes from different
         protocols.  Static configuration is also
         considered a protocol for the purpose of this
         field.  It is also known as administrative-distance.
         The lower the value, the higher the preference.";
    }
    leaf local-only {
      type boolean ;
      mandatory true;
      description
        "Indicate whether the attributes is local only.";
    }
    container address-family-route-attributes{
      description
        "Address family related route attributes.";
      choice route-type {
        description
          "Address family related route attributes.";
        case ip-route-attributes {
        }
        case mpls-route-attributes {
        }
        case ethernet-route-attributes {
        }
      }
    }
  }

  container routing-instance {
    description
      "A routing instance, in the context of
       the RIB information model, is a collection
       of RIBs, interfaces, and routing parameters";
    leaf name {
      type string;
      description
        "The name of the routing instance. This MUST
         be unique across all routing instances in
         a given network device.";
    }
    list interface-list {
      key "name";
      description
        "This represents the list of interfaces associated
         with this routing instance. The interface list helps
         constrain the boundaries of packet forwarding.
         Packets coming on these interfaces are directly
         associated with the given routing instance. The
         interface list contains a list of identifiers, with
         each identifier uniquely identifying an interface.";
      leaf name {
        type if:interface-ref;
        description
          "A reference to the name of a network layer interface.";
      }
    }
    leaf router-id {
      type yang:dotted-quad;
      description
        "Router ID - 32-bit number in the form of a dotted quad.";
    }
    leaf lookup-limit {
      type uint8;
      description
        "A limit on how many levels of a lookup can be performed.";
    }
    list rib-list {
      key "name";
      description
        "A list of RIBs that are associated with the routing
         instance.";
      leaf name {
        type string;
        mandatory true;
        description
          "A reference to the name of each rib.";
      }
      leaf address-family {
        type rib-family-def;
        mandatory true;
        description
          "The address family of a rib.";
      }
      leaf ip-rpf-check {
        type boolean;
        description
          "Each RIB can be optionally associated with a
           ENABLE_IP_RPF_CHECK attribute that enables Reverse
           path forwarding (RPF) checks on all IP routes in that
           RIB.  Reverse path forwarding (RPF) check is used to
           prevent spoofing and limit malicious traffic.";
      }
      list route-list {
        key "route-index";
        description
          "A list of routes of a rib.";
        uses route;
      }
      // This is a list that maintains the nexthops added to the rib.
      uses nexthop-list;
    }
  }

  //RPC Operations
  rpc rib-add {
    description
      "To add a RIB to a instance";
    input {
      leaf name {
        type string;
        mandatory true;
        description
          "A reference to the name of the RIB
           that is to be added.";
      }
      leaf address-family {
        type rib-family-def;
        mandatory true;
        description
          "The address family of the rib.";
      }
      leaf ip-rpf-check {
        type boolean;
        description
          "Each RIB can be optionally associated with a
           ENABLE_IP_RPF_CHECK attribute that enables Reverse
           path forwarding (RPF) checks on all IP routes in that
           RIB.  Reverse path forwarding (RPF) check is used to
           prevent spoofing and limit malicious traffic.";
      }
    }
    output {
      leaf result {
        type boolean;
        mandatory true;
        description
          "Return the result of the rib-add operation.
           true  - success;
           false - failed";
      }
      leaf reason {
        type string;
        description
          "The specific reason that causes the failure.";
      }
    }
  }

  rpc rib-delete {
    description
      "To delete a RIB from a routing instance.
       After deleting the rib, all routes installed
       in the RIB will be deleted as well.";
    input {
      leaf name {
        type string;
        mandatory true;
        description
          "A reference to the name of the RIB
           that is to be deleted.";
      }
    }
    output {
      leaf result {
        type boolean;
        mandatory true;
        description
          "Return the result of the rib-delete operation.
           true  - success;
           false - failed";
      }
      leaf reason {
        type string;
        description
          "The specific reason that causes failure.";
      }
    }
  }

  grouping route-operation-state {
    description
      "Route operation state.";
    leaf success-count {
      type uint32;
      mandatory true;
      description
        "The numbers of routes that are successfully
         added/deleted/updated.";
    }
    leaf failed-count {
      type uint32;
      mandatory true;
      description
        "The numbers of the routes that are failed
         to be added/deleted/updated.";
    }
    container failure-detail {
      description
        "The failure detail reflects the reason why a route
         operation fails. It is a array that includes the route
         index and error code of the failed route.";
      list failed-routes {
         key "route-index";
         description
          "The list of failed routes.";
         leaf route-index {
          type uint32;
          description
            "The route index of the failed route.";
        }
        leaf error-code {
          type uint32;
          description
            "The error code that reflects the failure reason.";
        }
      }
    }
  }

  rpc route-add {
    description
      "To add a route or a list of route to a rib";
    input {
      leaf return-failure-detail {
        type boolean;
        default false;
        description
          "Whether return the failure detail.
           true  - return the failure detail;
           false - do not return the failure detail;
           the default is false.";
      }
      leaf rib-name {
        type string;
        mandatory true;
        description
          "A reference to the name of a rib.";
      }
      container routes {
        description
          "The routes to be added to the rib.";
        list route-list {
          key "route-index";
          description
            "The list of routes to be added.";
          uses route-prefix;
          container route-attributes {
            uses route-attributes;
            description
              "The route attributes.";
          }
          container route-vendor-attributes {
            if-feature route-vendor-attributes;
            uses route-vendor-attributes;
            description
              "The route vendor attributes.";
          }
          container nexthop {
            uses nexthop;
            description
              "The nexthop of the added route.";
          }
        }
      }
    }
    output {
      uses route-operation-state;
    }
  }

  rpc route-delete {
    description
      "To delete a route or a list of route from a rib";
    input {
      leaf return-failure-detail {
        type boolean;
        default false;
        description
          "Whether return the failure detail.
           true  - return the failure detail;
           false - do not return the failure detail;
           the default is false.";
      }
      leaf rib-name {
        type string;
        mandatory true;
        description
          "A reference to the name of a rib.";
      }
      container routes {
        description
          "The routes to be added to the rib.";
        list route-list{
          key "route-index";
          description
            "The list of routes to be deleted.";
          uses route-prefix;
        }
      }
    }
    output {
      uses route-operation-state;
    }
  }

  grouping route-update-options {
    description
      "Update options:
       1. update the nexthop
       2. update the route attributes
       3. update the route-vendor-attributes.";
    choice update-options {
      description
        "Update options:
         1. update the nexthop
         2. update the route attributes
         3. update the route-vendor-attributes.";
      case update-nexthop {
        container updated-nexthop {
          uses nexthop;
          description
            "The nexthop used for updating.";
        }
      }
      case update-route-attributes {
        container updated-route-attr {
          uses route-attributes;
          description
            "The route attributes used for updating.";
        }
      }
      case update-route-vendor-attributes {
        container updated-route-vendor-attr {
          uses route-vendor-attributes;
          description
            "The vendor route attributes used for updating.";
        }
      }
    }
  }

  rpc route-update {
    description
      "To update a route or a list of route of a rib.
       The inputs:
         1. The match conditions, could be:
           a. route prefix, or
           b. route attributes, or
           c. nexthop;
         2. The update parameters to be used:
           a. new nexthop;
           b. new route attributes;nexthop
       Actions:
         1. update the nexthop
         2. update the route attributes
       The outputs:
         success-count - the number of routes updated;
         failed-count - the number of routes fail to update
         failure-detail - the detail failure info.
       ";
    input {
      leaf return-failure-detail {
        type boolean;
        default false;
        description
          "Whether return the failure detail.
           true  - return the failure detail;
           false - do not return the failure detail;
           the default is false.";
      }
      leaf rib-name {
        type string;
        mandatory true;
        description
          "A reference to the name of a rib.";
      }
      choice match-options {
        description
          "Match options.";
        case match-route-prefix {
          description
            "Update the routes that match route
             prefix(es) condition.";
          container input-routes {
            description
              "The matched routes to be updated.";
            list route-list {
              key "route-index";
              description
                "The list of routes to be updated.";
              uses route-prefix;
              uses route-update-options;
            }
          }
        }
        case match-route-attributes {
          description
            "Update the routes that match the
             route attributes condition.";
          container input-route-attributes {
            description
              "The route attributes are used for matching.";
            uses route-attributes;
          }
          container update-parametors {
            description
              "Update options:
               1. update the nexthop
               2. update the route attributes
               3. update the route-vendor-attributes.";
            uses route-update-options;
          }
        }
        case match-route-vendor-attributes {
          if-feature route-vendor-attributes;
          description
            "Update the routes that match the
             vendor attributes condition";
          container input-route-vendor-attributes {
            description
              "The vendor route attributes are used for matching.";
            uses route-vendor-attributes;
          }
          container update-parameters-vendor {
            description
              "Update options:
               1. update the nexthop
               2. update the route attributes
               3. update the route-vendor-attributes.";
            uses route-update-options;
          }
        }
        case match-nexthop {
          description
            "Update the routes that match the nexthop.";
          container input-nexthop {
            description
              "The nexthop used for matching.";
            uses nexthop;
          }
          container update-parameters-nexthop {
            description
              "Update options:
               1. update the nexthop
               2. update the route attributes
               3. update the route-vendor-attributes.";
            uses route-update-options;
          }
        }
      }
    }
    output {
      uses route-operation-state;
    }
  }

  rpc nh-add {
    description
      "To add a nexthop to a rib.
       Inputs parameters:
         1. RIB name
         2. nexthop;
       Actions:
         Add the nexthop to the RIB
       Outputs:
         1.Operation result:
           true  - success
           false - failed;
         2. nexthop identifier.";
    input {
      leaf rib-name {
        type string;
        mandatory true;
        description
          "A reference to the name of a rib.";
      }
      uses nexthop;
    }
    output {
      leaf result {
        type boolean;
        mandatory true;
        description
          "Return the result of the rib-add operation.
           true  - success;
           false - failed;";
      }
      leaf reason {
        type string;
        description
          "The specific reason that causes the failure.";
      }
      leaf nexthop-id {
        type uint32;
        description
          "A nexthop identifier that is allocated to the nexthop.";
      }
    }
  }

  rpc nh-delete {
    description
      "To delete a nexthop from a rib";
    input {
      leaf rib-name {
        type string;
        mandatory true;
        description
          "A reference to the name of a rib.";
      }
      uses nexthop;
    }
    output {
      leaf result {
        type boolean;
        mandatory true;
        description
          "Return the result of the rib-add operation.
           true  - success;
           false - failed.";
      }
      leaf reason {
        type string;
        description
          "The specific reason that causes the failure.";
      }
    }
  }

  /*Notifications*/
  notification nexthop-resolution-status-change {
    description
      "Nexthop resolution status (resolved/unresolved)
       notification.";
    container nexthop{
      description
        "The nexthop.";
      uses nexthop;
    }
    leaf nexthop-state {
      type nexthop-state-def;
      mandatory true;
      description
        "Nexthop resolution status (resolved/unresolved)
         notification.";
    }
  }

  notification route-change {
    description
      "Route change notification.";
    leaf rib-name {
      type string;
      mandatory true;
      description
        "A reference to the name of a rib.";
    }
    leaf address-family {
      type rib-family-def;
      mandatory true;
      description
        "The address family of a rib.";
    }
    uses route-prefix;
    leaf route-installed-state {
      type route-installed-state-def;
      mandatory true;
      description
        "Indicates whether the route got installed in the FIB.";
    }
    leaf route-state {
      type route-state-def;
      mandatory true;
      description
        "Indicates whether a route is active or inactive.";
    }
    list route-change-reasons {
      key "route-change-reason";
      description
        "The reasons that cause the route change. A route
         change that may result from several reasons. For
         example, a nexthop becoming resolved will make a
         route A active which is of better preference than
         a currently active route B, which results in the
         route A being installed";
      leaf route-change-reason {
        type route-change-reason-def;
        mandatory true;
        description
          "The reason that causes the route change.";
      }
    }
  }
}
