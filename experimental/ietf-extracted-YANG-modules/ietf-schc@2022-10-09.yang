module ietf-schc {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-schc";
  prefix schc;

  organization
    "IETF IPv6 over Low Power Wide-Area Networks (lpwan) working
     group";
  contact
    "WG Web:   <https://datatracker.ietf.org/wg/lpwan/about/>
     WG List:  <mailto:lp-wan@ietf.org>
     Editor:   Laurent Toutain
       <mailto:laurent.toutain@imt-atlantique.fr>
     Editor:   Ana Minaburo
       <mailto:ana@ackl.io>";
  description
    "
     Copyright (c) 2022 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Revised BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX
     (https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
     for full legal notices.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
     'MAY', and 'OPTIONAL' in this document are to be interpreted as
     described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
     they appear in all capitals, as shown here.

     ***************************************************************

     Generic Data model for Static Context Header Compression Rule
     for SCHC, based on RFC 8724 and RFC8824. Include compression,
     no compression and fragmentation rules.

     This module is a YANG model for SCHC rules (RFC 8724 and
     RFC8824). RFC 8724 describes compression rules in a abstract
     way through a table.

 |-----------------------------------------------------------------|
 |  (FID)            Rule 1                                        |
 |+-------+--+--+--+------------+-----------------+---------------+|
 ||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||
 |+-------+--+--+--+------------+-----------------+---------------+|
 ||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||
 |+-------+--+--+--+------------+-----------------+---------------+|
 ||...    |..|..|..|   ...      | ...             | ...           ||
 |+-------+--+--+--+------------+-----------------+---------------+|
 ||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||
 |+-------+--+--+--+------------+-----------------+---------------+|
 |-----------------------------------------------------------------|

     This module specifies a global data model that can be used for
     rule exchanges or modification. It specifies both the data model
     format and the global identifiers used to describe some
     operations in fields.
     This data model applies to both compression and fragmentation.";

  revision 2022-10-09 {
    description
      "Initial version from RFC XXXX.";
    reference
      "RFC XXX: Data Model for Static Context Header Compression
       (SCHC)";
  }

  feature compression {
    description
      "SCHC compression capabilities are taken into account.";
  }

  feature fragmentation {
    description
      "SCHC fragmentation capabilities are taken into account.";
  }

  // -------------------------
  //  Field ID type definition
  //--------------------------
  // generic value TV definition

  identity fid-base-type {
    description
      "Field ID base type for all fields.";
  }

  identity fid-ipv6-base-type {
    base fid-base-type;
    description
      "Field ID base type for IPv6 headers described in RFC 8200.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-version {
    base fid-ipv6-base-type;
    description
      "IPv6 version field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-trafficclass {
    base fid-ipv6-base-type;
    description
      "IPv6 Traffic Class field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-trafficclass-ds {
    base fid-ipv6-trafficclass;
    description
      "IPv6 Traffic Class field: DiffServ field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification,
       RFC 3168 The Addition of Explicit Congestion Notification
                (ECN) to IP";
  }

  identity fid-ipv6-trafficclass-ecn {
    base fid-ipv6-trafficclass;
    description
      "IPv6 Traffic Class field: ECN field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification,
       RFC 3168 The Addition of Explicit Congestion Notification
                (ECN) to IP";
  }

  identity fid-ipv6-flowlabel {
    base fid-ipv6-base-type;
    description
      "IPv6 Flow Label field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-payload-length {
    base fid-ipv6-base-type;
    description
      "IPv6 Payload Length field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-nextheader {
    base fid-ipv6-base-type;
    description
      "IPv6 Next Header field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-hoplimit {
    base fid-ipv6-base-type;
    description
      "IPv6 Next Header field.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-devprefix {
    base fid-ipv6-base-type;
    description
      "Corresponds to either the source address or the destination
       address prefix of RFC 8200 depending on whether it is an
       uplink or a downlink message.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-deviid {
    base fid-ipv6-base-type;
    description
      "Corresponds to either the source address or the destination
       address IID of RFC 8200 depending on whether it is an uplink
       or a downlink message.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-appprefix {
    base fid-ipv6-base-type;
    description
      "Corresponds to either the source address or the destination
       address prefix of RFC 8200 depending on whether it is an
       uplink or a downlink message.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-ipv6-appiid {
    base fid-ipv6-base-type;
    description
      "Corresponds to either the source address or the destination
       address IID of RFC 8200 depending on whether it is an uplink
       or a downlink message.";
    reference
      "RFC 8200 Internet Protocol, Version 6 (IPv6) Specification";
  }

  identity fid-udp-base-type {
    base fid-base-type;
    description
      "Field ID base type for UDP headers described in RFC 768.";
    reference
      "RFC 768 User Datagram Protocol";
  }

  identity fid-udp-dev-port {
    base fid-udp-base-type;
    description
      "UDP source or destination port, if uplink or downlink
       communication, respectively.";
    reference
      "RFC 768 User Datagram Protocol";
  }

  identity fid-udp-app-port {
    base fid-udp-base-type;
    description
      "UDP destination or source port, if uplink or downlink
       communication, respectively.";
    reference
      "RFC 768 User Datagram Protocol";
  }

  identity fid-udp-length {
    base fid-udp-base-type;
    description
      "UDP length.";
    reference
      "RFC 768 User Datagram Protocol";
  }

  identity fid-udp-checksum {
    base fid-udp-base-type;
    description
      "UDP length.";
    reference
      "RFC 768 User Datagram Protocol";
  }

  identity fid-coap-base-type {
    base fid-base-type;
    description
      "Field ID base type for UDP headers described.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-version {
    base fid-coap-base-type;
    description
      "CoAP version.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-type {
    base fid-coap-base-type;
    description
      "CoAP type.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-tkl {
    base fid-coap-base-type;
    description
      "CoAP token length.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-code {
    base fid-coap-base-type;
    description
      "CoAP code.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-code-class {
    base fid-coap-code;
    description
      "CoAP code class.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-code-detail {
    base fid-coap-code;
    description
      "CoAP code detail.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-mid {
    base fid-coap-base-type;
    description
      "CoAP message ID.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-token {
    base fid-coap-base-type;
    description
      "CoAP token.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-if-match {
    base fid-coap-base-type;
    description
      "CoAP option If-Match.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-uri-host {
    base fid-coap-base-type;
    description
      "CoAP option URI-Host.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-etag {
    base fid-coap-base-type;
    description
      "CoAP option Etag.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-if-none-match {
    base fid-coap-base-type;
    description
      "CoAP option if-none-match.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-observe {
    base fid-coap-base-type;
    description
      "CoAP option Observe.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-uri-port {
    base fid-coap-base-type;
    description
      "CoAP option Uri-Port.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-location-path {
    base fid-coap-base-type;
    description
      "CoAP option Location-Path.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-uri-path {
    base fid-coap-base-type;
    description
      "CoAP option Uri-Path.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-content-format {
    base fid-coap-base-type;
    description
      "CoAP option Content Format.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-max-age {
    base fid-coap-base-type;
    description
      "CoAP option Max-Age.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-uri-query {
    base fid-coap-base-type;
    description
      "CoAP option Uri-Query.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-accept {
    base fid-coap-base-type;
    description
      "CoAP option Accept.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-location-query {
    base fid-coap-base-type;
    description
      "CoAP option Location-Query.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-block2 {
    base fid-coap-base-type;
    description
      "CoAP option Block2.";
    reference
      "RFC 7959 Block-Wise Transfers in the Constrained
                Application Protocol (CoAP)";
  }

  identity fid-coap-option-block1 {
    base fid-coap-base-type;
    description
      "CoAP option Block1.";
    reference
      "RFC 7959 Block-Wise Transfers in the Constrained
                Application Protocol (CoAP)";
  }

  identity fid-coap-option-size2 {
    base fid-coap-base-type;
    description
      "CoAP option size2.";
    reference
      "RFC 7959 Block-Wise Transfers in the Constrained
                Application Protocol (CoAP)";
  }

  identity fid-coap-option-proxy-uri {
    base fid-coap-base-type;
    description
      "CoAP option Proxy-Uri.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-proxy-scheme {
    base fid-coap-base-type;
    description
      "CoAP option Proxy-scheme.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-size1 {
    base fid-coap-base-type;
    description
      "CoAP option Size1.";
    reference
      "RFC 7252 The Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-no-response {
    base fid-coap-base-type;
    description
      "CoAP option No response.";
    reference
      "RFC 7967 Constrained Application Protocol (CoAP)
                Option for No Server Response";
  }

  identity fid-oscore-base-type {
    base fid-coap-type;
    description
      "OSCORE options (RFC8613) split in sub options.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP)";
  }

  identity fid-coap-option-oscore-flags {
    base fid-oscore-base-type;
    description
      "CoAP option oscore flags.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP) (see
                section 6.4)";
  }

  identity fid-coap-option-oscore-piv {
    base fid-oscore-base-type;
    description
      "CoAP option oscore flags.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP) (see
                section 6.4)";
  }

  identity fid-coap-option-oscore-kid {
    base fid-oscore-base-type;
    description
      "CoAP option oscore flags.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP) (see
                section 6.4)";
  }

  identity fid-coap-option-oscore-kidctx {
    base fid-oscore-base-type;
    description
      "CoAP option oscore flags.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP)(see
                section 6.4)";
  }

  //----------------------------------
  // Field Length type definition
  //----------------------------------

  identity fl-base-type {
    description
      "Used to extend field length functions.";
  }

  identity fl-variable {
    base fl-base-type;
    description
      "Residue length in Byte is sent as defined for CoAP.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP) (see
                section 5.3)";
  }

  identity fl-token-length {
    base fl-base-type;
    description
      "Residue length in Byte is sent as defined for CoAP.";
    reference
      "RFC 8824 Static Context Header Compression (SCHC) for the
                Constrained Application Protocol (CoAP) (see
                section 4.5)";
  }

  //---------------------------------
  // Direction Indicator type
  //---------------------------------

  identity di-base-type {
    description
      "Used to extend direction indicators.";
  }

  identity di-bidirectional {
    base di-base-type;
    description
      "Direction Indication of bidirectionality.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.1.)";
  }

  identity di-up {
    base di-base-type;
    description
      "Direction Indication of uplink.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.1).";
  }

  identity di-down {
    base di-base-type;
    description
      "Direction Indication of downlink.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.1).";
  }

  //----------------------------------
  // Matching Operator type definition
  //----------------------------------

  identity mo-base-type {
    description
      "Matching Operator: used in the rule selection process
       to check is a Target Value matches the field's value.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see*
                section 7.2).";
  }

  identity mo-equal {
    base mo-base-type;
    description
      "equal MO.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.3).";
  }

  identity mo-ignore {
    base mo-base-type;
    description
      "ignore MO.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.3).";
  }

  identity mo-msb {
    base mo-base-type;
    description
      "MSB MO.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.3).";
  }

  identity mo-match-mapping {
    base mo-base-type;
    description
      "match-mapping MO.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.3).";
  }

  //------------------------------
  // CDA type definition
  //------------------------------

  identity cda-base-type {
    description
      "Compression Decompression Actions. Specify the action to
       be applied to the field's value in a specific rule.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.2).";
  }

  identity cda-not-sent {
    base cda-base-type;
    description
      "not-sent CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.4).";
  }

  identity cda-value-sent {
    base cda-base-type;
    description
      "value-sent CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.4).";
  }

  identity cda-lsb {
    base cda-base-type;
    description
      "LSB CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.4).";
  }

  identity cda-mapping-sent {
    base cda-base-type;
    description
      "mapping-sent CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.4).";
  }

  identity cda-compute {
    base cda-base-type;
    description
      "compute-* CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.4).";
  }

  identity cda-deviid {
    base cda-base-type;
    description
      "DevIID CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.4).";
  }

  identity cda-appiid {
    base cda-base-type;
    description
      "AppIID CDA.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context
                Header Compression and Fragmentation (see
                section 7.4).";
  }

  // -- type definition

  typedef fid-type {
    type identityref {
      base fid-base-type;
    }
    description
      "Field ID generic type.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef fl-type {
    type union {
      type uint64 {
        range 1..max;
      }
      type identityref {
        base fl-base-type;
      }
    }
    description
      "Field length either a positive integer expressing the size in
       bits or a function defined through an identityref.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef di-type {
    type identityref {
      base di-base-type;
    }
    description
      "Direction in LPWAN network, up when emitted by the device,
       down when received by the device, bi when emitted or
       received by the device.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef mo-type {
    type identityref {
      base mo-base-type;
    }
    description
      "Matching Operator (MO) to compare fields values with
       target values.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef cda-type {
    type identityref {
      base cda-base-type;
    }
    description
      "Compression Decompression Action to compression or
       decompress a field.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  // -- FRAGMENTATION TYPE
  // -- fragmentation modes

  identity fragmentation-mode-base-type {
    description
      "Define the fragmentation mode.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity fragmentation-mode-no-ack {
    base fragmentation-mode-base-type;
    description
      "No-ACK mode.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity fragmentation-mode-ack-always {
    base fragmentation-mode-base-type;
    description
      "ACK-Always mode.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity fragmentation-mode-ack-on-error {
    base fragmentation-mode-base-type;
    description
      "ACK-on-Error mode.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef fragmentation-mode-type {
    type identityref {
      base fragmentation-mode-base-type;
    }
    description
      "Define the type used for fragmentation mode in rules.";
  }

  // -- Ack behavior

  identity ack-behavior-base-type {
    description
      "Define when to send an Acknowledgment .";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity ack-behavior-after-all-0 {
    base ack-behavior-base-type;
    description
      "Fragmentation expects Ack after sending All-0 fragment.";
  }

  identity ack-behavior-after-all-1 {
    base ack-behavior-base-type;
    description
      "Fragmentation expects Ack after sending All-1 fragment.";
  }

  identity ack-behavior-by-layer2 {
    base ack-behavior-base-type;
    description
      "Layer 2 defines when to send an Ack.";
  }

  typedef ack-behavior-type {
    type identityref {
      base ack-behavior-base-type;
    }
    description
      "Define the type used for Ack behavior in rules.";
  }

  // -- All-1 with data types

  identity all-1-data-base-type {
    description
      "Type to define when to send an Acknowledgment message.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity all-1-data-no {
    base all-1-data-base-type;
    description
      "All-1 contains no tiles.";
  }

  identity all-1-data-yes {
    base all-1-data-base-type;
    description
      "All-1 MUST contain a tile.";
  }

  identity all-1-data-sender-choice {
    base all-1-data-base-type;
    description
      "Fragmentation process chooses to send tiles or not in All-1.";
  }

  typedef all-1-data-type {
    type identityref {
      base all-1-data-base-type;
    }
    description
      "Define the type used for All-1 format in rules.";
  }
  // -- RCS algorithm types

  identity rcs-algorithm-base-type {
    description
      "Identify which algorithm is used to compute RCS.
       The algorithm also defines the size of the RCS field.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  identity rcs-crc32 {
    base rcs-algorithm-base-type;
    description
      "CRC 32 defined as default RCS in RFC8724. This RCS is
       4 bytes long.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  typedef rcs-algorithm-type {
    type identityref {
      base rcs-algorithm-base-type;
    }
    description
      "Define the type for RCS algorithm in rules.";
  }

  // --------  RULE ENTRY DEFINITION ------------

  grouping tv-struct {
    description
      "Defines the target value element. If the header field
       contains a text, the binary sequence uses the same encoding.
       field-id allows the conversion to the appropriate type.";
    leaf index {
      type uint16;
      description
        "Index gives the position in the matching-list. If only one
         element is present, index is 0. Otherwise, index is the
         the order in the matching list, starting at 0.";
    }
    leaf value {
      type binary;
      description
        "Target Value content as an untyped binary value.";
    }
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  grouping compression-rule-entry {
    description
      "These entries defines a compression entry (i.e. a line)
       as defined in RFC 8724.

   +-------+--+--+--+------------+-----------------+---------------+
   |Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|
   +-------+--+--+--+------------+-----------------+---------------+

       An entry in a compression rule is composed of 7 elements:
       - Field ID: The header field to be compressed.
       - Field Length : Either a positive integer of a function.
       - Field Position: A positive (and possibly equal to 0)
         integer.
       - Direction Indicator: An indication in which direction
         compression and decompression process is effective.
       - Target value: A value against which the header Field is
         compared.
       - Matching Operator: The comparison operation and optional
         associate parameters.
       - Comp./Decomp. Action: The compression or decompression
         action, and optional parameters.
      ";
    leaf field-id {
      type schc:fid-type;
      mandatory true;
      description
        "Field ID, identify a field in the header with a YANG
         identity reference.";
    }
    leaf field-length {
      type schc:fl-type;
      mandatory true;
      description
        "Field Length, expressed in number of bits if the length is
         known when the Rule is created or through a specific
         function if the length is variable.";
    }
    leaf field-position {
      type uint8;
      mandatory true;
      description
        "Field position in the header is an integer. Position 1
         matches the first occurrence of a field in the header,
         while incremented position values match subsequent
         occurrences.
         Position 0 means that this entry matches a field
         irrespective of its position of occurrence in the
         header.
         Be aware that the decompressed header may have
         position-0 fields ordered differently than they
         appeared in the original packet.";
    }
    leaf direction-indicator {
      type schc:di-type;
      mandatory true;
      description
        "Direction Indicator, indicate if this field must be
         considered for rule selection or ignored based on the
         direction (bi directionnal, only uplink, or only
         downlink).";
    }
    list target-value {
      key "index";
      uses tv-struct;
      description
        "A list of value to compare with the header field value.
         If target value is a singleton, position must be 0.
         For use as a matching list for the mo-match-mapping matching
         operator, index should take consecutive values starting
         from 0.";
    }
    leaf matching-operator {
      type schc:mo-type;
      must "../target-value or derived-from-or-self(.,
                                                   'mo-ignore')" {
        error-message
          "mo-equal, mo-msb and mo-match-mapping need target-value";
        description
          "target-value is not required for mo-ignore.";
      }
      must "not (derived-from-or-self(., 'mo-msb')) or
            ../matching-operator-value" {
        error-message "mo-msb requires length value";
      }
      mandatory true;
      description
        "MO: Matching Operator.";
      reference
        "RFC 8724 SCHC: Generic Framework for Static Context Header
                  Compression and Fragmentation (see Section 7.3).";
    }
    list matching-operator-value {
      key "index";
      uses tv-struct;
      description
        "Matching Operator Arguments, based on TV structure to allow
         several arguments.
         In RFC 8724, only the MSB matching operator needs arguments
         (a single argument, which is the number of most significant
         bits to be matched).";
    }
    leaf comp-decomp-action {
      type schc:cda-type;
      must "../target-value or
                derived-from-or-self(., 'cda-value-sent') or
                derived-from-or-self(., 'cda-compute') or
                derived-from-or-self(., 'cda-appiid') or
                derived-from-or-self(., 'cda-deviid')" {
        error-message
          "cda-not-sent, cda-lsb, cda-mapping-sent need
           target-value";
        description
          "target-value is not required for some CDA.";
        }
      mandatory true;
      description
        "CDA: Compression Decompression Action.";
      reference
        "RFC 8724 SCHC: Generic Framework for Static Context Header
                  Compression and Fragmentation (see section 7.4)";
    }
    list comp-decomp-action-value {
      key "index";
      uses tv-struct;
      description
        "CDA arguments, based on a TV structure, in order to allow
         for several arguments. The CDAs specified in RFC 8724
         require no argument.";
    }

  }

  // --Rule nature

  identity nature-base-type {
    description
      "A rule, identified by its RuleID, are used for a single
       purpose. RFC 8724 defines 2 natures:
       compression, no compression and fragmentation.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation (see section 6).";
  }

  identity nature-compression {
    base nature-base-type;
    description
      "Identify a compression rule.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation (see section 6).";
  }

  identity nature-no-compression {
    base nature-base-type;
    description
      "Identify a no compression rule.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation (see section 6).";
  }

  identity nature-fragmentation {
    base nature-base-type;
    description
      "Identify a fragmentation rule.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation (see section 6).";
  }

  typedef nature-type {
    type identityref {
      base nature-base-type;
    }
    description
      "defines the type to indicate the nature of the rule.";
  }

  grouping compression-content {
    list entry {
      must "derived-from-or-self(../rule-nature,
                                        'nature-compression')" {
        error-message "Rule nature must be compression";
      }
      key "field-id field-position direction-indicator";
      uses compression-rule-entry;
      description
        "A compression rule is a list of rule entries, each
         describing a header field. An entry is identified
         through a field-id, its position in the packet, and
         its direction.";
    }
    description
      "Define a compression rule composed of a list of entries.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  grouping fragmentation-content {
    description
      "This grouping defines the fragmentation parameters for
       all the modes (No-ACK, ACK-Always and ACK-on-Error) specified
       in RFC 8724.";
    leaf fragmentation-mode {
      type schc:fragmentation-mode-type;
      must "derived-from-or-self(../rule-nature,
                                        'nature-fragmentation')" {
        error-message "Rule nature must be fragmentation";
      }
      mandatory true;
      description
        "Which fragmentation mode is used (No-Ack, ACK-Always,
         ACK-on-Error).";
    }
    leaf l2-word-size {
      type uint8;
      default "8";
      description
        "Size, in bits, of the layer 2 word.";
    }
    leaf direction {
      type schc:di-type;
      must "derived-from-or-self(., 'di-up') or
            derived-from-or-self(., 'di-down')" {
        error-message
          "Direction for fragmentation rules are up or down.";
      }
      mandatory true;
      description
        "MUST be up or down, bidirectional MUST NOT be used.";
    }
    // SCHC Frag header format
    leaf dtag-size {
      type uint8;
      default "0";
      description
        "Size, in bits, of the DTag field (T variable from
         RFC8724).";
    }
    leaf w-size {
      when "derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      type uint8;
      description
        "Size, in bits, of the window field (M variable from
         RFC8724).";
    }
    leaf fcn-size {
      type uint8;
      mandatory true;
      description
        "Size, in bits, of the FCN field (N variable from RFC8724).";
    }
    leaf rcs-algorithm {
      type rcs-algorithm-type;
      default "schc:rcs-crc32";
      description
        "Algorithm used for RCS. The algorithm specifies the RCS
         size.";
    }
    // SCHC fragmentation protocol parameters
    leaf maximum-packet-size {
      type uint16;
      default "1280";
      description
        "When decompression is done, packet size must not
         strictly exceed this limit, expressed in bytes.";
    }
    leaf window-size {
      type uint16;
      description
        "By default, if not specified 2^w-size - 1. Should not exceed
         this value. Possible FCN values are between 0 and
         window-size - 1.";
    }
    leaf max-interleaved-frames {
      type uint8;
      default "1";
      description
        "Maximum of simultaneously fragmented frames. Maximum value
         is 2^dtag-size. All DTAG values can be used, but more than
         max-interleaved-frames MUST NOT be active at any time";
    }
    container inactivity-timer {
      leaf ticks-duration {
        type uint8;
        default "20";
        description
          "Duration of one tick in micro-seconds:
              2^ticks-duration/10^6 = 1.048s.";
      }
      leaf ticks-numbers {
        type uint16 {
          range "0..max";
        }
        description
          "Timer duration = ticks-numbers*2^ticks-duration / 10^6.";
      }

      description
        "Duration is seconds of the inactivity timer, 0 indicates
         that the timer is disabled.

         Allows a precision from micro-second to year by sending the
         tick-duration value. For instance:

       tick-duration /  smallest value          highest value
       v
       20: 00y 000d 00h 00m 01s.048575<->00y 000d 19h 05m 18s.428159
       21: 00y 000d 00h 00m 02s.097151<->00y 001d 14h 10m 36s.856319
       22: 00y 000d 00h 00m 04s.194303<->00y 003d 04h 21m 13s.712639
       23: 00y 000d 00h 00m 08s.388607<->00y 006d 08h 42m 27s.425279
       24: 00y 000d 00h 00m 16s.777215<->00y 012d 17h 24m 54s.850559
       25: 00y 000d 00h 00m 33s.554431<->00y 025d 10h 49m 49s.701119

        Note that the smallest value is also the incrementation step,
        so the timer precision.";
    }
    container retransmission-timer {
      leaf ticks-duration {
        type uint8;
        default "20";
        description
          "Duration of one tick in micro-seconds:
              2^ticks-duration/10^6 = 1.048s.";
      }
      leaf ticks-numbers {
        type uint16 {
          range "1..max";
        }
        description
          "Timer duration = ticks-numbers*2^ticks-duration / 10^6.";
      }

      when "derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      description
        "Duration in seconds of the retransmission timer.
         See inactivity timer.";
    }
    leaf max-ack-requests {
      when "derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from-or-self(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      type uint8 {
        range "1..max";
      }
      description
        "The maximum number of retries for a specific SCHC ACK.";
    }
    choice mode {
      case no-ack;
      case ack-always;
      case ack-on-error {
        leaf tile-size {
          when "derived-from-or-self(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type uint8;
          description
            "Size, in bits, of tiles. If not specified or set to 0,
             tiles fill the fragment.";
        }
        leaf tile-in-all-1 {
          when "derived-from-or-self(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type schc:all-1-data-type;
          description
            "Defines whether the sender and receiver expect a tile in
             All-1 fragments or not, or if it is left to the sender's
             choice.";
        }
        leaf ack-behavior {
          when "derived-from-or-self(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type schc:ack-behavior-type;
          description
            "Sender behavior to acknowledge, after All-0, All-1 or
             when the LPWAN allows it.";
        }
      }
      description
        "RFC 8724 defines 3 fragmentation modes.";
    }
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  // Define rule ID. Rule ID is composed of a RuleID value and a
  // Rule ID Length

  grouping rule-id-type {
    leaf rule-id-value {
      type uint32;
      description
        "Rule ID value, this value must be unique, considering its
         length.";
    }
    leaf rule-id-length {
      type uint8 {
        range "0..32";
      }
      description
        "Rule ID length, in bits. The value 0 is for implicit
         rules.";
    }
    description
      "A rule ID is composed of a value and a length, expressed in
       bits.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }

  // SCHC table for a specific device.

  container schc {
    list rule {
      key "rule-id-value rule-id-length";
      uses rule-id-type;
      leaf rule-nature {
        type nature-type;
        mandatory true;
        description
          "Specify the rule's nature.";
      }
      choice nature {
        case fragmentation {
          if-feature "fragmentation";
          uses fragmentation-content;
        }
        case compression {
          if-feature "compression";
          uses compression-content;
        }
        description
          "A rule is for compression, for no-compression or for
           fragmentation.";
      }
      description
        "Set of rules compression, no compression or fragmentation
         rules identified by their rule-id.";
    }
    description
      "A SCHC set of rules is composed of a list of rules which are
       used for compression, no-compression or fragmentation.";
    reference
      "RFC 8724 SCHC: Generic Framework for Static Context Header
                Compression and Fragmentation";
  }
}
