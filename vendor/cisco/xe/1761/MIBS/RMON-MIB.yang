/*
 * Generated by confdc --mib2yang-std
 * Source: mgmt/dmi/model/mib/src/RMON-MIB.mib
 */
/*
 * This YANG module has been generated by smidump 0.5.0:
 *
 *      smidump -f yang RMON-MIB
 *
 * Do not edit. Edit the source file instead!
 */

module RMON-MIB {

  namespace "urn:ietf:params:xml:ns:yang:smiv2:RMON-MIB";
  prefix RMON-MIB;

  import SNMPv2-TC {
    prefix "snmpv2-tc";
  }

  import ietf-yang-smiv2 {
    prefix "smiv2";
  }

  import ietf-yang-types {
    prefix "yang";
  }

  organization
   "IETF RMON MIB Working Group";

  contact
   "Steve Waldbusser
    Phone: +1-650-948-6500
    Fax:   +1-650-745-0671
    Email: waldbusser@nextbeacon.com";

  description
   "Remote network monitoring devices, often called
    monitors or probes, are instruments that exist for
    the purpose of managing a network. This MIB defines
    objects for managing remote network monitoring devices.";

  revision 2000-05-11 {
    description
     "Reformatted into SMIv2 format.
      
      This version published as RFC 2819.";
  }

  revision 1995-02-01 {
    description
     "Bug fixes, clarifications and minor changes based on
      implementation experience, published as RFC1757 [18].
      
      Two changes were made to object definitions:
      
      1) A new status bit has been defined for the
      captureBufferPacketStatus object, indicating that the
      packet order within the capture buffer may not be identical to
      the packet order as received off the wire.  This bit may only
      be used for packets transmitted by the probe.  Older NMS
      applications can safely ignore this status bit, which might be
      used by newer agents.
      
      2) The packetMatch trap has been removed.  This trap was never
      actually 'approved' and was not added to this document along
      with the risingAlarm and fallingAlarm traps. The packetMatch
      trap could not be throttled, which could cause disruption of
      normal network traffic under some circumstances. An NMS should
      configure a risingAlarm threshold on the appropriate
      channelMatches instance if a trap is desired for a packetMatch
      event. Note that logging of packetMatch events is still
      supported--only trap generation for such events has been
      removed.
      
      In addition, several clarifications to individual object
      definitions have been added to assist agent and NMS
      implementors:
      
      - global definition of 'good packets' and 'bad packets'
      
      - more detailed text governing conceptual row creation and
        modification
      
      - instructions for probes relating to interface changes and
        disruptions
      
      - clarification of some ethernet counter definitions
      
      - recommended formula for calculating network utilization
      
      - clarification of channel and captureBuffer behavior for some
        unusual conditions
      
      - examples of proper instance naming for each table";
  }

  revision 1991-11-01 {
    description
     "The original version of this MIB, published as RFC1271.";
  }

  typedef OwnerString {
    type binary {
      length "0..127";
    }
    description
     "This data type is used to model an administratively
      assigned name of the owner of a resource. Implementations
      must accept values composed of well-formed NVT ASCII
      sequences. In addition, implementations should accept
      values composed of well-formed UTF-8 sequences.
      
      It is suggested that this name contain one or more of
      the following: IP address, management station name,
      network manager's name, location, or phone number.
      In some cases the agent itself will be the owner of
      an entry.  In these cases, this string shall be set
      to a string starting with 'monitor'.
      
      SNMP access control is articulated entirely in terms
      of the contents of MIB views; access to a particular
      SNMP object instance depends only upon its presence
      or absence in a particular MIB view and never upon
      its value or the value of related object instances.
      Thus, objects of this type afford resolution of
      resource contention only among cooperating
      managers; they realize no access control function
      with respect to uncooperative parties.";
  }

  typedef EntryStatus {
    type enumeration {
      enum "valid" {
        value "1";
      }
      enum "createRequest" {
        value "2";
      }
      enum "underCreation" {
        value "3";
      }
      enum "invalid" {
        value "4";
      }
    }
    description
     "The status of a table entry.
      
      Setting this object to the value invalid(4) has the
      effect of invalidating the corresponding entry.
      That is, it effectively disassociates the mapping
      identified with said entry.
      It is an implementation-specific matter as to whether
      the agent removes an invalidated entry from the table.
      Accordingly, management stations must be prepared to
      receive tabular information from agents that corresponds
      to entries currently not in use.  Proper
      interpretation of such entries requires examination
      of the relevant EntryStatus object.
      
      An existing instance of this object cannot be set to
      createRequest(2).  This object may only be set to
      createRequest(2) when this instance is created.  When
      this object is created, the agent may wish to create
      supplemental object instances with default values
      to complete a conceptual row in this table.  Because the
      creation of these default objects is entirely at the option
      of the agent, the manager must not assume that any will be
      created, but may make use of any that are created.
      Immediately after completing the create operation, the agent
      must set this object to underCreation(3).
      
      When in the underCreation(3) state, an entry is allowed to
      exist in a possibly incomplete, possibly inconsistent state,
      usually to allow it to be modified in multiple PDUs.  When in
      this state, an entry is not fully active.
      Entries shall exist in the underCreation(3) state until
      the management station is finished configuring the entry
      and sets this object to valid(1) or aborts, setting this
      object to invalid(4).  If the agent determines that an
      entry has been in the underCreation(3) state for an
      abnormally long time, it may decide that the management
      station has crashed.  If the agent makes this decision,
      it may set this object to invalid(4) to reclaim the
      entry.  A prudent agent will understand that the
      management station may need to wait for human input
      and will allow for that possibility in its
      determination of this abnormally long period.
      
      An entry in the valid(1) state is fully configured and
      consistent and fully represents the configuration or
      operation such a row is intended to represent.  For
      example, it could be a statistical function that is
      configured and active, or a filter that is available
      in the list of filters processed by the packet capture
      process.
      
      A manager is restricted to changing the state of an entry in
      the following ways:
      
           To:       valid  createRequest  underCreation  invalid
      From:
      valid             OK             NO             OK       OK
      createRequest    N/A            N/A            N/A      N/A
      underCreation     OK             NO             OK       OK
      invalid           NO             NO             NO       OK
      nonExistent       NO             OK             NO       OK
      
      In the table above, it is not applicable to move the state
      from the createRequest state to any other state because the
      manager will never find the variable in that state.  The
      nonExistent state is not a value of the enumeration, rather
      it means that the entryStatus variable does not exist at all.
      
      An agent may allow an entryStatus variable to change state in
      additional ways, so long as the semantics of the states are
      followed.  This allowance is made to ease the implementation of
      the agent and is made despite the fact that managers should
      never exercise these additional state transitions.";
  }

  identity rmonEventsV2 {
    base smiv2:object-identity;
    description
     "Definition point for RMON notifications.";
    smiv2:oid "1.3.6.1.2.1.16.0";
  }


  container RMON-MIB {
    config false;

    container etherStatsTable {
      description
       "A list of Ethernet statistics entries.";
      smiv2:oid "1.3.6.1.2.1.16.1.1";

      list etherStatsEntry {
        key "etherStatsIndex";
        description
         "A collection of statistics kept for a particular
          Ethernet interface.  As an example, an instance of the
          etherStatsPkts object might be named etherStatsPkts.1";
        smiv2:oid "1.3.6.1.2.1.16.1.1.1";

        leaf etherStatsIndex {
          type int32 {
            range "1..65535";
          }
          description
           "The value of this object uniquely identifies this
            etherStats entry.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.1";
        }

        leaf etherStatsDataSource {
          type yang:object-identifier-128;
          description
           "This object identifies the source of the data that
            this etherStats entry is configured to analyze.  This
            source can be any ethernet interface on this device.
            In order to identify a particular interface, this object
            shall identify the instance of the ifIndex object,
            defined in RFC 2233 [17], for the desired interface.
            For example, if an entry were to receive data from
            interface #1, this object would be set to ifIndex.1.
            
            The statistics in this group reflect all packets
            on the local network segment attached to the identified
            interface.
            
            An agent may or may not be able to tell if fundamental
            changes to the media of the interface have occurred and
            necessitate an invalidation of this entry.  For example, a
            hot-pluggable ethernet card could be pulled out and replaced
            by a token-ring card.  In such a case, if the agent has such
            knowledge of the change, it is recommended that it
            invalidate this entry.
            
            This object may not be modified if the associated
            etherStatsStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.2";
        }

        leaf etherStatsDropEvents {
          type yang:counter32;
          description
           "The total number of events in which packets
            were dropped by the probe due to lack of resources.
            Note that this number is not necessarily the number of
            packets dropped; it is just the number of times this
            condition has been detected.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.3";
        }

        leaf etherStatsOctets {
          type yang:counter32;
          units "Octets";
          description
           "The total number of octets of data (including
            those in bad packets) received on the
            network (excluding framing bits but including
            FCS octets).
            This object can be used as a reasonable estimate of
            10-Megabit ethernet utilization.  If greater precision is
            desired, the etherStatsPkts and etherStatsOctets objects
            should be sampled before and after a common interval.  The
            differences in the sampled values are Pkts and Octets,
            respectively, and the number of seconds in the interval is
            Interval.  These values are used to calculate the Utilization
            as follows:
            
                             Pkts * (9.6 + 6.4) + (Octets * .8)
             Utilization = -------------------------------------
                                     Interval * 10,000
            
            The result of this equation is the value Utilization which
            is the percent utilization of the ethernet segment on a
            scale of 0 to 100 percent.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.4";
        }

        leaf etherStatsPkts {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets (including bad packets,
            broadcast packets, and multicast packets) received.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.5";
        }

        leaf etherStatsBroadcastPkts {
          type yang:counter32;
          units "Packets";
          description
           "The total number of good packets received that were
            directed to the broadcast address.  Note that this
            does not include multicast packets.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.6";
        }

        leaf etherStatsMulticastPkts {
          type yang:counter32;
          units "Packets";
          description
           "The total number of good packets received that were
            directed to a multicast address.  Note that this number
            does not include packets directed to the broadcast
            address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.7";
        }

        leaf etherStatsCRCAlignErrors {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets received that
            had a length (excluding framing bits, but
            including FCS octets) of between 64 and 1518
            octets, inclusive, but had either a bad
            Frame Check Sequence (FCS) with an integral
            number of octets (FCS Error) or a bad FCS with
            a non-integral number of octets (Alignment Error).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.8";
        }

        leaf etherStatsUndersizePkts {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets received that were
            less than 64 octets long (excluding framing bits,
            but including FCS octets) and were otherwise well
            formed.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.9";
        }

        leaf etherStatsOversizePkts {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets received that were
            longer than 1518 octets (excluding framing bits,
            but including FCS octets) and were otherwise
            well formed.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.10";
        }

        leaf etherStatsFragments {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets received that were less than
            64 octets in length (excluding framing bits but including
            FCS octets) and had either a bad Frame Check Sequence
            (FCS) with an integral number of octets (FCS Error) or a
            bad FCS with a non-integral number of octets (Alignment
            Error).
            
            Note that it is entirely normal for etherStatsFragments to
            increment.  This is because it counts both runts (which are
            normal occurrences due to collisions) and noise hits.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.11";
        }

        leaf etherStatsJabbers {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets received that were
            longer than 1518 octets (excluding framing bits,
            but including FCS octets), and had either a bad
            Frame Check Sequence (FCS) with an integral number
            of octets (FCS Error) or a bad FCS with a non-integral
            number of octets (Alignment Error).
            
            Note that this definition of jabber is different
            than the definition in IEEE-802.3 section 8.2.1.5
            (10BASE5) and section 10.3.1.4 (10BASE2).  These
            documents define jabber as the condition where any
            packet exceeds 20 ms.  The allowed range to detect
            jabber is between 20 ms and 150 ms.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.12";
        }

        leaf etherStatsCollisions {
          type yang:counter32;
          units "Collisions";
          description
           "The best estimate of the total number of collisions
            on this Ethernet segment.
            
            The value returned will depend on the location of the
            RMON probe. Section 8.2.1.3 (10BASE-5) and section
            10.3.1.3 (10BASE-2) of IEEE standard 802.3 states that a
            station must detect a collision, in the receive mode, if
            three or more stations are transmitting simultaneously.  A
            repeater port must detect a collision when two or more
            stations are transmitting simultaneously.  Thus a probe
            placed on a repeater port could record more collisions
            than a probe connected to a station on the same segment
            would.
            
            Probe location plays a much smaller role when considering
            10BASE-T.  14.2.1.4 (10BASE-T) of IEEE standard 802.3
            defines a collision as the simultaneous presence of signals
            on the DO and RD circuits (transmitting and receiving
            at the same time).  A 10BASE-T station can only detect
            collisions when it is transmitting.  Thus probes placed on
            a station and a repeater, should report the same number of
            collisions.
            
            Note also that an RMON probe inside a repeater should
            ideally report collisions between the repeater and one or
            more other hosts (transmit collisions as defined by IEEE
            802.3k) plus receiver collisions observed on any coax
            segments to which the repeater is connected.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.13";
        }

        leaf etherStatsPkts64Octets {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets (including bad
            packets) received that were 64 octets in length
            (excluding framing bits but including FCS octets).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.14";
        }

        leaf etherStatsPkts65to127Octets {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets (including bad
            packets) received that were between
            65 and 127 octets in length inclusive
            (excluding framing bits but including FCS octets).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.15";
        }

        leaf etherStatsPkts128to255Octets {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets (including bad
            packets) received that were between
            128 and 255 octets in length inclusive
            (excluding framing bits but including FCS octets).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.16";
        }

        leaf etherStatsPkts256to511Octets {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets (including bad
            packets) received that were between
            256 and 511 octets in length inclusive
            (excluding framing bits but including FCS octets).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.17";
        }

        leaf etherStatsPkts512to1023Octets {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets (including bad
            packets) received that were between
            512 and 1023 octets in length inclusive
            (excluding framing bits but including FCS octets).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.18";
        }

        leaf etherStatsPkts1024to1518Octets {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets (including bad
            packets) received that were between
            1024 and 1518 octets in length inclusive
            (excluding framing bits but including FCS octets).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.19";
        }

        leaf etherStatsOwner {
          type RMON-MIB:OwnerString;
          description
           "The entity that configured this entry and is therefore
            using the resources assigned to it.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.20";
        }

        leaf etherStatsStatus {
          type RMON-MIB:EntryStatus;
          description
           "The status of this etherStats entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.1.1.1.21";
        }
      }
    }

    container historyControlTable {
      description
       "A list of history control entries.";
      smiv2:oid "1.3.6.1.2.1.16.2.1";

      list historyControlEntry {
        key "historyControlIndex";
        description
         "A list of parameters that set up a periodic sampling of
          statistics.  As an example, an instance of the
          historyControlInterval object might be named
          historyControlInterval.2";
        smiv2:oid "1.3.6.1.2.1.16.2.1.1";

        leaf historyControlIndex {
          type int32 {
            range "1..65535";
          }
          description
           "An index that uniquely identifies an entry in the
            historyControl table.  Each such entry defines a
            set of samples at a particular interval for an
            interface on the device.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.1.1.1";
        }

        leaf historyControlDataSource {
          type yang:object-identifier-128;
          description
           "This object identifies the source of the data for
            which historical data was collected and
            placed in a media-specific table on behalf of this
            historyControlEntry.  This source can be any
            interface on this device.  In order to identify
            a particular interface, this object shall identify
            the instance of the ifIndex object, defined
            in  RFC 2233 [17], for the desired interface.
            For example, if an entry were to receive data from
            interface #1, this object would be set to ifIndex.1.
            
            The statistics in this group reflect all packets
            on the local network segment attached to the identified
            interface.
            
            An agent may or may not be able to tell if fundamental
            changes to the media of the interface have occurred and
            necessitate an invalidation of this entry.  For example, a
            hot-pluggable ethernet card could be pulled out and replaced
            by a token-ring card.  In such a case, if the agent has such
            knowledge of the change, it is recommended that it
            invalidate this entry.
            
            This object may not be modified if the associated
            historyControlStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.2.1.1.2";
        }

        leaf historyControlBucketsRequested {
          type int32 {
            range "1..65535";
          }
          description
           "The requested number of discrete time intervals
            over which data is to be saved in the part of the
            media-specific table associated with this
            historyControlEntry.
            
            When this object is created or modified, the probe
            should set historyControlBucketsGranted as closely to
            this object as is possible for the particular probe
            implementation and available resources.";
          smiv2:defval "50";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.2.1.1.3";
        }

        leaf historyControlBucketsGranted {
          type int32 {
            range "1..65535";
          }
          description
           "The number of discrete sampling intervals
            over which data shall be saved in the part of
            the media-specific table associated with this
            historyControlEntry.
            When the associated historyControlBucketsRequested
            object is created or modified, the probe
            should set this object as closely to the requested
            value as is possible for the particular
            probe implementation and available resources.  The
            probe must not lower this value except as a result
            of a modification to the associated
            historyControlBucketsRequested object.
            
            There will be times when the actual number of
            buckets associated with this entry is less than
            the value of this object.  In this case, at the
            end of each sampling interval, a new bucket will
            be added to the media-specific table.
            
            When the number of buckets reaches the value of
            this object and a new bucket is to be added to the
            media-specific table, the oldest bucket associated
            with this historyControlEntry shall be deleted by
            the agent so that the new bucket can be added.
            
            When the value of this object changes to a value less
            than the current value, entries are deleted
            from the media-specific table associated with this
            historyControlEntry.  Enough of the oldest of these
            entries shall be deleted by the agent so that their
            number remains less than or equal to the new value of
            this object.
            
            When the value of this object changes to a value greater
            than the current value, the number of associated media-
            specific entries may be allowed to grow.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.1.1.4";
        }

        leaf historyControlInterval {
          type int32 {
            range "1..3600";
          }
          units "Seconds";
          description
           "The interval in seconds over which the data is
            sampled for each bucket in the part of the
            media-specific table associated with this
            historyControlEntry.  This interval can
            be set to any number of seconds between 1 and
            3600 (1 hour).
            
            Because the counters in a bucket may overflow at their
            maximum value with no indication, a prudent manager will
            take into account the possibility of overflow in any of
            the associated counters.  It is important to consider the
            minimum time in which any counter could overflow on a
            particular media type and set the historyControlInterval
            object to a value less than this interval.  This is
            typically most important for the 'octets' counter in any
            media-specific table.  For example, on an Ethernet
            network, the etherHistoryOctets counter could overflow
            in about one hour at the Ethernet's maximum
            utilization.
            
            This object may not be modified if the associated
            historyControlStatus object is equal to valid(1).";
          smiv2:defval "1800";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.2.1.1.5";
        }

        leaf historyControlOwner {
          type RMON-MIB:OwnerString;
          description
           "The entity that configured this entry and is therefore
            using the resources assigned to it.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.2.1.1.6";
        }

        leaf historyControlStatus {
          type RMON-MIB:EntryStatus;
          description
           "The status of this historyControl entry.
            
            Each instance of the media-specific table associated
            with this historyControlEntry will be deleted by the agent
            if this historyControlEntry is not equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.2.1.1.7";
        }
      }
    }

    container etherHistoryTable {
      description
       "A list of Ethernet history entries.";
      smiv2:oid "1.3.6.1.2.1.16.2.2";

      list etherHistoryEntry {
        key "etherHistoryIndex etherHistorySampleIndex";
        description
         "An historical sample of Ethernet statistics on a particular
          Ethernet interface.  This sample is associated with the
          historyControlEntry which set up the parameters for
          a regular collection of these samples.  As an example, an
          instance of the etherHistoryPkts object might be named
          etherHistoryPkts.2.89";
        smiv2:oid "1.3.6.1.2.1.16.2.2.1";

        leaf etherHistoryIndex {
          type int32 {
            range "1..65535";
          }
          description
           "The history of which this entry is a part.  The
            history identified by a particular value of this
            index is the same history as identified
            by the same value of historyControlIndex.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.1";
        }

        leaf etherHistorySampleIndex {
          type int32 {
            range "1..2147483647";
          }
          description
           "An index that uniquely identifies the particular
            sample this entry represents among all samples
            associated with the same historyControlEntry.
            This index starts at 1 and increases by one
            as each new sample is taken.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.2";
        }

        leaf etherHistoryIntervalStart {
          type yang:timeticks;
          description
           "The value of sysUpTime at the start of the interval
            over which this sample was measured.  If the probe
            keeps track of the time of day, it should start
            the first sample of the history at a time such that
            when the next hour of the day begins, a sample is
            started at that instant.  Note that following this
            rule may require the probe to delay collecting the
            first sample of the history, as each sample must be
            of the same interval.  Also note that the sample which
            is currently being collected is not accessible in this
            table until the end of its interval.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.3";
        }

        leaf etherHistoryDropEvents {
          type yang:counter32;
          description
           "The total number of events in which packets
            were dropped by the probe due to lack of resources
            during this sampling interval.  Note that this number
            is not necessarily the number of packets dropped, it
            is just the number of times this condition has been
            detected.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.4";
        }

        leaf etherHistoryOctets {
          type yang:counter32;
          units "Octets";
          description
           "The total number of octets of data (including
            those in bad packets) received on the
            network (excluding framing bits but including
            FCS octets).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.5";
        }

        leaf etherHistoryPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of packets (including bad packets)
            received during this sampling interval.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.6";
        }

        leaf etherHistoryBroadcastPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of good packets received during this
            sampling interval that were directed to the
            broadcast address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.7";
        }

        leaf etherHistoryMulticastPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of good packets received during this
            sampling interval that were directed to a
            multicast address.  Note that this number does not
            include packets addressed to the broadcast address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.8";
        }

        leaf etherHistoryCRCAlignErrors {
          type yang:counter32;
          units "Packets";
          description
           "The number of packets received during this
            sampling interval that had a length (excluding
            framing bits but including FCS octets) between
            64 and 1518 octets, inclusive, but had either a bad Frame
            Check Sequence (FCS) with an integral number of octets
            (FCS Error) or a bad FCS with a non-integral number
            of octets (Alignment Error).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.9";
        }

        leaf etherHistoryUndersizePkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of packets received during this
            sampling interval that were less than 64 octets
            long (excluding framing bits but including FCS
            octets) and were otherwise well formed.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.10";
        }

        leaf etherHistoryOversizePkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of packets received during this
            sampling interval that were longer than 1518
            octets (excluding framing bits but including
            FCS octets) but were otherwise well formed.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.11";
        }

        leaf etherHistoryFragments {
          type yang:counter32;
          units "Packets";
          description
           "The total number of packets received during this
            sampling interval that were less than 64 octets in
            length (excluding framing bits but including FCS
            octets) had either a bad Frame Check Sequence (FCS)
            with an integral number of octets (FCS Error) or a bad
            FCS with a non-integral number of octets (Alignment
            Error).
            
            Note that it is entirely normal for etherHistoryFragments to
            increment.  This is because it counts both runts (which are
            normal occurrences due to collisions) and noise hits.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.12";
        }

        leaf etherHistoryJabbers {
          type yang:counter32;
          units "Packets";
          description
           "The number of packets received during this
            sampling interval that were longer than 1518 octets
            (excluding framing bits but including FCS octets),
            and  had either a bad Frame Check Sequence (FCS)
            with an integral number of octets (FCS Error) or
            a bad FCS with a non-integral number of octets
            (Alignment Error).
            
            Note that this definition of jabber is different
            than the definition in IEEE-802.3 section 8.2.1.5
            (10BASE5) and section 10.3.1.4 (10BASE2).  These
            documents define jabber as the condition where any
            packet exceeds 20 ms.  The allowed range to detect
            jabber is between 20 ms and 150 ms.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.13";
        }

        leaf etherHistoryCollisions {
          type yang:counter32;
          units "Collisions";
          description
           "The best estimate of the total number of collisions
            on this Ethernet segment during this sampling
            interval.
            
            The value returned will depend on the location of the
            RMON probe. Section 8.2.1.3 (10BASE-5) and section
            10.3.1.3 (10BASE-2) of IEEE standard 802.3 states that a
            station must detect a collision, in the receive mode, if
            three or more stations are transmitting simultaneously.  A
            repeater port must detect a collision when two or more
            stations are transmitting simultaneously.  Thus a probe
            placed on a repeater port could record more collisions
            than a probe connected to a station on the same segment
            would.
            
            Probe location plays a much smaller role when considering
            10BASE-T.  14.2.1.4 (10BASE-T) of IEEE standard 802.3
            defines a collision as the simultaneous presence of signals
            on the DO and RD circuits (transmitting and receiving
            at the same time).  A 10BASE-T station can only detect
            collisions when it is transmitting.  Thus probes placed on
            a station and a repeater, should report the same number of
            collisions.
            
            Note also that an RMON probe inside a repeater should
            ideally report collisions between the repeater and one or
            more other hosts (transmit collisions as defined by IEEE
            802.3k) plus receiver collisions observed on any coax
            segments to which the repeater is connected.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.14";
        }

        leaf etherHistoryUtilization {
          type int32 {
            range "0..10000";
          }
          description
           "The best estimate of the mean physical layer
            network utilization on this interface during this
            sampling interval, in hundredths of a percent.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.2.2.1.15";
        }
      }
    }

    container alarmTable {
      description
       "A list of alarm entries.";
      smiv2:oid "1.3.6.1.2.1.16.3.1";

      list alarmEntry {
        key "alarmIndex";
        description
         "A list of parameters that set up a periodic checking
          for alarm conditions.  For example, an instance of the
          alarmValue object might be named alarmValue.8";
        smiv2:oid "1.3.6.1.2.1.16.3.1.1";

        leaf alarmIndex {
          type int32 {
            range "1..65535";
          }
          description
           "An index that uniquely identifies an entry in the
            alarm table.  Each such entry defines a
            diagnostic sample at a particular interval
            for an object on the device.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.1";
        }

        leaf alarmInterval {
          type int32;
          units "Seconds";
          description
           "The interval in seconds over which the data is
            sampled and compared with the rising and falling
            thresholds.  When setting this variable, care
            should be taken in the case of deltaValue
            sampling - the interval should be set short enough
            that the sampled variable is very unlikely to
            increase or decrease by more than 2^31 - 1 during
            a single sampling interval.
            
            This object may not be modified if the associated
            alarmStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.2";
        }

        leaf alarmVariable {
          type yang:object-identifier-128;
          description
           "The object identifier of the particular variable to be
            sampled.  Only variables that resolve to an ASN.1 primitive
            type of INTEGER (INTEGER, Integer32, Counter32, Counter64,
            Gauge, or TimeTicks) may be sampled.
            
            Because SNMP access control is articulated entirely
            in terms of the contents of MIB views, no access
            control mechanism exists that can restrict the value of
            this object to identify only those objects that exist
            in a particular MIB view.  Because there is thus no
            acceptable means of restricting the read access that
            could be obtained through the alarm mechanism, the
            probe must only grant write access to this object in
            those views that have read access to all objects on
            the probe.
            
            During a set operation, if the supplied variable name is
            not available in the selected MIB view, a badValue error
            must be returned.  If at any time the variable name of
            an established alarmEntry is no longer available in the
            selected MIB view, the probe must change the status of
            this alarmEntry to invalid(4).
            
            This object may not be modified if the associated
            alarmStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.3";
        }

        leaf alarmSampleType {
          type enumeration {
            enum "absoluteValue" {
              value "1";
            }
            enum "deltaValue" {
              value "2";
            }
          }
          description
           "The method of sampling the selected variable and
            calculating the value to be compared against the
            thresholds.  If the value of this object is
            absoluteValue(1), the value of the selected variable
            will be compared directly with the thresholds at the
            end of the sampling interval.  If the value of this
            object is deltaValue(2), the value of the selected
            variable at the last sample will be subtracted from
            the current value, and the difference compared with
            the thresholds.
            
            This object may not be modified if the associated
            alarmStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.4";
        }

        leaf alarmValue {
          type int32;
          description
           "The value of the statistic during the last sampling
            period.  For example, if the sample type is deltaValue,
            this value will be the difference between the samples
            at the beginning and end of the period.  If the sample
            type is absoluteValue, this value will be the sampled
            value at the end of the period.
            This is the value that is compared with the rising and
            falling thresholds.
            
            The value during the current sampling period is not
            made available until the period is completed and will
            remain available until the next period completes.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.5";
        }

        leaf alarmStartupAlarm {
          type enumeration {
            enum "risingAlarm" {
              value "1";
            }
            enum "fallingAlarm" {
              value "2";
            }
            enum "risingOrFallingAlarm" {
              value "3";
            }
          }
          description
           "The alarm that may be sent when this entry is first
            set to valid.  If the first sample after this entry
            becomes valid is greater than or equal to the
            risingThreshold and alarmStartupAlarm is equal to
            risingAlarm(1) or risingOrFallingAlarm(3), then a single
            rising alarm will be generated.  If the first sample
            after this entry becomes valid is less than or equal
            to the fallingThreshold and alarmStartupAlarm is equal
            to fallingAlarm(2) or risingOrFallingAlarm(3), then a
            single falling alarm will be generated.
            
            This object may not be modified if the associated
            alarmStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.6";
        }

        leaf alarmRisingThreshold {
          type int32;
          description
           "A threshold for the sampled statistic.  When the current
            sampled value is greater than or equal to this threshold,
            and the value at the last sampling interval was less than
            this threshold, a single event will be generated.
            A single event will also be generated if the first
            sample after this entry becomes valid is greater than or
            equal to this threshold and the associated
            alarmStartupAlarm is equal to risingAlarm(1) or
            risingOrFallingAlarm(3).
            
            After a rising event is generated, another such event
            will not be generated until the sampled value
            falls below this threshold and reaches the
            alarmFallingThreshold.
            
            This object may not be modified if the associated
            alarmStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.7";
        }

        leaf alarmFallingThreshold {
          type int32;
          description
           "A threshold for the sampled statistic.  When the current
            sampled value is less than or equal to this threshold,
            and the value at the last sampling interval was greater than
            this threshold, a single event will be generated.
            A single event will also be generated if the first
            sample after this entry becomes valid is less than or
            equal to this threshold and the associated
            alarmStartupAlarm is equal to fallingAlarm(2) or
            risingOrFallingAlarm(3).
            
            After a falling event is generated, another such event
            will not be generated until the sampled value
            rises above this threshold and reaches the
            alarmRisingThreshold.
            
            This object may not be modified if the associated
            alarmStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.8";
        }

        leaf alarmRisingEventIndex {
          type int32 {
            range "0..65535";
          }
          description
           "The index of the eventEntry that is
            used when a rising threshold is crossed.  The
            eventEntry identified by a particular value of
            this index is the same as identified by the same value
            of the eventIndex object.  If there is no
            corresponding entry in the eventTable, then
            no association exists.  In particular, if this value
            is zero, no associated event will be generated, as
            zero is not a valid event index.
            
            This object may not be modified if the associated
            alarmStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.9";
        }

        leaf alarmFallingEventIndex {
          type int32 {
            range "0..65535";
          }
          description
           "The index of the eventEntry that is
            used when a falling threshold is crossed.  The
            eventEntry identified by a particular value of
            this index is the same as identified by the same value
            of the eventIndex object.  If there is no
            corresponding entry in the eventTable, then
            no association exists.  In particular, if this value
            is zero, no associated event will be generated, as
            zero is not a valid event index.
            
            This object may not be modified if the associated
            alarmStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.10";
        }

        leaf alarmOwner {
          type RMON-MIB:OwnerString;
          description
           "The entity that configured this entry and is therefore
            using the resources assigned to it.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.11";
        }

        leaf alarmStatus {
          type RMON-MIB:EntryStatus;
          description
           "The status of this alarm entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.3.1.1.12";
        }
      }
    }

    container hostControlTable {
      description
       "A list of host table control entries.";
      smiv2:oid "1.3.6.1.2.1.16.4.1";

      list hostControlEntry {
        key "hostControlIndex";
        description
         "A list of parameters that set up the discovery of hosts
          on a particular interface and the collection of statistics
          about these hosts.  For example, an instance of the
          hostControlTableSize object might be named
          hostControlTableSize.1";
        smiv2:oid "1.3.6.1.2.1.16.4.1.1";

        leaf hostControlIndex {
          type int32 {
            range "1..65535";
          }
          description
           "An index that uniquely identifies an entry in the
            hostControl table.  Each such entry defines
            a function that discovers hosts on a particular interface
            and places statistics about them in the hostTable and
            the hostTimeTable on behalf of this hostControlEntry.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.1.1.1";
        }

        leaf hostControlDataSource {
          type yang:object-identifier-128;
          description
           "This object identifies the source of the data for
            this instance of the host function.  This source
            can be any interface on this device.  In order
            to identify a particular interface, this object shall
            identify the instance of the ifIndex object, defined
            in RFC 2233 [17], for the desired interface.
            For example, if an entry were to receive data from
            interface #1, this object would be set to ifIndex.1.
            
            The statistics in this group reflect all packets
            on the local network segment attached to the identified
            interface.
            
            An agent may or may not be able to tell if fundamental
            changes to the media of the interface have occurred and
            necessitate an invalidation of this entry.  For example, a
            hot-pluggable ethernet card could be pulled out and replaced
            by a token-ring card.  In such a case, if the agent has such
            knowledge of the change, it is recommended that it
            invalidate this entry.
            
            This object may not be modified if the associated
            hostControlStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.4.1.1.2";
        }

        leaf hostControlTableSize {
          type int32;
          description
           "The number of hostEntries in the hostTable and the
            hostTimeTable associated with this hostControlEntry.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.1.1.3";
        }

        leaf hostControlLastDeleteTime {
          type yang:timeticks;
          description
           "The value of sysUpTime when the last entry
            was deleted from the portion of the hostTable
            associated with this hostControlEntry.  If no
            deletions have occurred, this value shall be zero.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.1.1.4";
        }

        leaf hostControlOwner {
          type RMON-MIB:OwnerString;
          description
           "The entity that configured this entry and is therefore
            using the resources assigned to it.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.4.1.1.5";
        }

        leaf hostControlStatus {
          type RMON-MIB:EntryStatus;
          description
           "The status of this hostControl entry.
            
            If this object is not equal to valid(1), all associated
            entries in the hostTable, hostTimeTable, and the
            hostTopNTable shall be deleted by the agent.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.4.1.1.6";
        }
      }
    }

    container hostTable {
      description
       "A list of host entries.";
      smiv2:oid "1.3.6.1.2.1.16.4.2";

      list hostEntry {
        key "hostIndex hostAddress";
        description
         "A collection of statistics for a particular host that has
          been discovered on an interface of this device.  For example,
          an instance of the hostOutBroadcastPkts object might be
          named hostOutBroadcastPkts.1.6.8.0.32.27.3.176";
        smiv2:oid "1.3.6.1.2.1.16.4.2.1";

        leaf hostAddress {
          type binary;
          description
           "The physical address of this host.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.2.1.1";
        }

        leaf hostCreationOrder {
          type int32 {
            range "1..65535";
          }
          description
           "An index that defines the relative ordering of
            the creation time of hosts captured for a
            particular hostControlEntry.  This index shall
            be between 1 and N, where N is the value of
            the associated hostControlTableSize.  The ordering
            of the indexes is based on the order of each entry's
            insertion into the table, in which entries added earlier
            have a lower index value than entries added later.
            
            It is important to note that the order for a
            particular entry may change as an (earlier) entry
            is deleted from the table.  Because this order may
            change, management stations should make use of the
            hostControlLastDeleteTime variable in the
            hostControlEntry associated with the relevant
            portion of the hostTable.  By observing
            this variable, the management station may detect
            the circumstances where a previous association
            between a value of hostCreationOrder
            and a hostEntry may no longer hold.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.2.1.2";
        }

        leaf hostIndex {
          type int32 {
            range "1..65535";
          }
          description
           "The set of collected host statistics of which
            this entry is a part.  The set of hosts
            identified by a particular value of this
            index is associated with the hostControlEntry
            as identified by the same value of hostControlIndex.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.2.1.3";
        }

        leaf hostInPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of good packets transmitted to this
            address since it was added to the hostTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.2.1.4";
        }

        leaf hostOutPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of packets, including bad packets, transmitted
            by this address since it was added to the hostTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.2.1.5";
        }

        leaf hostInOctets {
          type yang:counter32;
          units "Octets";
          description
           "The number of octets transmitted to this address since
            it was added to the hostTable (excluding framing
            bits but including FCS octets), except for those
            octets in bad packets.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.2.1.6";
        }

        leaf hostOutOctets {
          type yang:counter32;
          units "Octets";
          description
           "The number of octets transmitted by this address since
            it was added to the hostTable (excluding framing
            bits but including FCS octets), including those
            octets in bad packets.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.2.1.7";
        }

        leaf hostOutErrors {
          type yang:counter32;
          units "Packets";
          description
           "The number of bad packets transmitted by this address
            since this host was added to the hostTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.2.1.8";
        }

        leaf hostOutBroadcastPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of good packets transmitted by this
            address that were directed to the broadcast address
            since this host was added to the hostTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.2.1.9";
        }

        leaf hostOutMulticastPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of good packets transmitted by this
            address that were directed to a multicast address
            since this host was added to the hostTable.
            Note that this number does not include packets
            directed to the broadcast address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.2.1.10";
        }
      }
    }

    container hostTimeTable {
      description
       "A list of time-ordered host table entries.";
      smiv2:oid "1.3.6.1.2.1.16.4.3";

      list hostTimeEntry {
        key "hostTimeIndex hostTimeCreationOrder";
        description
         "A collection of statistics for a particular host that has
          been discovered on an interface of this device.  This
          collection includes the relative ordering of the creation
          time of this object.  For example, an instance of the
          hostTimeOutBroadcastPkts object might be named
          hostTimeOutBroadcastPkts.1.687";
        smiv2:oid "1.3.6.1.2.1.16.4.3.1";

        leaf hostTimeAddress {
          type binary;
          description
           "The physical address of this host.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.3.1.1";
        }

        leaf hostTimeCreationOrder {
          type int32 {
            range "1..65535";
          }
          description
           "An index that uniquely identifies an entry in
            the hostTime table among those entries associated
            with the same hostControlEntry.  This index shall
            be between 1 and N, where N is the value of
            the associated hostControlTableSize.  The ordering
            of the indexes is based on the order of each entry's
            insertion into the table, in which entries added earlier
            have a lower index value than entries added later.
            Thus the management station has the ability to
            learn of new entries added to this table without
            downloading the entire table.
            
            It is important to note that the index for a
            particular entry may change as an (earlier) entry
            is deleted from the table.  Because this order may
            change, management stations should make use of the
            hostControlLastDeleteTime variable in the
            hostControlEntry associated with the relevant
            portion of the hostTimeTable.  By observing
            this variable, the management station may detect
            the circumstances where a download of the table
            may have missed entries, and where a previous
            association between a value of hostTimeCreationOrder
            and a hostTimeEntry may no longer hold.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.3.1.2";
        }

        leaf hostTimeIndex {
          type int32 {
            range "1..65535";
          }
          description
           "The set of collected host statistics of which
            this entry is a part.  The set of hosts
            identified by a particular value of this
            index is associated with the hostControlEntry
            as identified by the same value of hostControlIndex.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.3.1.3";
        }

        leaf hostTimeInPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of good packets transmitted to this
            address since it was added to the hostTimeTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.3.1.4";
        }

        leaf hostTimeOutPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of packets, including bad packets, transmitted
            by this address since it was added to the hostTimeTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.3.1.5";
        }

        leaf hostTimeInOctets {
          type yang:counter32;
          units "Octets";
          description
           "The number of octets transmitted to this address since
            it was added to the hostTimeTable (excluding framing
            bits but including FCS octets), except for those
            octets in bad packets.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.3.1.6";
        }

        leaf hostTimeOutOctets {
          type yang:counter32;
          units "Octets";
          description
           "The number of octets transmitted by this address since
            it was added to the hostTimeTable (excluding framing
            bits but including FCS octets), including those
            octets in bad packets.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.3.1.7";
        }

        leaf hostTimeOutErrors {
          type yang:counter32;
          units "Packets";
          description
           "The number of bad packets transmitted by this address
            since this host was added to the hostTimeTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.3.1.8";
        }

        leaf hostTimeOutBroadcastPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of good packets transmitted by this
            address that were directed to the broadcast address
            since this host was added to the hostTimeTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.3.1.9";
        }

        leaf hostTimeOutMulticastPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of good packets transmitted by this
            address that were directed to a multicast address
            since this host was added to the hostTimeTable.
            Note that this number does not include packets directed
            to the broadcast address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.4.3.1.10";
        }
      }
    }

    container hostTopNControlTable {
      description
       "A list of top N host control entries.";
      smiv2:oid "1.3.6.1.2.1.16.5.1";

      list hostTopNControlEntry {
        key "hostTopNControlIndex";
        description
         "A set of parameters that control the creation of a report
          of the top N hosts according to several metrics.  For
          example, an instance of the hostTopNDuration object might
          be named hostTopNDuration.3";
        smiv2:oid "1.3.6.1.2.1.16.5.1.1";

        leaf hostTopNControlIndex {
          type int32 {
            range "1..65535";
          }
          description
           "An index that uniquely identifies an entry
            in the hostTopNControl table.  Each such
            entry defines one top N report prepared for
            one interface.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.5.1.1.1";
        }

        leaf hostTopNHostIndex {
          type int32 {
            range "1..65535";
          }
          description
           "The host table for which a top N report will be prepared
            on behalf of this entry.  The host table identified by a
            particular value of this index is associated with the same
            host table as identified by the same value of
            hostIndex.
            
            This object may not be modified if the associated
            hostTopNStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.5.1.1.2";
        }

        leaf hostTopNRateBase {
          type enumeration {
            enum "hostTopNInPkts" {
              value "1";
            }
            enum "hostTopNOutPkts" {
              value "2";
            }
            enum "hostTopNInOctets" {
              value "3";
            }
            enum "hostTopNOutOctets" {
              value "4";
            }
            enum "hostTopNOutErrors" {
              value "5";
            }
            enum "hostTopNOutBroadcastPkts" {
              value "6";
            }
            enum "hostTopNOutMulticastPkts" {
              value "7";
            }
          }
          description
           "The variable for each host that the hostTopNRate
            variable is based upon.
            
            This object may not be modified if the associated
            hostTopNStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.5.1.1.3";
        }

        leaf hostTopNTimeRemaining {
          type int32;
          units "Seconds";
          description
           "The number of seconds left in the report currently being
            collected.  When this object is modified by the management
            station, a new collection is started, possibly aborting
            a currently running report.  The new value is used
            as the requested duration of this report, which is
            loaded into the associated hostTopNDuration object.
            
            When this object is set to a non-zero value, any
            associated hostTopNEntries shall be made
            inaccessible by the monitor.  While the value of this
            object is non-zero, it decrements by one per second until
            it reaches zero.  During this time, all associated
            hostTopNEntries shall remain inaccessible.  At the time
            that this object decrements to zero, the report is made
            accessible in the hostTopNTable.  Thus, the hostTopN
            table needs to be created only at the end of the collection
            interval.";
          smiv2:defval "0";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.5.1.1.4";
        }

        leaf hostTopNDuration {
          type int32;
          units "Seconds";
          description
           "The number of seconds that this report has collected
            during the last sampling interval, or if this
            report is currently being collected, the number
            of seconds that this report is being collected
            during this sampling interval.
            
            When the associated hostTopNTimeRemaining object is set,
            this object shall be set by the probe to the same value
            and shall not be modified until the next time
            the hostTopNTimeRemaining is set.
            
            This value shall be zero if no reports have been
            requested for this hostTopNControlEntry.";
          smiv2:defval "0";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.5.1.1.5";
        }

        leaf hostTopNRequestedSize {
          type int32;
          description
           "The maximum number of hosts requested for the top N
            table.
            
            When this object is created or modified, the probe
            should set hostTopNGrantedSize as closely to this
            object as is possible for the particular probe
            implementation and available resources.";
          smiv2:defval "10";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.5.1.1.6";
        }

        leaf hostTopNGrantedSize {
          type int32;
          description
           "The maximum number of hosts in the top N table.
            
            When the associated hostTopNRequestedSize object is
            created or modified, the probe should set this
            object as closely to the requested value as is possible
            for the particular implementation and available
            resources. The probe must not lower this value except
            as a result of a set to the associated
            hostTopNRequestedSize object.
            
            Hosts with the highest value of hostTopNRate shall be
            placed in this table in decreasing order of this rate
            until there is no more room or until there are no more
            hosts.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.5.1.1.7";
        }

        leaf hostTopNStartTime {
          type yang:timeticks;
          description
           "The value of sysUpTime when this top N report was
            last started.  In other words, this is the time that
            the associated hostTopNTimeRemaining object was
            modified to start the requested report.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.5.1.1.8";
        }

        leaf hostTopNOwner {
          type RMON-MIB:OwnerString;
          description
           "The entity that configured this entry and is therefore
            using the resources assigned to it.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.5.1.1.9";
        }

        leaf hostTopNStatus {
          type RMON-MIB:EntryStatus;
          description
           "The status of this hostTopNControl entry.
            
            If this object is not equal to valid(1), all associated
            hostTopNEntries shall be deleted by the agent.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.5.1.1.10";
        }
      }
    }

    container hostTopNTable {
      description
       "A list of top N host entries.";
      smiv2:oid "1.3.6.1.2.1.16.5.2";

      list hostTopNEntry {
        key "hostTopNReport hostTopNIndex";
        description
         "A set of statistics for a host that is part of a top N
          report.  For example, an instance of the hostTopNRate
          object might be named hostTopNRate.3.10";
        smiv2:oid "1.3.6.1.2.1.16.5.2.1";

        leaf hostTopNReport {
          type int32 {
            range "1..65535";
          }
          description
           "This object identifies the top N report of which
            this entry is a part.  The set of hosts
            identified by a particular value of this
            object is part of the same report as identified
            by the same value of the hostTopNControlIndex object.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.5.2.1.1";
        }

        leaf hostTopNIndex {
          type int32 {
            range "1..65535";
          }
          description
           "An index that uniquely identifies an entry in
            the hostTopN table among those in the same report.
            This index is between 1 and N, where N is the
            number of entries in this table.  Increasing values
            of hostTopNIndex shall be assigned to entries with
            decreasing values of hostTopNRate until index N
            is assigned to the entry with the lowest value of
            hostTopNRate or there are no more hostTopNEntries.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.5.2.1.2";
        }

        leaf hostTopNAddress {
          type binary;
          description
           "The physical address of this host.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.5.2.1.3";
        }

        leaf hostTopNRate {
          type int32;
          description
           "The amount of change in the selected variable
            during this sampling interval.  The selected
            variable is this host's instance of the object
            selected by hostTopNRateBase.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.5.2.1.4";
        }
      }
    }

    container matrixControlTable {
      description
       "A list of information entries for the
        traffic matrix on each interface.";
      smiv2:oid "1.3.6.1.2.1.16.6.1";

      list matrixControlEntry {
        key "matrixControlIndex";
        description
         "Information about a traffic matrix on a particular
          interface.  For example, an instance of the
          matrixControlLastDeleteTime object might be named
          matrixControlLastDeleteTime.1";
        smiv2:oid "1.3.6.1.2.1.16.6.1.1";

        leaf matrixControlIndex {
          type int32 {
            range "1..65535";
          }
          description
           "An index that uniquely identifies an entry in the
            matrixControl table.  Each such entry defines
            a function that discovers conversations on a particular
            interface and places statistics about them in the
            matrixSDTable and the matrixDSTable on behalf of this
            matrixControlEntry.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.1.1.1";
        }

        leaf matrixControlDataSource {
          type yang:object-identifier-128;
          description
           "This object identifies the source of
            the data from which this entry creates a traffic matrix.
            This source can be any interface on this device.  In
            order to identify a particular interface, this object
            shall identify the instance of the ifIndex object,
            defined in RFC 2233 [17], for the desired
            interface.  For example, if an entry were to receive data
            from interface #1, this object would be set to ifIndex.1.
            
            The statistics in this group reflect all packets
            on the local network segment attached to the identified
            interface.
            
            An agent may or may not be able to tell if fundamental
            changes to the media of the interface have occurred and
            necessitate an invalidation of this entry.  For example, a
            hot-pluggable ethernet card could be pulled out and replaced
            by a token-ring card.  In such a case, if the agent has such
            knowledge of the change, it is recommended that it
            invalidate this entry.
            
            This object may not be modified if the associated
            matrixControlStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.6.1.1.2";
        }

        leaf matrixControlTableSize {
          type int32;
          description
           "The number of matrixSDEntries in the matrixSDTable
            for this interface.  This must also be the value of
            the number of entries in the matrixDSTable for this
            interface.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.1.1.3";
        }

        leaf matrixControlLastDeleteTime {
          type yang:timeticks;
          description
           "The value of sysUpTime when the last entry
            was deleted from the portion of the matrixSDTable
            or matrixDSTable associated with this matrixControlEntry.
            If no deletions have occurred, this value shall be
            zero.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.1.1.4";
        }

        leaf matrixControlOwner {
          type RMON-MIB:OwnerString;
          description
           "The entity that configured this entry and is therefore
            using the resources assigned to it.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.6.1.1.5";
        }

        leaf matrixControlStatus {
          type RMON-MIB:EntryStatus;
          description
           "The status of this matrixControl entry.
            If this object is not equal to valid(1), all associated
            entries in the matrixSDTable and the matrixDSTable
            shall be deleted by the agent.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.6.1.1.6";
        }
      }
    }

    container matrixSDTable {
      description
       "A list of traffic matrix entries indexed by
        source and destination MAC address.";
      smiv2:oid "1.3.6.1.2.1.16.6.2";

      list matrixSDEntry {
        key "matrixSDIndex matrixSDSourceAddress matrixSDDestAddress";
        description
         "A collection of statistics for communications between
          two addresses on a particular interface.  For example,
          an instance of the matrixSDPkts object might be named
          matrixSDPkts.1.6.8.0.32.27.3.176.6.8.0.32.10.8.113";
        smiv2:oid "1.3.6.1.2.1.16.6.2.1";

        leaf matrixSDSourceAddress {
          type binary;
          description
           "The source physical address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.2.1.1";
        }

        leaf matrixSDDestAddress {
          type binary;
          description
           "The destination physical address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.2.1.2";
        }

        leaf matrixSDIndex {
          type int32 {
            range "1..65535";
          }
          description
           "The set of collected matrix statistics of which
            this entry is a part.  The set of matrix statistics
            identified by a particular value of this index
            is associated with the same matrixControlEntry
            as identified by the same value of matrixControlIndex.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.2.1.3";
        }

        leaf matrixSDPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of packets transmitted from the source
            address to the destination address (this number includes
            bad packets).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.2.1.4";
        }

        leaf matrixSDOctets {
          type yang:counter32;
          units "Octets";
          description
           "The number of octets (excluding framing bits but
            including FCS octets) contained in all packets
            transmitted from the source address to the
            destination address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.2.1.5";
        }

        leaf matrixSDErrors {
          type yang:counter32;
          units "Packets";
          description
           "The number of bad packets transmitted from
            the source address to the destination address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.2.1.6";
        }
      }
    }

    container matrixDSTable {
      description
       "A list of traffic matrix entries indexed by
        destination and source MAC address.";
      smiv2:oid "1.3.6.1.2.1.16.6.3";

      list matrixDSEntry {
        key "matrixDSIndex matrixDSDestAddress matrixDSSourceAddress";
        description
         "A collection of statistics for communications between
          two addresses on a particular interface.  For example,
          an instance of the matrixSDPkts object might be named
          matrixSDPkts.1.6.8.0.32.10.8.113.6.8.0.32.27.3.176";
        smiv2:oid "1.3.6.1.2.1.16.6.3.1";

        leaf matrixDSSourceAddress {
          type binary;
          description
           "The source physical address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.3.1.1";
        }

        leaf matrixDSDestAddress {
          type binary;
          description
           "The destination physical address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.3.1.2";
        }

        leaf matrixDSIndex {
          type int32 {
            range "1..65535";
          }
          description
           "The set of collected matrix statistics of which
            this entry is a part.  The set of matrix statistics
            identified by a particular value of this index
            is associated with the same matrixControlEntry
            as identified by the same value of matrixControlIndex.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.3.1.3";
        }

        leaf matrixDSPkts {
          type yang:counter32;
          units "Packets";
          description
           "The number of packets transmitted from the source
            address to the destination address (this number includes
            bad packets).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.3.1.4";
        }

        leaf matrixDSOctets {
          type yang:counter32;
          units "Octets";
          description
           "The number of octets (excluding framing bits
            but including FCS octets) contained in all packets
            transmitted from the source address to the
            destination address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.3.1.5";
        }

        leaf matrixDSErrors {
          type yang:counter32;
          units "Packets";
          description
           "The number of bad packets transmitted from
            the source address to the destination address.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.6.3.1.6";
        }
      }
    }

    container filterTable {
      description
       "A list of packet filter entries.";
      smiv2:oid "1.3.6.1.2.1.16.7.1";

      list filterEntry {
        key "filterIndex";
        description
         "A set of parameters for a packet filter applied on a
          particular interface.  As an example, an instance of the
          filterPktData object might be named filterPktData.12";
        smiv2:oid "1.3.6.1.2.1.16.7.1.1";

        leaf filterIndex {
          type int32 {
            range "1..65535";
          }
          description
           "An index that uniquely identifies an entry
            in the filter table.  Each such entry defines
            one filter that is to be applied to every packet
            received on an interface.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.7.1.1.1";
        }

        leaf filterChannelIndex {
          type int32 {
            range "1..65535";
          }
          description
           "This object identifies the channel of which this filter
            is a part.  The filters identified by a particular value
            of this object are associated with the same channel as
            identified by the same value of the channelIndex object.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.1.1.2";
        }

        leaf filterPktDataOffset {
          type int32;
          units "Octets";
          description
           "The offset from the beginning of each packet where
            a match of packet data will be attempted.  This offset
            is measured from the point in the physical layer
            packet after the framing bits, if any.  For example,
            in an Ethernet frame, this point is at the beginning of
            the destination MAC address.
            
            This object may not be modified if the associated
            filterStatus object is equal to valid(1).";
          smiv2:defval "0";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.1.1.3";
        }

        leaf filterPktData {
          type binary;
          description
           "The data that is to be matched with the input packet.
            For each packet received, this filter and the accompanying
            filterPktDataMask and filterPktDataNotMask will be
            adjusted for the offset.  The only bits relevant to this
            match algorithm are those that have the corresponding
            filterPktDataMask bit equal to one.  The following three
            rules are then applied to every packet:
            
            (1) If the packet is too short and does not have data
                corresponding to part of the filterPktData, the packet
                will fail this data match.
            
            (2) For each relevant bit from the packet with the
                corresponding filterPktDataNotMask bit set to zero, if
                the bit from the packet is not equal to the corresponding
                bit from the filterPktData, then the packet will fail
                this data match.
            
            (3) If for every relevant bit from the packet with the
                corresponding filterPktDataNotMask bit set to one, the
                bit from the packet is equal to the corresponding bit
                from the filterPktData, then the packet will fail this
                data match.
            
            Any packets that have not failed any of the three matches
            above have passed this data match.  In particular, a zero
            length filter will match any packet.
            
            This object may not be modified if the associated
            filterStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.1.1.4";
        }

        leaf filterPktDataMask {
          type binary;
          description
           "The mask that is applied to the match process.
            After adjusting this mask for the offset, only those
            bits in the received packet that correspond to bits set
            in this mask are relevant for further processing by the
            match algorithm.  The offset is applied to filterPktDataMask
            in the same way it is applied to the filter.  For the
            purposes of the matching algorithm, if the associated
            filterPktData object is longer than this mask, this mask is
            conceptually extended with '1' bits until it reaches the
            length of the filterPktData object.
            
            This object may not be modified if the associated
            filterStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.1.1.5";
        }

        leaf filterPktDataNotMask {
          type binary;
          description
           "The inversion mask that is applied to the match
            process.  After adjusting this mask for the offset,
            those relevant bits in the received packet that correspond
            to bits cleared in this mask must all be equal to their
            corresponding bits in the filterPktData object for the packet
            to be accepted.  In addition, at least one of those relevant
            bits in the received packet that correspond to bits set in
            this mask must be different to its corresponding bit in the
            filterPktData object.
            
            For the purposes of the matching algorithm, if the associated
            filterPktData object is longer than this mask, this mask is
            conceptually extended with '0' bits until it reaches the
            length of the filterPktData object.
            
            This object may not be modified if the associated
            filterStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.1.1.6";
        }

        leaf filterPktStatus {
          type int32;
          description
           "The status that is to be matched with the input packet.
            The only bits relevant to this match algorithm are those that
            have the corresponding filterPktStatusMask bit equal to one.
            The following two rules are then applied to every packet:
            
            (1) For each relevant bit from the packet status with the
                corresponding filterPktStatusNotMask bit set to zero, if
                the bit from the packet status is not equal to the
                corresponding bit from the filterPktStatus, then the
                packet will fail this status match.
            
            (2) If for every relevant bit from the packet status with the
                corresponding filterPktStatusNotMask bit set to one, the
                bit from the packet status is equal to the corresponding
                bit from the filterPktStatus, then the packet will fail
                this status match.
            
            Any packets that have not failed either of the two matches
            above have passed this status match.  In particular, a zero
            length status filter will match any packet's status.
            
            The value of the packet status is a sum.  This sum
            initially takes the value zero.  Then, for each
            error, E, that has been discovered in this packet,
            2 raised to a value representing E is added to the sum.
            The errors and the bits that represent them are dependent
            on the media type of the interface that this channel
            is receiving packets from.
            
            The errors defined for a packet captured off of an
            Ethernet interface are as follows:
            
                bit #    Error
                    0    Packet is longer than 1518 octets
                    1    Packet is shorter than 64 octets
                    2    Packet experienced a CRC or Alignment error
            
            For example, an Ethernet fragment would have a
            value of 6 (2^1 + 2^2).
            
            As this MIB is expanded to new media types, this object
            will have other media-specific errors defined.
            
            For the purposes of this status matching algorithm, if the
            packet status is longer than this filterPktStatus object,
            this object is conceptually extended with '0' bits until it
            reaches the size of the packet status.
            
            This object may not be modified if the associated
            filterStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.1.1.7";
        }

        leaf filterPktStatusMask {
          type int32;
          description
           "The mask that is applied to the status match process.
            Only those bits in the received packet that correspond to
            bits set in this mask are relevant for further processing
            by the status match algorithm.  For the purposes
            of the matching algorithm, if the associated filterPktStatus
            object is longer than this mask, this mask is conceptually
            extended with '1' bits until it reaches the size of the
            filterPktStatus.  In addition, if a packet status is longer
            than this mask, this mask is conceptually extended with '0'
            bits until it reaches the size of the packet status.
            
            This object may not be modified if the associated
            filterStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.1.1.8";
        }

        leaf filterPktStatusNotMask {
          type int32;
          description
           "The inversion mask that is applied to the status match
            process.  Those relevant bits in the received packet status
            that correspond to bits cleared in this mask must all be
            equal to their corresponding bits in the filterPktStatus
            object for the packet to be accepted.  In addition, at least
            one of those relevant bits in the received packet status
            that correspond to bits set in this mask must be different
            to its corresponding bit in the filterPktStatus object for
            the packet to be accepted.
            
            For the purposes of the matching algorithm, if the associated
            filterPktStatus object or a packet status is longer than this
            mask, this mask is conceptually extended with '0' bits until
            it reaches the longer of the lengths of the filterPktStatus
            object and the packet status.
            
            This object may not be modified if the associated
            filterStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.1.1.9";
        }

        leaf filterOwner {
          type RMON-MIB:OwnerString;
          description
           "The entity that configured this entry and is therefore
            using the resources assigned to it.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.1.1.10";
        }

        leaf filterStatus {
          type RMON-MIB:EntryStatus;
          description
           "The status of this filter entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.1.1.11";
        }
      }
    }

    container channelTable {
      description
       "A list of packet channel entries.";
      smiv2:oid "1.3.6.1.2.1.16.7.2";

      list channelEntry {
        key "channelIndex";
        description
         "A set of parameters for a packet channel applied on a
          particular interface.  As an example, an instance of the
          channelMatches object might be named channelMatches.3";
        smiv2:oid "1.3.6.1.2.1.16.7.2.1";

        leaf channelIndex {
          type int32 {
            range "1..65535";
          }
          description
           "An index that uniquely identifies an entry in the channel
            table.  Each such entry defines one channel, a logical
            data and event stream.
            
            It is suggested that before creating a channel, an
            application should scan all instances of the
            filterChannelIndex object to make sure that there are no
            pre-existing filters that would be inadvertently be linked
            to the channel.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.1";
        }

        leaf channelIfIndex {
          type int32 {
            range "1..65535";
          }
          description
           "The value of this object uniquely identifies the
            interface on this remote network monitoring device to which
            the associated filters are applied to allow data into this
            channel.  The interface identified by a particular value
            of this object is the same interface as identified by the
            same value of the ifIndex object, defined in RFC 2233 [17].
            
            The filters in this group are applied to all packets on
            the local network segment attached to the identified
            interface.
            
            An agent may or may not be able to tell if fundamental
            changes to the media of the interface have occurred and
            necessitate an invalidation of this entry.  For example, a
            hot-pluggable ethernet card could be pulled out and replaced
            by a token-ring card.  In such a case, if the agent has such
            knowledge of the change, it is recommended that it
            invalidate this entry.
            
            This object may not be modified if the associated
            channelStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.2";
        }

        leaf channelAcceptType {
          type enumeration {
            enum "acceptMatched" {
              value "1";
            }
            enum "acceptFailed" {
              value "2";
            }
          }
          description
           "This object controls the action of the filters
            associated with this channel.  If this object is equal
            to acceptMatched(1), packets will be accepted to this
            channel if they are accepted by both the packet data and
            packet status matches of an associated filter.  If
            this object is equal to acceptFailed(2), packets will
            be accepted to this channel only if they fail either
            the packet data match or the packet status match of
            each of the associated filters.
            
            In particular, a channel with no associated filters will
            match no packets if set to acceptMatched(1) case and will
            match all packets in the acceptFailed(2) case.
            
            This object may not be modified if the associated
            channelStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.3";
        }

        leaf channelDataControl {
          type enumeration {
            enum "on" {
              value "1";
            }
            enum "off" {
              value "2";
            }
          }
          description
           "This object controls the flow of data through this channel.
            If this object is on(1), data, status and events flow
            through this channel.  If this object is off(2), data,
            status and events will not flow through this channel.";
          smiv2:defval "off";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.4";
        }

        leaf channelTurnOnEventIndex {
          type int32 {
            range "0..65535";
          }
          description
           "The value of this object identifies the event
            that is configured to turn the associated
            channelDataControl from off to on when the event is
            generated.  The event identified by a particular value
            of this object is the same event as identified by the
            same value of the eventIndex object.  If there is no
            corresponding entry in the eventTable, then no
            association exists.  In fact, if no event is intended
            for this channel, channelTurnOnEventIndex must be
            set to zero, a non-existent event index.
            This object may not be modified if the associated
            channelStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.5";
        }

        leaf channelTurnOffEventIndex {
          type int32 {
            range "0..65535";
          }
          description
           "The value of this object identifies the event
            that is configured to turn the associated
            channelDataControl from on to off when the event is
            generated.  The event identified by a particular value
            of this object is the same event as identified by the
            same value of the eventIndex object.  If there is no
            corresponding entry in the eventTable, then no
            association exists.  In fact, if no event is intended
            for this channel, channelTurnOffEventIndex must be
            set to zero, a non-existent event index.
            
            This object may not be modified if the associated
            channelStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.6";
        }

        leaf channelEventIndex {
          type int32 {
            range "0..65535";
          }
          description
           "The value of this object identifies the event
            that is configured to be generated when the
            associated channelDataControl is on and a packet
            is matched.  The event identified by a particular value
            of this object is the same event as identified by the
            same value of the eventIndex object.  If there is no
            corresponding entry in the eventTable, then no
            association exists.  In fact, if no event is intended
            for this channel, channelEventIndex must be
            set to zero, a non-existent event index.
            
            This object may not be modified if the associated
            channelStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.7";
        }

        leaf channelEventStatus {
          type enumeration {
            enum "eventReady" {
              value "1";
            }
            enum "eventFired" {
              value "2";
            }
            enum "eventAlwaysReady" {
              value "3";
            }
          }
          description
           "The event status of this channel.
            
            If this channel is configured to generate events
            when packets are matched, a means of controlling
            the flow of those events is often needed.  When
            this object is equal to eventReady(1), a single
            event may be generated, after which this object
            will be set by the probe to eventFired(2).  While
            in the eventFired(2) state, no events will be
            generated until the object is modified to
            eventReady(1) (or eventAlwaysReady(3)).  The
            management station can thus easily respond to a
            notification of an event by re-enabling this object.
            
            If the management station wishes to disable this
            flow control and allow events to be generated
            at will, this object may be set to
            eventAlwaysReady(3).  Disabling the flow control
            is discouraged as it can result in high network
            traffic or other performance problems.";
          smiv2:defval "eventReady";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.8";
        }

        leaf channelMatches {
          type yang:counter32;
          units "Packets";
          description
           "The number of times this channel has matched a packet.
            Note that this object is updated even when
            channelDataControl is set to off.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.9";
        }

        leaf channelDescription {
          type snmpv2-tc:DisplayString {
            length "0..127";
          }
          description
           "A comment describing this channel.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.10";
        }

        leaf channelOwner {
          type RMON-MIB:OwnerString;
          description
           "The entity that configured this entry and is therefore
            using the resources assigned to it.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.11";
        }

        leaf channelStatus {
          type RMON-MIB:EntryStatus;
          description
           "The status of this channel entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.7.2.1.12";
        }
      }
    }

    container bufferControlTable {
      description
       "A list of buffers control entries.";
      smiv2:oid "1.3.6.1.2.1.16.8.1";

      list bufferControlEntry {
        key "bufferControlIndex";
        description
         "A set of parameters that control the collection of a stream
          of packets that have matched filters.  As an example, an
          instance of the bufferControlCaptureSliceSize object might
          be named bufferControlCaptureSliceSize.3";
        smiv2:oid "1.3.6.1.2.1.16.8.1.1";

        leaf bufferControlIndex {
          type int32 {
            range "1..65535";
          }
          description
           "An index that uniquely identifies an entry
            in the bufferControl table.  The value of this
            index shall never be zero.  Each such
            entry defines one set of packets that is
            captured and controlled by one or more filters.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.1";
        }

        leaf bufferControlChannelIndex {
          type int32 {
            range "1..65535";
          }
          description
           "An index that identifies the channel that is the
            source of packets for this bufferControl table.
            The channel identified by a particular value of this
            index is the same as identified by the same value of
            the channelIndex object.
            
            This object may not be modified if the associated
            bufferControlStatus object is equal to valid(1).";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.2";
        }

        leaf bufferControlFullStatus {
          type enumeration {
            enum "spaceAvailable" {
              value "1";
            }
            enum "full" {
              value "2";
            }
          }
          description
           "This object shows whether the buffer has room to
            accept new packets or if it is full.
            
            If the status is spaceAvailable(1), the buffer is
            accepting new packets normally.  If the status is
            full(2) and the associated bufferControlFullAction
            object is wrapWhenFull, the buffer is accepting new
            packets by deleting enough of the oldest packets
            to make room for new ones as they arrive.  Otherwise,
            if the status is full(2) and the
            bufferControlFullAction object is lockWhenFull,
            then the buffer has stopped collecting packets.
            
            When this object is set to full(2) the probe must
            not later set it to spaceAvailable(1) except in the
            case of a significant gain in resources such as
            an increase of bufferControlOctetsGranted.  In
            particular, the wrap-mode action of deleting old
            packets to make room for newly arrived packets
            must not affect the value of this object.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.3";
        }

        leaf bufferControlFullAction {
          type enumeration {
            enum "lockWhenFull" {
              value "1";
            }
            enum "wrapWhenFull" {
              value "2";
            }
          }
          description
           "Controls the action of the buffer when it
            reaches the full status.  When in the lockWhenFull(1)
            state and a packet is added to the buffer that
            fills the buffer, the bufferControlFullStatus will
            be set to full(2) and this buffer will stop capturing
            packets.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.4";
        }

        leaf bufferControlCaptureSliceSize {
          type int32;
          units "Octets";
          description
           "The maximum number of octets of each packet
            that will be saved in this capture buffer.
            For example, if a 1500 octet packet is received by
            the probe and this object is set to 500, then only
            500 octets of the packet will be stored in the
            associated capture buffer.  If this variable is set
            to 0, the capture buffer will save as many octets
            as is possible.
            
            This object may not be modified if the associated
            bufferControlStatus object is equal to valid(1).";
          smiv2:defval "100";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.5";
        }

        leaf bufferControlDownloadSliceSize {
          type int32;
          units "Octets";
          description
           "The maximum number of octets of each packet
            in this capture buffer that will be returned in
            an SNMP retrieval of that packet.  For example,
            if 500 octets of a packet have been stored in the
            associated capture buffer, the associated
            bufferControlDownloadOffset is 0, and this
            object is set to 100, then the captureBufferPacket
            object that contains the packet will contain only
            the first 100 octets of the packet.
            
            A prudent manager will take into account possible
            interoperability or fragmentation problems that may
            occur if the download slice size is set too large.
            In particular, conformant SNMP implementations are not
            required to accept messages whose length exceeds 484
            octets, although they are encouraged to support larger
            datagrams whenever feasible.";
          smiv2:defval "100";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.6";
        }

        leaf bufferControlDownloadOffset {
          type int32;
          units "Octets";
          description
           "The offset of the first octet of each packet
            in this capture buffer that will be returned in
            an SNMP retrieval of that packet.  For example,
            if 500 octets of a packet have been stored in the
            associated capture buffer and this object is set to
            100, then the captureBufferPacket object that
            contains the packet will contain bytes starting
            100 octets into the packet.";
          smiv2:defval "0";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.7";
        }

        leaf bufferControlMaxOctetsRequested {
          type int32;
          units "Octets";
          description
           "The requested maximum number of octets to be
            saved in this captureBuffer, including any
            implementation-specific overhead. If this variable
            is set to -1, the capture buffer will save as many
            octets as is possible.
            
            When this object is created or modified, the probe
            should set bufferControlMaxOctetsGranted as closely
            to this object as is possible for the particular probe
            implementation and available resources.  However, if
            the object has the special value of -1, the probe
            must set bufferControlMaxOctetsGranted to -1.";
          smiv2:defval "-1";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.8";
        }

        leaf bufferControlMaxOctetsGranted {
          type int32;
          units "Octets";
          description
           "The maximum number of octets that can be
            saved in this captureBuffer, including overhead.
            If this variable is -1, the capture buffer will save
            as many octets as possible.
            
            When the bufferControlMaxOctetsRequested object is
            created or modified, the probe should set this object
            as closely to the requested value as is possible for the
            particular probe implementation and available resources.
            However, if the request object has the special value
            of -1, the probe must set this object to -1.
            
            The probe must not lower this value except as a result of
            a modification to the associated
            bufferControlMaxOctetsRequested object.
            
            When this maximum number of octets is reached
            and a new packet is to be added to this
            capture buffer and the corresponding
            bufferControlFullAction is set to wrapWhenFull(2),
            enough of the oldest packets associated with this
            capture buffer shall be deleted by the agent so
            that the new packet can be added.  If the corresponding
            bufferControlFullAction is set to lockWhenFull(1),
            the new packet shall be discarded.  In either case,
            the probe must set bufferControlFullStatus to
            full(2).
            
            When the value of this object changes to a value less
            than the current value, entries are deleted from
            the captureBufferTable associated with this
            bufferControlEntry.  Enough of the
            oldest of these captureBufferEntries shall be
            deleted by the agent so that the number of octets
            used remains less than or equal to the new value of
            this object.
            
            When the value of this object changes to a value greater
            than the current value, the number of associated
            captureBufferEntries may be allowed to grow.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.9";
        }

        leaf bufferControlCapturedPackets {
          type int32;
          units "Packets";
          description
           "The number of packets currently in this captureBuffer.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.10";
        }

        leaf bufferControlTurnOnTime {
          type yang:timeticks;
          description
           "The value of sysUpTime when this capture buffer was
            first turned on.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.11";
        }

        leaf bufferControlOwner {
          type RMON-MIB:OwnerString;
          description
           "The entity that configured this entry and is therefore
            using the resources assigned to it.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.12";
        }

        leaf bufferControlStatus {
          type RMON-MIB:EntryStatus;
          description
           "The status of this buffer Control Entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.8.1.1.13";
        }
      }
    }

    container captureBufferTable {
      description
       "A list of packets captured off of a channel.";
      smiv2:oid "1.3.6.1.2.1.16.8.2";

      list captureBufferEntry {
        key "captureBufferControlIndex captureBufferIndex";
        description
         "A packet captured off of an attached network.  As an
          example, an instance of the captureBufferPacketData
          object might be named captureBufferPacketData.3.1783";
        smiv2:oid "1.3.6.1.2.1.16.8.2.1";

        leaf captureBufferControlIndex {
          type int32 {
            range "1..65535";
          }
          description
           "The index of the bufferControlEntry with which
            this packet is associated.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.2.1.1";
        }

        leaf captureBufferIndex {
          type int32 {
            range "1..2147483647";
          }
          description
           "An index that uniquely identifies an entry
            in the captureBuffer table associated with a
            particular bufferControlEntry.  This index will
            start at 1 and increase by one for each new packet
            added with the same captureBufferControlIndex.
            
            Should this value reach 2147483647, the next packet
            added with the same captureBufferControlIndex shall
            cause this value to wrap around to 1.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.2.1.2";
        }

        leaf captureBufferPacketID {
          type int32;
          description
           "An index that describes the order of packets
            that are received on a particular interface.
            The packetID of a packet captured on an
            interface is defined to be greater than the
            packetID's of all packets captured previously on
            the same interface.  As the captureBufferPacketID
            object has a maximum positive value of 2^31 - 1,
            any captureBufferPacketID object shall have the
            value of the associated packet's packetID mod 2^31.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.2.1.3";
        }

        leaf captureBufferPacketData {
          type binary;
          description
           "The data inside the packet, starting at the beginning
            of the packet plus any offset specified in the
            associated bufferControlDownloadOffset, including any
            link level headers.  The length of the data in this object
            is the minimum of the length of the captured packet minus
            the offset, the length of the associated
            bufferControlCaptureSliceSize minus the offset, and the
            associated bufferControlDownloadSliceSize.  If this minimum
            is less than zero, this object shall have a length of zero.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.2.1.4";
        }

        leaf captureBufferPacketLength {
          type int32;
          units "Octets";
          description
           "The actual length (off the wire) of the packet stored
            in this entry, including FCS octets.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.2.1.5";
        }

        leaf captureBufferPacketTime {
          type int32;
          units "Milliseconds";
          description
           "The number of milliseconds that had passed since
            this capture buffer was first turned on when this
            packet was captured.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.2.1.6";
        }

        leaf captureBufferPacketStatus {
          type int32;
          description
           "A value which indicates the error status of this packet.
            
            The value of this object is defined in the same way as
            filterPktStatus.  The value is a sum.  This sum
            initially takes the value zero.  Then, for each
            error, E, that has been discovered in this packet,
            2 raised to a value representing E is added to the sum.
            
            The errors defined for a packet captured off of an
            Ethernet interface are as follows:
            
                bit #    Error
                    0    Packet is longer than 1518 octets
                    1    Packet is shorter than 64 octets
                    2    Packet experienced a CRC or Alignment error
                    3    First packet in this capture buffer after
                         it was detected that some packets were
                         not processed correctly.
                    4    Packet's order in buffer is only approximate
                         (May only be set for packets sent from
                         the probe)
            
            For example, an Ethernet fragment would have a
            value of 6 (2^1 + 2^2).
            
            As this MIB is expanded to new media types, this object
            will have other media-specific errors defined.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.8.2.1.7";
        }
      }
    }

    container eventTable {
      description
       "A list of events to be generated.";
      smiv2:oid "1.3.6.1.2.1.16.9.1";

      list eventEntry {
        key "eventIndex";
        description
         "A set of parameters that describe an event to be generated
          when certain conditions are met.  As an example, an instance
          of the eventLastTimeSent object might be named
          eventLastTimeSent.6";
        smiv2:oid "1.3.6.1.2.1.16.9.1.1";

        leaf eventIndex {
          type int32 {
            range "1..65535";
          }
          description
           "An index that uniquely identifies an entry in the
            event table.  Each such entry defines one event that
            is to be generated when the appropriate conditions
            occur.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.9.1.1.1";
        }

        leaf eventDescription {
          type snmpv2-tc:DisplayString {
            length "0..127";
          }
          description
           "A comment describing this event entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.9.1.1.2";
        }

        leaf eventType {
          type enumeration {
            enum "none" {
              value "1";
            }
            enum "log" {
              value "2";
            }
            enum "snmptrap" {
              value "3";
            }
            enum "logandtrap" {
              value "4";
            }
          }
          description
           "The type of notification that the probe will make
            about this event.  In the case of log, an entry is
            made in the log table for each event.  In the case of
            snmp-trap, an SNMP trap is sent to one or more
            management stations.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.9.1.1.3";
        }

        leaf eventCommunity {
          type binary {
            length "0..127";
          }
          description
           "If an SNMP trap is to be sent, it will be sent to
            the SNMP community specified by this octet string.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.9.1.1.4";
        }

        leaf eventLastTimeSent {
          type yang:timeticks;
          description
           "The value of sysUpTime at the time this event
            entry last generated an event.  If this entry has
            not generated any events, this value will be
            zero.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.9.1.1.5";
        }

        leaf eventOwner {
          type RMON-MIB:OwnerString;
          description
           "The entity that configured this entry and is therefore
            using the resources assigned to it.
            
            If this object contains a string starting with 'monitor'
            and has associated entries in the log table, all connected
            management stations should retrieve those log entries,
            as they may have significance to all management stations
            connected to this device";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.9.1.1.6";
        }

        leaf eventStatus {
          type RMON-MIB:EntryStatus;
          description
           "The status of this event entry.
            
            If this object is not equal to valid(1), all associated
            log entries shall be deleted by the agent.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.2.1.16.9.1.1.7";
        }
      }
    }

    container logTable {
      description
       "A list of events that have been logged.";
      smiv2:oid "1.3.6.1.2.1.16.9.2";

      list logEntry {
        key "logEventIndex logIndex";
        description
         "A set of data describing an event that has been
          logged.  For example, an instance of the logDescription
          object might be named logDescription.6.47";
        smiv2:oid "1.3.6.1.2.1.16.9.2.1";

        leaf logEventIndex {
          type int32 {
            range "1..65535";
          }
          description
           "The event entry that generated this log
            entry.  The log identified by a particular
            value of this index is associated with the same
            eventEntry as identified by the same value
            of eventIndex.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.9.2.1.1";
        }

        leaf logIndex {
          type int32 {
            range "1..2147483647";
          }
          description
           "An index that uniquely identifies an entry
            in the log table amongst those generated by the
            same eventEntries.  These indexes are
            assigned beginning with 1 and increase by one
            with each new log entry.  The association
            between values of logIndex and logEntries
            is fixed for the lifetime of each logEntry.
            The agent may choose to delete the oldest
            instances of logEntry as required because of
            lack of memory.  It is an implementation-specific
            matter as to when this deletion may occur.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.9.2.1.2";
        }

        leaf logTime {
          type yang:timeticks;
          description
           "The value of sysUpTime when this log entry was created.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.9.2.1.3";
        }

        leaf logDescription {
          type snmpv2-tc:DisplayString {
            length "0..255";
          }
          description
           "An implementation dependent description of the
            event that activated this log entry.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.2.1.16.9.2.1.4";
        }
      }
    }
  }

  notification risingAlarm {
    description
     "The SNMP trap that is generated when an alarm
      entry crosses its rising threshold and generates
      an event that is configured for sending SNMP
      traps.";
    smiv2:oid "1.3.6.1.2.1.16.0.1";

    container object-1 {

      leaf alarmIndex {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmIndex";
        }
      }
    }

    container object-2 {

      leaf alarmIndex {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmIndex";
        }
      }

      leaf alarmVariable {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmVariable";
        }
      }
    }

    container object-3 {

      leaf alarmIndex {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmIndex";
        }
      }

      leaf alarmSampleType {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmSampleType";
        }
      }
    }

    container object-4 {

      leaf alarmIndex {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmIndex";
        }
      }

      leaf alarmValue {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmValue";
        }
      }
    }

    container object-5 {

      leaf alarmIndex {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmIndex";
        }
      }

      leaf alarmRisingThreshold {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmRisingThreshold";
        }
      }
    }
  }

  notification fallingAlarm {
    description
     "The SNMP trap that is generated when an alarm
      entry crosses its falling threshold and generates
      an event that is configured for sending SNMP
      traps.";
    smiv2:oid "1.3.6.1.2.1.16.0.2";

    container object-1 {

      leaf alarmIndex {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmIndex";
        }
      }
    }

    container object-2 {

      leaf alarmIndex {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmIndex";
        }
      }

      leaf alarmVariable {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmVariable";
        }
      }
    }

    container object-3 {

      leaf alarmIndex {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmIndex";
        }
      }

      leaf alarmSampleType {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmSampleType";
        }
      }
    }

    container object-4 {

      leaf alarmIndex {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmIndex";
        }
      }

      leaf alarmValue {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmValue";
        }
      }
    }

    container object-5 {

      leaf alarmIndex {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmIndex";
        }
      }

      leaf alarmFallingThreshold {
        type leafref {
          path "/RMON-MIB:RMON-MIB/RMON-MIB:alarmTable/RMON-MIB:alarmEntry/RMON-MIB:alarmFallingThreshold";
        }
      }
    }
  }

  smiv2:alias "rmon" {
    smiv2:oid "1.3.6.1.2.1.16";
  }

  smiv2:alias "rmonEventsV2" {
    description
     "Definition point for RMON notifications.";
    smiv2:oid "1.3.6.1.2.1.16.0";
  }

  smiv2:alias "statistics" {
    smiv2:oid "1.3.6.1.2.1.16.1";
  }

  smiv2:alias "history" {
    smiv2:oid "1.3.6.1.2.1.16.2";
  }

  smiv2:alias "alarm" {
    smiv2:oid "1.3.6.1.2.1.16.3";
  }

  smiv2:alias "hosts" {
    smiv2:oid "1.3.6.1.2.1.16.4";
  }

  smiv2:alias "hostTopN" {
    smiv2:oid "1.3.6.1.2.1.16.5";
  }

  smiv2:alias "matrix" {
    smiv2:oid "1.3.6.1.2.1.16.6";
  }

  smiv2:alias "filter" {
    smiv2:oid "1.3.6.1.2.1.16.7";
  }

  smiv2:alias "capture" {
    smiv2:oid "1.3.6.1.2.1.16.8";
  }

  smiv2:alias "event" {
    smiv2:oid "1.3.6.1.2.1.16.9";
  }

  smiv2:alias "rmonConformance" {
    smiv2:oid "1.3.6.1.2.1.16.20";
  }

  smiv2:alias "rmonMibModule" {
    smiv2:oid "1.3.6.1.2.1.16.20.8";
  }

  smiv2:alias "rmonCompliances" {
    smiv2:oid "1.3.6.1.2.1.16.20.9";
  }

  smiv2:alias "rmonGroups" {
    smiv2:oid "1.3.6.1.2.1.16.20.10";
  }

}
