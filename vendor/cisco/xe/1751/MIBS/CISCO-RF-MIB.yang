/*
 * Generated by confdc --mib2yang-std
 * Source: mgmt/dmi/model/mib/src/CISCO-RF-MIB.mib
 */
/*
 * This YANG module has been generated by smidump 0.5.0:
 *
 *      smidump -f yang CISCO-RF-MIB
 *
 * Do not edit. Edit the source file instead!
 */

module CISCO-RF-MIB {

  namespace "urn:ietf:params:xml:ns:yang:smiv2:CISCO-RF-MIB";
  prefix CISCO-RF-MIB;

  import SNMP-FRAMEWORK-MIB {
    prefix "snmp-framework";
  }

  import SNMPv2-MIB {
    prefix "snmpv2-mib";
  }

  import SNMPv2-TC {
    prefix "snmpv2-tc";
  }

  import ietf-yang-smiv2 {
    prefix "smiv2";
  }

  import ietf-yang-types {
    prefix "yang";
  }

  organization
   "Cisco Systems, Inc.";

  contact
   "Cisco Systems Customer Service
    Postal: 170 West Tasman Drive
          San Jose, CA 95134
          USA
    Tel: +1 800 553-NETS
    
    E-mail: cs-rf-mib@cisco.com";

  description
   "This MIB provides configuration control and status for the
    Redundancy Framework (RF) subsystem. RF provides a mechanism
    for logical redundancy of software functionality and is
    designed to support 1:1 redundancy on processor cards. RF is
    not intended to solve all redundancy schemes. Nor is RF
    designed to support redundant hardware, such as power
    supplies.
    
    Redundancy is concerned with the duplication of data elements
    and software functions to provide an alternative in case of
    failure. It is a key component to meeting 99.999% availability
    requirements for Class 5 carrier solutions.
    
    In the scope of this MIB definition, peer software elements
    are redundant and redundant software elements are peers.";

  revision 2005-09-01 {
    description
     "Added a new textual convention : RFClientStatus.
      
      Added the cRFStatusRFClientTable which contains information
      about all the clients registered with the Redundancy 
      Facility (RF). ";
  }

  revision 2004-04-01 {
    description
     "Added the new states, systemReset, loadVersionSwitchover
      and runVersionSwitchover. The unset state has been removed
      and the init state will represent the absense of the ISSU
      process. Updated the object cRFStatusIssuState to
      cRFStatusIssuStateRev1 as the ISSU states have been revised.
      Added new object, cRFStatusIssuFromVersion and
      cRFStatusIssuToVersion which represent the from and the to
      versions of IOS that are involved in the upgrade process.
      The object ciscoRFIssuStateObjGroup was changed to
      ciscoRFIssuStateObjGroupRev1 to accomodate these new
      objects.";
  }

  revision 2004-02-04 {
    description
     "Added ciscoRFIssuStateNotifGroup and ciscoRFIssuStateObjGroup
      that represent the notification group and the object group
      that represents the ISSU state of the system.";
  }

  revision 2003-10-02 {
    description
     "Changed the description for ciscoRFProgressionNotif";
  }

  revision 2002-01-07 {
    description
     "Added the following object in cRFStatus:
      cRFStatusRFModeCapsTable
      Added the following object in cRFCfg:
      cRFCfgRedundancyOperMode
      Updated description of following object in cRFCfg:
      cRFCfgRedundancyMode";
  }

  revision 2001-07-20 {
    description
     "Added new sub-group
      cRFHistory
      Added new table cRFHistorySwitchOverTable
      which maintains the history of switchovers.
      Also added objects:
      cRFStatusFailoverTime
      cRFStatusPeerStandByEntryTime
      cRFHistoryTableMaxLength
      cRFHistoryColdStarts
      cRFHistoryStandByAvailTime
      Added textual convention:
      RFUnitIdentifier.";
  }

  revision 2001-06-26 {
    description
     "Changed terminology:
      'split-mode' is now 'maintenance-mode'
      Added textual convention:
      RFMode
      Deprecated object:
      cRFCfgSplitMode
      Added objects:
      cRFCfgMaintenanceMode
      cRFCfgRedundancyMode
      cRFCfgRedundancyModeDescr
      Added enumeration values:
      noAction(0)         to RFAction
      activeExtraload(15) to RFState
      activeHandback(16)  to RFState
      Added new transition state to ciscoRFProgressionNotif:
      activeExtraload
      Update compliance and conformance statements";
  }

  revision 2001-04-03 {
    description
     "The initial revision of this MIB.";
  }

  typedef RFState {
    type enumeration {
      enum "notKnown" {
        value "1";
      }
      enum "disabled" {
        value "2";
      }
      enum "initialization" {
        value "3";
      }
      enum "negotiation" {
        value "4";
      }
      enum "standbyCold" {
        value "5";
      }
      enum "standbyColdConfig" {
        value "6";
      }
      enum "standbyColdFileSys" {
        value "7";
      }
      enum "standbyColdBulk" {
        value "8";
      }
      enum "standbyHot" {
        value "9";
      }
      enum "activeFast" {
        value "10";
      }
      enum "activeDrain" {
        value "11";
      }
      enum "activePreconfig" {
        value "12";
      }
      enum "activePostconfig" {
        value "13";
      }
      enum "active" {
        value "14";
      }
      enum "activeExtraload" {
        value "15";
      }
      enum "activeHandback" {
        value "16";
      }
    }
    description
     "The current state of the RF subsystem.
      
      notKnown
          - state is unknown
      disabled
          - RF is not operational on this unit
      initialization
          - establish necessary system services
      negotiation
          - peer unit discovery and negotiation
      standbyCold
          - client notification on standby unit
      *standbyColdConfig
          - standby configuration is updated from active configuration
      *standbyColdFileSys
          - standby file system (FS) is updated from the active FS
      *standbyColdBulk
          - clients sync data from active to standby
      standbyHot
          - incremental client data sync continues. This unit is
            ready to take over activity.
      activeFast
          - call maintenance efforts during a SWACT
      activeDrain
          - client clean-up phase
      activePreconfig
          - unit is active but has not read its configuration
      activePostconfig
          - unit is active and is post-processing its configuration
      active
          - unit is active and processing calls
      activeExtraload
          - unit is active and processing calls for all feature
            boards in the system
      activeHandback
          - unit is active, processing calls and is in the process
            of handing some resources to the other unit in the system
      
      * Sub-state of 'standbyCold'";
  }

  typedef RFMode {
    type enumeration {
      enum "nonRedundant" {
        value "1";
      }
      enum "staticLoadShareNonRedundant" {
        value "2";
      }
      enum "dynamicLoadShareNonRedundant" {
        value "3";
      }
      enum "staticLoadShareRedundant" {
        value "4";
      }
      enum "dynamicLoadShareRedundant" {
        value "5";
      }
      enum "coldStandbyRedundant" {
        value "6";
      }
      enum "warmStandbyRedundant" {
        value "7";
      }
      enum "hotStandbyRedundant" {
        value "8";
      }
    }
    description
     "The characterization of the redundancy subsystem.
      
      nonRedundant
          - the system is not redundant.
      staticLoadShareNonRedundant
          - the system is *not* redundant but is load sharing.
            The load sharing is *not* based on operational load
            (i.e. number of calls, etc).
      dynamicLoadShareNonRedundant
          - the system is *not* redundant but is load sharing.
            Load sharing is based on operational load.
      staticLoadShareRedundant
          - the system is redundant and is load sharing. The
            load sharing is *not* based on operational load.
      dynamicLoadShareRedundant
          - the system is redundant and is load sharing. Load
            sharing is based on operational load.
      coldStandbyRedundant
          - the system is redundant but the redundant peer unit is
            not fully initialized and is not able to retain
            established calls.
      warmStandbyRedundant
          - the system is redundant and the redundant peer unit is
            immediately able to handle new calls. The redundant
            unit is unable to retain established calls.
      hotStandbyRedundant
          - the system is redundant and the redundant peer unit is
            able to 'instantaneously' retain established calls and
            immediately able to handle new calls.";
  }

  typedef RFAction {
    type enumeration {
      enum "noAction" {
        value "0";
      }
      enum "reloadPeer" {
        value "1";
      }
      enum "reloadShelf" {
        value "2";
      }
      enum "switchActivity" {
        value "3";
      }
      enum "forceSwitchActivity" {
        value "4";
      }
    }
    description
     "Administrative commands to invoke in the RF subsystem.
      
      noAction
          - no action (do nothing)
      reloadPeer
          - reset the redundant peer unit
      reloadShelf
          - reset the entire shelf
      switchActivity
          - safely SWACT to peer unit and go standby
      forceSwitchActivity
          - switch activity; ignoring pre-conditions, system
            warnings and safety checks.
      
      When the value is set to 'noAction' no operation is performed.
      When read, the value 'noAction' is always returned.";
  }

  typedef RFSwactReasonType {
    type enumeration {
      enum "unsupported" {
        value "1";
      }
      enum "none" {
        value "2";
      }
      enum "notKnown" {
        value "3";
      }
      enum "userInitiated" {
        value "4";
      }
      enum "userForced" {
        value "5";
      }
      enum "activeUnitFailed" {
        value "6";
      }
      enum "activeUnitRemoved" {
        value "7";
      }
    }
    description
     "Reason codes for the switch of activity from an active
      redundant unit to its standby peer unit.
      
      unsupported
          - the 'reason code' is an unsupported feature
      none
          - no SWACT has occurred
      notKnown
          - reason is unknown
      userInitiated
          - a safe, manual SWACT was initiated by user
      userForced
          - a manual SWACT was forced by user; ignoring
            pre-conditions, warnings and safety checks
      activeUnitFailed
          - active unit failure caused an auto SWACT
      activeUnitRemoved
          - active unit removal caused an auto SWACT";
  }

  typedef RFUnitIdentifier {
    type int32 {
      range "0..2147483647";
    }
    description
     "A unique identifier for Active/Standby unit.";
  }

  typedef RFIssuState {
    type enumeration {
      enum "unset" {
        value "0";
      }
      enum "init" {
        value "1";
      }
      enum "loadVersion" {
        value "2";
      }
      enum "runVersion" {
        value "3";
      }
      enum "commitVersion" {
        value "4";
      }
    }
    status deprecated;
    description
     "ISSU state represents the current system state.
      
      unset
          - unset state; if the system is booted from tftp or from
            ROMMON such that the image is not the first in BOOT
      init
          - init state; the first ISSU state that the system will
            move to after the unset state, when the ISSU process
            has just been kicked off. The first CLI that is executed
            to make this happen is the loadversion CLI.
      loadVersion
          - Once the loadversion CLI has been executed, the state
            of the system is changed to reflect this, and this state
            is called the loadVersion state. The boot variable on
            the Standby is updated to point to the new image that the
            Standby needs to load and then it is reset.
      runVersion
          - runVersion state; When the system is in the loadversion
            state, the Active is running the old image and the
            Standby is running the new image. When the runversion
            CLI is executed, a switchover occurs, and the Standby
            running the new image takes over as the Active. The
            state of the system at this stage is updated to
            runversion.
      commitVersion
          - in the runversion state, the Active is running the
            new image, and the Standby is running the old image.
            When the user is satisfied with the functioning of
            the system, they execute the commitversion CLI, which
            will prepend the boot variable on the Standby with
            the new image, and then the Standby is reset. After
            this, the Standby comes up with the new image, and
            the state of the system is updated to reflect the
            commitVersion state.";
  }

  typedef RFIssuStateRev1 {
    type enumeration {
      enum "init" {
        value "0";
      }
      enum "systemReset" {
        value "1";
      }
      enum "loadVersion" {
        value "3";
      }
      enum "loadVersionSwitchover" {
        value "4";
      }
      enum "runVersion" {
        value "6";
      }
      enum "runVersionSwitchover" {
        value "7";
      }
      enum "commitVersion" {
        value "9";
      }
    }
    description
     "ISSU state represents the current system state.
      
      init
          - This state represents the initial state of the system.
            The ISSU process is not running at this stage. The only
            CLI for ISSU process that can be executed in this state
            is the loadversion CLI.
      systemReset
          - If a system reset occurs, or the abortversion CLI is 
            executed, the state of the system is pushed to this state.
      loadVersion
          - When the Standby signs in after the loadversion CLI
            is executed, the state of the system is changed to
            loadVersion.
      loadVersionSwitchover
          - If a switchover occurs in the loadVersion state, by
            the user, or because the Active crashes, the new
            state of the system will be loadVersionSwitchover.
            It is analogous to the runVersion state, except that
            the runversion CLI was not executed.
      runVersion
          - When the Standby signs in after executing the
            runversion CLI, the state of the system is changed
            to runVersion.
      runVersionSwitchover
          - if a switchover occurs while the system is in the
            runVersion state, the new state will be called
            runVersionSwitchover. It is analogous to the
            loadVersion state.
      commitVersion
          - When the Standby signs in after the commitversion CLI
            is executed, the state of the system is changed to
            commitVersion.";
  }

  typedef RFClientStatus {
    type enumeration {
      enum "noStatus" {
        value "1";
      }
      enum "clientNotRedundant" {
        value "2";
      }
      enum "clientRedundancyInProgress" {
        value "3";
      }
      enum "clientRedundant" {
        value "4";
      }
    }
    description
     "The status of a RF client before, during and after
      switchover.
      
      noStatus
          - No status information is available for this client.
      clientNotRedundant
          - Client is active. But there is no redundancy to this
            client. This could be because there is no standby or
            the client cannot claim that the standby client can
            take over without losing data or traffic during a
            switchover.
      clientRedundancyInProgress
          - The client is trying to sync all data to standby and
            achieve redundancy.
      clientRedundant
          - The client is redundant and ready for switchover. The 
            client can safely claim that there is no data or traffic 
            loss if there is a switchover.";
  }


  container CISCO-RF-MIB {
    config false;

    container cRFStatus {
      smiv2:oid "1.3.6.1.4.1.9.9.176.1.1";

      leaf cRFStatusUnitId {
        type CISCO-RF-MIB:RFUnitIdentifier;
        description
         "A unique identifier for this redundant unit. This identifier
          is implementation-specific but the method for selecting the id
          must remain consistent throughout the redundant system.
          
          Some example identifiers include: slot id, physical or logical
          entity id, or a unique id assigned internally by the RF
          subsystem.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.1";
      }

      leaf cRFStatusUnitState {
        type CISCO-RF-MIB:RFState;
        description
         "The current state of RF on this unit.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.2";
      }

      leaf cRFStatusPeerUnitId {
        type CISCO-RF-MIB:RFUnitIdentifier;
        description
         "A unique identifier for the redundant peer unit. This
          identifier is implementation-specific but the method for
          selecting the id must remain consistent throughout the
          redundant system.
          
          Some example identifiers include: slot id, physical or logical
          entity id, or a unique id assigned internally by the RF
          subsystem.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.3";
      }

      leaf cRFStatusPeerUnitState {
        type CISCO-RF-MIB:RFState;
        description
         "The current state of RF on the peer unit.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.4";
      }

      leaf cRFStatusPrimaryMode {
        type boolean;
        description
         "Indicates whether this is the primary redundant unit or
          not. If this unit is the primary unit, this object is true. If
          this unit is the secondary unit, this object is false.
          
          Note that the terms 'primary/secondary' are not synonymous
          with the terms 'active/standby'. At any given time, the
          primary unit may be the active unit, or the primary unit may
          be the standby unit. Likewise,   the secondary unit, at any
          given time, may be the active unit, or the secondary unit may
          be the standby unit.
          
          The primary unit is given a higher priority or precedence over
          the secondary unit. In a race condition (usually at
          initialization time) or any situation where the redundant
          units are unable to successfully negotiate activity between
          themselves, the primary unit will always become the active
          unit and the secondary unit will fall back to standby. Only
          one redundant unit can be the primary unit at any given time.
          
          The algorithm for determining the primary unit is system
          dependent, such as 'the redundant unit with the lower numeric
          unit id is always the primary unit.'";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.5";
      }

      leaf cRFStatusDuplexMode {
        type boolean;
        description
         "Indicates whether the redundant peer unit has been detected
          or not. If the redundant peer unit is detected, this object is
          true. If the redundant peer unit is not detected, this object
          is false.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.6";
      }

      leaf cRFStatusManualSwactInhibit {
        type boolean;
        description
         "Indicates whether a manual switch of activity is
          permitted. If a manual switch of activity is allowed, this
          object is false. If a manual switch of activity is not
          allowed, this object is true. Note that the value of this
          object is the inverse of the status of manual SWACTs.
          
          This object does not indicate whether a switch of activity is
          or has occurred. This object only indicates if the
          user-controllable capability is enabled or not.
          
          A switch of activity is the event in which the standby
          redundant unit becomes active and the previously active unit
          becomes standby.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.7";
      }

      leaf cRFStatusLastSwactReasonCode {
        type CISCO-RF-MIB:RFSwactReasonType;
        description
         "The reason for the last switch of activity.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.8";
      }

      leaf cRFStatusFailoverTime {
        type yang:timestamp;
        description
         "The value of sysUpTime when the primary redundant unit took over
          as active. The value of this object will be 0 till the first
          switchover.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.9";
      }

      leaf cRFStatusPeerStandByEntryTime {
        type yang:timestamp;
        description
         "The value of sysUpTime when the peer redundant unit entered the
          standbyHot state. The value will be 0 on system initialization.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.10";
      }

      leaf cRFStatusIssuState {
        type CISCO-RF-MIB:RFIssuState;
        status deprecated;
        description
         "The current ISSU state of the system.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.12";
      }

      leaf cRFStatusIssuStateRev1 {
        type CISCO-RF-MIB:RFIssuStateRev1;
        description
         "The current ISSU state of the system.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.13";
      }

      leaf cRFStatusIssuFromVersion {
        type snmp-framework:SnmpAdminString;
        description
         "The IOS version from with the user is upgrading";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.14";
      }

      leaf cRFStatusIssuToVersion {
        type snmp-framework:SnmpAdminString;
        description
         "The IOS version to with the user is upgrading";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.15";
      }
    }

    container cRFCfg {
      smiv2:oid "1.3.6.1.4.1.9.9.176.1.2";

      leaf cRFCfgSplitMode {
        type boolean;
        status deprecated;
        description
         "Indicates whether redundant units may communicate
          synchronization messages with each other. If communication is
          not permitted, this object is set to true. If communication is
          permitted, this object is set to false.
          
          In split mode (true), the active unit will not communicate
          with the standby unit. The standby unit progression will not
          occur. When split mode is disabled (false), the standby unit
          is reset to recover.
          
          Split mode (true) is useful for maintenance operations.";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.1";
      }

      leaf cRFCfgKeepaliveThresh {
        type uint32;
        description
         "On platforms that support keep-alives, the keep-alive
          threshold value designates the number of lost keep-alives
          tolerated before a failure condition is declared. If this
          occurs, a SWACT notification is sent.
          
          On platforms that do not support keep-alives, this object has
          no purpose or effect.";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.2";
      }

      leaf cRFCfgKeepaliveThreshMin {
        type uint32;
        description
         "The minimum acceptable value for the cRFCfgKeepaliveThresh
          object.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.3";
      }

      leaf cRFCfgKeepaliveThreshMax {
        type uint32;
        description
         "The maximum acceptable value for the cRFCfgKeepaliveThresh
          object.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.4";
      }

      leaf cRFCfgKeepaliveTimer {
        type uint32;
        units "milliseconds";
        description
         "On platforms that support keep-alives, the keep-alive timer
          value is used to guard against lost keep-alives. The RF
          subsystem expects to receive a keep-alive within this period.
          If a keep-alive is not received within this time period, a
          SWACT notification is sent.
          
          On platforms that do not support keep-alives, this object has
          no purpose or effect.";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.5";
      }

      leaf cRFCfgKeepaliveTimerMin {
        type uint32;
        units "milliseconds";
        description
         "The minimum acceptable value for the cRFCfgKeepaliveTimer
          object.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.6";
      }

      leaf cRFCfgKeepaliveTimerMax {
        type uint32;
        units "milliseconds";
        description
         "The maximum acceptable value for the cRFCfgKeepaliveTimer
          object.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.7";
      }

      leaf cRFCfgNotifTimer {
        type uint32;
        units "milliseconds";
        description
         "Note that the term 'notification' here refers to an RF
          notification and not an SNMP notification.
          
          As the standby unit progresses to the 'standbyHot' state,
          asynchronous messages are sent from the active unit to the
          standby unit which must then be acknowledged by the standby
          unit. If the active unit receives the acknowledgement during
          the time period specified by this object, progression proceeds
          as normal. If the timer expires and an acknowledgement was not
          received by the active unit, a switch of activity occurs.";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.8";
      }

      leaf cRFCfgNotifTimerMin {
        type uint32;
        units "milliseconds";
        description
         "The minimum acceptable value for the cRFCfgNotifTimer
          object.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.9";
      }

      leaf cRFCfgNotifTimerMax {
        type uint32;
        units "milliseconds";
        description
         "The maximum acceptable value for the cRFCfgNotifTimer
          object.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.10";
      }

      leaf cRFCfgAdminAction {
        type CISCO-RF-MIB:RFAction;
        description
         "This variable is set to invoke RF subsystem action commands.
          The commands are useful for maintenance and software upgrade
          activities.";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.11";
      }

      leaf cRFCfgNotifsEnabled {
        type boolean;
        description
         "Allows enabling/disabling of RF subsystem notifications.";
        smiv2:defval "false";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.12";
      }

      leaf cRFCfgMaintenanceMode {
        type boolean;
        description
         "Indicates whether redundant units may communicate
          synchronization messages with each other. If communication is
          not permitted, this object is set to 'true'. If communication
          is permitted, this object is set to 'false'.
          
          If the value of this object is 'true', the redundant system is
          considered to be in a maintenance mode of operation. If the
          value of this object is 'false', the redundant system is
          considered to be in a normal (non-maintenance) mode of
          operation.
          
          In maintenance mode (true), the active unit will not
          communicate with the standby unit. The standby unit
          progression will not occur. When maintenance mode is disabled
          (false), the standby unit is reset to recover.
          
          Maintenance mode (true) is useful for maintenance-type
          operations.";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.13";
      }

      leaf cRFCfgRedundancyMode {
        type CISCO-RF-MIB:RFMode;
        description
         "Indicates the redundancy mode configured on the device.";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.14";
      }

      leaf cRFCfgRedundancyModeDescr {
        type snmp-framework:SnmpAdminString;
        description
         "Further clarifies or describes the redundancy mode indicated
          by cRFCfgRedundancyMode. Implementation-specific terminology
          associated with the current redundancy mode may be presented
          here.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.15";
      }

      leaf cRFCfgRedundancyOperMode {
        type CISCO-RF-MIB:RFMode;
        description
         "Indicate the operational redundancy mode of the device.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.2.16";
      }
    }

    container cRFHistory {
      smiv2:oid "1.3.6.1.4.1.9.9.176.1.3";

      leaf cRFHistoryTableMaxLength {
        type uint32 {
          range "0..50";
        }
        description
         "Maximum number of entries permissible in the history
          table. A value of 0 will result in no history being
          maintained.";
        smiv2:defval "10";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.3.1";
      }

      leaf cRFHistoryColdStarts {
        type yang:counter32;
        description
         "Indicates the number of system cold starts. This includes
          the number of system cold starts due to switchover failure
          and the number of manual restarts.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.3.3";
      }

      leaf cRFHistoryStandByAvailTime {
        type snmpv2-tc:TimeInterval;
        description
         "Indicates the cumulative time that a standby redundant
          unit has been available since last system initialization.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.3.4";
      }
    }

    container cRFStatusRFModeCapsTable {
      description
       "This table containing a list of redundancy modes that can be
        supported on the device.";
      smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.11";

      list cRFStatusRFModeCapsEntry {
        key "cRFStatusRFModeCapsMode";
        description
         "An entry containing the device implementation specific
          terminology associated with the redundancy mode that can be
          supported on the device.";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.11.1";

        leaf cRFStatusRFModeCapsMode {
          type CISCO-RF-MIB:RFMode;
          description
           "The redundancy mode that can be supported on the device.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.11.1.1";
        }

        leaf cRFStatusRFModeCapsModeDescr {
          type snmp-framework:SnmpAdminString;
          description
           "The description of the device implementation specific
            terminology associated with its supported redundancy mode.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.1.11.1.2";
        }
      }
    }

    container cRFHistorySwitchOverTable {
      description
       "A table that tracks the history of all switchovers that
        have occurred since system initialization. The maximum
        number of entries permissible in this table is defined by
        cRFHistoryTableMaxLength. When the number of entries in
        the table reaches the maximum limit, the next entry
        would replace the oldest existing entry in the table.";
      smiv2:oid "1.3.6.1.4.1.9.9.176.1.3.2";

      list cRFHistorySwitchOverEntry {
        key "cRFHistorySwitchOverIndex";
        description
         "The entries in this table contain the switchover
          information. Each entry in the table is indexed by
          cRFHistorySwitchOverIndex. The index wraps around to 1
          after reaching the maximum value.";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.3.2.1";

        leaf cRFHistorySwitchOverIndex {
          type uint32 {
            range "1..4294967295";
          }
          description
           "A monotonically increasing integer for the purpose of
            indexing history table. After reaching maximum value,
            it wraps around to 1.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.3.2.1.1";
        }

        leaf cRFHistoryPrevActiveUnitId {
          type CISCO-RF-MIB:RFUnitIdentifier;
          description
           "Indicates the primary redundant unit that went down.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.3.2.1.2";
        }

        leaf cRFHistoryCurrActiveUnitId {
          type CISCO-RF-MIB:RFUnitIdentifier;
          description
           "Indicates the secondary redundant unit that took
            over as active.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.3.2.1.3";
        }

        leaf cRFHistorySwitchOverReason {
          type CISCO-RF-MIB:RFSwactReasonType;
          description
           "Indicates the reason for the switchover.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.3.2.1.4";
        }

        leaf cRFHistorySwactTime {
          type snmpv2-tc:DateAndTime;
          description
           "Indicates the Date & Time when switchover occurred.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.3.2.1.5";
        }
      }
    }

    container cRFStatusRFClientTable {
      description
       "This table contains a list of RF clients that are
        registered on the device. 
        
        RF clients are applications that have registered with 
        the Redundancy Facility (RF) to receive RF events and 
        notifications. The purpose of RF clients is to synchronize 
        any relevant data with the standby unit.";
      smiv2:oid "1.3.6.1.4.1.9.9.176.1.4.1";

      list cRFStatusRFClientEntry {
        key "cRFStatusRFClientID";
        description
         "An entry containing information on various clients
          registered with the Redundancy Facility (RF). Entries in
          this table are always created by the system.
          
          An entry is created in this table when a redundancy aware 
          application registers with the Redundancy Facility. The entry 
          is destroyed when that application deregisters from the 
          Redundancy Facility.";
        smiv2:oid "1.3.6.1.4.1.9.9.176.1.4.1.1";

        leaf cRFStatusRFClientID {
          type uint32 {
            range "1..4294967295";
          }
          description
           "A unique identifier for the client which registered with the
            Redundancy Facility.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.4.1.1.1";
        }

        leaf cRFStatusRFClientDescr {
          type snmp-framework:SnmpAdminString;
          description
           "The description of the client which has registered with the
            Redundancy Facility.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.4.1.1.2";
        }

        leaf cRFStatusRFClientSeq {
          type uint32;
          description
           "The sequence number of the client. The system assigns the
            sequence numbers based on the order of registration of
            the Redundancy Facility clients. 
            This is used for deciding order of RF events sent to clients.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.4.1.1.3";
        }

        leaf cRFStatusRFClientRedTime {
          type uint32;
          units "milliseconds";
          description
           "Time taken for this client to become Redundant. This value
            is meaningful when the value of cRFStatusRFClientStatus is
            not 'noStatus'.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.4.1.1.4";
        }

        leaf cRFStatusRFClientStatus {
          type CISCO-RF-MIB:RFClientStatus;
          description
           "This object provides the status of the Redundancy Facility
            client.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.176.1.4.1.1.5";
        }
      }
    }
  }

  notification ciscoRFSwactNotif {
    description
     "A SWACT notification is sent by the newly active redundant
      unit whenever a switch of activity occurs. In the case where a
      SWACT event may be indistinguishable from a reset event, a
      network management station should use this notification to
      differentiate the activity.
      
      sysUpTime is the same sysUpTime defined in the RFC-1213 MIB.";
    smiv2:oid "1.3.6.1.4.1.9.9.176.2.0.1";

    container object-1 {

      leaf cRFStatusUnitId {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusUnitId";
        }
      }
    }

    container object-2 {

      leaf sysUpTime {
        type leafref {
          path "/snmpv2-mib:SNMPv2-MIB/snmpv2-mib:system/snmpv2-mib:sysUpTime";
        }
      }
    }

    container object-3 {

      leaf cRFStatusLastSwactReasonCode {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusLastSwactReasonCode";
        }
      }
    }
  }

  notification ciscoRFProgressionNotif {
    description
     "A progression notification is sent by the active redundant
      unit whenever its RF state changes or the RF state of the peer
      unit changes.
      
      To avoid a flurry of notifications for all state transitions,
      notifications will only be sent for transitions to the
      following RF states:
          disabled (for the peer state)
          standbyCold
          standbyHot
          active
          activeExtraload";
    smiv2:oid "1.3.6.1.4.1.9.9.176.2.0.2";

    container object-1 {

      leaf cRFStatusUnitId {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusUnitId";
        }
      }
    }

    container object-2 {

      leaf cRFStatusUnitState {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusUnitState";
        }
      }
    }

    container object-3 {

      leaf cRFStatusPeerUnitId {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusPeerUnitId";
        }
      }
    }

    container object-4 {

      leaf cRFStatusPeerUnitState {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusPeerUnitState";
        }
      }
    }
  }

  notification ciscoRFIssuStateNotif {
    status deprecated;
    description
     "An ISSU notification to indicate the new state of
      the system.";
    smiv2:oid "1.3.6.1.4.1.9.9.176.2.0.3";

    container object-1 {

      leaf cRFStatusUnitId {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusUnitId";
        }
      }
    }

    container object-2 {

      leaf cRFStatusUnitState {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusUnitState";
        }
      }
    }

    container object-3 {

      leaf cRFStatusIssuState {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusIssuState";
        }
        status deprecated;
      }
    }
  }

  notification ciscoRFIssuStateNotifRev1 {
    description
     "An ISSU notification to indicate the new state of
      the system.";
    smiv2:oid "1.3.6.1.4.1.9.9.176.2.0.4";

    container object-1 {

      leaf cRFStatusIssuStateRev1 {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusIssuStateRev1";
        }
      }
    }

    container object-2 {

      leaf cRFStatusIssuFromVersion {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusIssuFromVersion";
        }
      }
    }

    container object-3 {

      leaf cRFStatusIssuToVersion {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusIssuToVersion";
        }
      }
    }

    container object-4 {

      leaf cRFStatusLastSwactReasonCode {
        type leafref {
          path "/CISCO-RF-MIB:CISCO-RF-MIB/CISCO-RF-MIB:cRFStatus/CISCO-RF-MIB:cRFStatusLastSwactReasonCode";
        }
      }
    }
  }

  smiv2:alias "ciscoRFMIB" {
    smiv2:oid "1.3.6.1.4.1.9.9.176";
  }

  smiv2:alias "ciscoRFMIBObjects" {
    smiv2:oid "1.3.6.1.4.1.9.9.176.1";
  }

  smiv2:alias "cRFStatus" {
    smiv2:oid "1.3.6.1.4.1.9.9.176.1.1";
  }

  smiv2:alias "cRFCfg" {
    smiv2:oid "1.3.6.1.4.1.9.9.176.1.2";
  }

  smiv2:alias "cRFHistory" {
    smiv2:oid "1.3.6.1.4.1.9.9.176.1.3";
  }

  smiv2:alias "cRFClient" {
    smiv2:oid "1.3.6.1.4.1.9.9.176.1.4";
  }

  smiv2:alias "ciscoRFMIBNotificationsPrefix" {
    smiv2:oid "1.3.6.1.4.1.9.9.176.2";
  }

  smiv2:alias "ciscoRFMIBNotifications" {
    smiv2:oid "1.3.6.1.4.1.9.9.176.2.0";
  }

  smiv2:alias "ciscoRFMIBConformance" {
    smiv2:oid "1.3.6.1.4.1.9.9.176.3";
  }

  smiv2:alias "ciscoRFMIBCompliances" {
    smiv2:oid "1.3.6.1.4.1.9.9.176.3.1";
  }

  smiv2:alias "ciscoRFMIBGroups" {
    smiv2:oid "1.3.6.1.4.1.9.9.176.3.2";
  }

}
