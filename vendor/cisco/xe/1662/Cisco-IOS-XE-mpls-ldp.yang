module Cisco-IOS-XE-mpls-ldp {
  namespace "http://cisco.com/ns/yang/Cisco-IOS-XE-mpls-ldp";
  prefix mpls-ldp-ios-xe-oper;

  import ietf-inet-types {
    prefix inet;
  }
  import ietf-interfaces {
    prefix if;
  }
  import ietf-yang-types {
    prefix yang;
  }

  organization "Cisco Systems, Inc.";
  contact
    "Cisco Systems, Inc.
     Customer Service

     Postal: 170 West Tasman Drive
     San Jose, CA 95134

     Tel: +1 800 553-NETS

     E-mail: cs-yang@cisco.com";

  description
    "This module contains a collection of YANG definitions
     for the Cisco MPLS LDP configuration and operational data.


     The configuration is held in the mpls-ldp-config container
     which is broken into the following sections:
       1) global-cfg contains configuration applicable to the entire
            LSR.
       2) nbr-table contains configuration for specific LDP neighbors
            or peers.
       3) passwords contains configuration regarding passwords, both
            local and those to be used with specific neighbors.
       4) label-cfg contains the label allocation and advertisement
            configuration and filters.
       5) discovery contains the configuration for link-hello and
            targetted hello protocol parameters including
            interface-specific settings for transport.
       6) graceful-restart contains the configuration for the
            graceful restart feature.
       7) logging contains the configuration for ldp-specific logs.
       8) interfaces contains the configuration for each interface,
            including and routing interactions specific to that
            interface.

     The operational state is held in the mpls-ldp-state container
     which is broken the following sections:
       1) oper-summary contains the summarized global state.
       2) forwarding-summary contains the summarized forwarding
            state.
       3) bindings-summary contains the summarized forwarding state.
       4) vrf provides the detailed state on a per VRF basis.
       5) bindings-advertise-specs - holds the advertisement
            specification filters
       6) discovery provides the LDP Discovery operational state.
       7) forwarding provides summary information regarding LDP
            forwarding setup and detailed information on the LDP
            forwarding rewrites
       8) bindings provides the detailed LDP Bindings of address to
            label.
       9) neighbors

     The vrf-table, provides the detailed state on a per VRF basis.
     If the router only supports LDP in a single VRF then this table
     will have a single entry using the vrf-name 'default'.
     Otherwise this table will have one entry for every VRF where
     LDP is enabled on the device.

     Each vrf includes:
        A list parameters used by the VRF
        A capability table containing the capabilities exchanged with
          each neighbor.
        A table of backoff parameters used in this VRF.
        The graceful restart information used between the local
           device and the neighbors should any of them restart.
        An AF-table which holds all information for a given Address
           Family. This is extensive and is described below.
        The LDP ID used by the device for this vrf.

     The AF-table holds information for a given Address Family
     such as:
          - per-interface state.
          - IGP synchronization data.
          - LDP bindings statistics.
          - LDP forwarding statistics.


       Terms and Acronyms

       FRR - Fast Re-Reroute

       ICCP - Inter-Chassis Communication Protocol

       LACP - Link Aggregation Control Protocol

       LDP - Label Distribution Protocol

       LER - Label Edge Router

       LFA - Loop Free Alternative

       LIB - Label Information Base

       LSR - Label Switch Router

       MPLS - Multi-Protocol Label Switching

       PQ node - A node which is a member of both the extended
           P-space and the Q-space as defined in
           draft-ietf-rtgwg-rlfa-node-protection.

       VRF - Virtual Route Forwarding

     Copyright (c) 2014, 2017 by Cisco Systems, Inc.
     All rights reserved.";

  // =========================================================================
  // REVISION
  // =========================================================================
  revision 2017-02-07 {
    description
      "Initial revision";
  }

  feature mpls-ldp-bgp {
    description
      "This feature identifies MPLS LDP BGP information and is only
       supported on devices which are capable of allowing LDP to
       interact with BGP, regardless of whether such support is
       enabled. ";
  }

  feature mpls-ldp-nsr {
    description
      "This feature identifies MPLS LDP Non-Stop Routing information
       and is only supported on devices capable of allowing this
       support, regardless of whether such support is enabled.";
  }

  /* placeholder for feature that is XR-only */
  feature mpls-ldp-extended {
    description
      "This identifies MPLS LDP Extended Support, i.e. support for
       non-core LDP features.";
  }

  feature mpls-ldp-iccp {
    description
      "This feature identifies MPLS LDP ICCP information and is only
       supported on devices which support LDP ICCP extensions.";
  }


  typedef loop-detection-type {
    type enumeration {
      enum none {
        value 1;
        description
          "Loop Detection is not enabled on this LSR.";
      }
      enum other {
        value 2;
        description
          "Loop Detection is enabled but by a method
           other than those defined.";
      }
      enum hop-count {
        value 3;
        description
          "Loop Detection is supported by Hop Count only.";
      }
      enum path-vector {
        value 4;
        description
          "Loop Detection is supported by Path Vector only.";
      }
      enum hop-count-and-path-vector {
        value 5;
        description
          "Loop Detection is supported by both Hop Count
           and Path Vector.";
      }
    }
    description
      "This specifies the type of loop detection either supported by
       the LSR or enabled on the LSR.";
  } // typedef loop-detection-type

  typedef session-state {
    type enumeration {
      enum nonexistent {
        value 1;
        description
          "LDP session state: nonexistent.";
      }
      enum initialized {
        value 2;
        description
          "LDP session state: initialized.";
      }
      enum openrec {
        value 3;
        description
          "LDP session state: openrec.";
      }
      enum opensent {
        value 4;
        description
          "LDP session state: opensent.";
      }
      enum operational {
        value 5;
        description
          "LDP session state: operational.";
      }
    }
    description
      "The current state of the session, all of the
       states 1 to 5 are based on the state machine
       for session negotiation behavior.";
    reference
      "RFC3036, LDP Specification, Section 2.5.4,
       Initialization State Machine.";
  } // typedef session-state


  typedef adj-state {
    type enumeration {
      enum nonex {
        value 0;
        description
          "LDP adjacency state: nonexistent.";
      }
      enum unsol-op-pdg {
        value 1;
        description
          "LDP session state: unsolicited open pending.";
      }
      enum deferred {
        value 2;
        description
          "LDP session state: deferred.";
      }
      enum estab {
        value 3;
        description
          "LDP session state: established";
      }
      enum lib-exp-wait {
        value 4;
        description
          "LDP session state: LIB expension wait.";
      }
      enum destroyed {
        value 5;
        description
          "LDP session state: destroyed.";
      }
    }
    description
      "The current state of the session, all of the
       states 0 to 5 are based on the state machine
       for LDP adjacency peer.";
  } // typedef adj-state


  typedef adv-label-type {
    type enumeration {
      enum use-lable {
        value 1;
        description
          "Advertise the label for matching prefixes and peers.";
      }
      enum use-explicit {
        value 2;
        description
          "Advertise explicit null for matching prefixes and peers.";
      }
      enum use-implicit {
        value 3;
        description
          "Advertise imlicit null for matching prefixes and peers.";
      }
      enum none {
        value 4;
        description
          "Do not advertise labels for matching prefixes and peers.";
      }
    }
    description
      "This provides the configuration of the type of label to
       advertise for matching prefixes and peers.";
  } // typedef adv-label-type

  typedef nbr-bgp-advt-state {
    type enumeration {
      enum "not-applicable" {
        description
          "BGP Label Advertisement is not applicable.";
      }
      enum "permit" {
        description
          "BGP Label Advertisement is permitted.";
      }
      enum "deny" {
        description
          "BGP Label Advertisement denied.";
      }
    }
    description
      "MPLS LDP Neighbor BGP Label Advertisement State
       Type.";
  }


  /*
   * The following are the LDP Non-Stop Routing peer LDP
   * synchronization nack reasons.
   */
  identity nsr-sync-nack-rsn {
    description
      "Base identity from which LDP Non-Stop Routing peer LDP
       synchronization nack reason identities are derived.";
  }

  identity nsr-sync-nack-rsn-none {
    base nsr-sync-nack-rsn;
    description
      "None";
  }
  identity nsr-sync-nack-rsn-tbl-id-mismatch {
    base nsr-sync-nack-rsn;
    description
      "NSR failed with a table ID mismatch.";
  }
  identity nsr-sync-nack-rsn-pp-exists { /* TBD move to XR augment */
    base nsr-sync-nack-rsn;
    description
      "NSR failed with because pp already exists.";
  }
  identity nsr-sync-nack-rsn-missing-elem { /* TBD XR augment */
    base nsr-sync-nack-rsn;
    description
      "NSR failed due to a Missing Element.";
  }
  identity nsr-sync-nack-rsn-no-p-end-sock { /* TBD XR augment */
    base nsr-sync-nack-rsn;
    description
      "NSR failed because there was no P end socket.";
  }
  identity nsr-sync-nack-rsn-p-end-sock-not-synced { /* TBD XR aug */
    base nsr-sync-nack-rsn;
    description
      "NSR failed because the P end sock was not synced.";
  }
  identity nsr-sync-nack-rsn-err-adj-add { /* TBD move to XR aug */
    base nsr-sync-nack-rsn;
    description
      "NSR failed due to an error adding the adjacency.";
  }
  identity nsr-sync-nack-rsn-err-dhc-add { /* TBD move to XR aug */
    base nsr-sync-nack-rsn;
    description
      "NSR failed with a error creating the directed hello control
       infrastructure.";
  }
  identity nsr-sync-nack-rsn-enomem {
    base nsr-sync-nack-rsn;
    description
      "NSR failed due to an out of memory error.";
  }
  identity nsr-sync-nack-rsn-err-tp-create {
    base nsr-sync-nack-rsn;
    description
      "NSR failed creating the tp."; /* TBD better error desc */
  }
  identity nsr-sync-nack-rsn-err-pp-create {
    base nsr-sync-nack-rsn;
    description
      "NSR failed creating the pp."; /* TBD better error desc */
  }
  identity nsr-sync-nack-rsn-err-addr-bind {
    base nsr-sync-nack-rsn;
    description
      "NSR failed to bind address.";
  }
  identity nsr-sync-nack-rsn-err-rx-bad-pie {
    base nsr-sync-nack-rsn;
    description
      "NSR failed, received a bad PIE.";
  }
  identity nsr-sync-nack-rsn-err-rx-notif {
    base nsr-sync-nack-rsn;
    description
      "NSR failed with a received notification error.";
  }
  identity nsr-sync-nack-rsn-err-rx-unexp-open {
    base nsr-sync-nack-rsn; /* TBD move to XR augment */
    description
      "NSR failed due to an unexpected open.";
  }
  identity nsr-sync-nack-rsn-err-unexp-peer-down {
    base nsr-sync-nack-rsn;
    description
      "NSR failed due to unexpected peer down.";
  }
  identity nsr-sync-nack-rsn-err-app-not-found {
    base nsr-sync-nack-rsn; /* TBD move to XR augment */
    description /* TBD, app where? local, remote, xr-specific? */
      "NSR failed due to app not found.";
  }
  identity nsr-sync-nack-rsn-err-app-invalid {
    base nsr-sync-nack-rsn;
    description /* TBD, app where? local, remote, xr-specific? */
      "NSR failed due to an app invalid error.";
  }
  identity nsr-sync-nack-rsn-no-ctx {
    base nsr-sync-nack-rsn;
    description
      "NSR failed with a no context error.";
  }

  /*
   * The following are the MPLS LDP NSR peer synchronization errors.
   */
  identity nsr-peer-sync-err {
    description
      "Base for MPLS LDP NSR peer synchronization error types.";
  }
  identity nsr-peer-sync-err-none {
    base  nsr-peer-sync-err;
    description
      "No error.";
  }
  identity nsr-peer-sync-err-ldp-sync-nack {
    base  nsr-peer-sync-err;
    description
      "LDP Peer Sync failed, received sync nack.";
  }
  identity nsr-peer-sync-err-sync-prep {
    base  nsr-peer-sync-err;
    description  /* TBD local, remote, xr-specific? */
      "LDP Peer Sync failed, synch prep.";
  }
  identity nsr-peer-sync-err-tcp-peer {
    base  nsr-peer-sync-err;
    description /* TBD local, remote, xr-specific? */
      "LDP Peer Sync failed, tcp peer";
  }
  identity nsr-peer-sync-err-tcp-gbl {
    base  nsr-peer-sync-err;
    description /* TBD local, remote, xr-specific? */
      "LDP Peer Sync failed, tcp gbl";
  }
  identity nsr-peer-sync-err-ldp-peer {
    base  nsr-peer-sync-err;
    description /* TBD local, remote, xr-specific? */
      "LDP Peer Sync failed, ldp peer";
  }
  identity nsr-peer-sync-err-ldp-gbl {
    base  nsr-peer-sync-err;
    description /* TBD local, remote, xr-specific? */
      "LDP Peer Sync failed, ldp gbl";
  }
  identity nsr-peer-sync-err-app-fail {
    base  nsr-peer-sync-err;
    description /* TBD local, remote, xr-specific? */
      "LDP Peer Sync failed, app fail";
  }



  typedef iccp-state {
    type enumeration {
      enum  nonexistent {
        value 1;
        description
          "This state is the starting point for the state machine.
           It indicates that no ICCP connection exists and that
           there's no LDP session established between the PEs.";
      }

      enum initialized {
        value 2;
        description
          "This state indicates that an LDP session exists between
           the PEs but LDP ICCP Capabilitiy have not yet been
           exchanged between them.";
      }

      enum capsent {
        value 3;
        description
          "This state indicates that an LDP session exists between
           the PEs and that the local PE has avertized LDP ICCP
           Capability to its peer.";
      }

      enum caprec {
        value 4;
        description
          "This state indicates that an LDP session exists between
           the PEs and that the local PE has both received and
           advertized LDP ICCP Capability from/to its peer.";
      }
      enum connecting {
        value 5;
        description
          "This state indicates that the local PE has initiated an
           ICCP connection to its peer, and is awaiting its
           response.";
      }
      enum operational {
        value 6;
        description
          "This state indicates that the ICCP connection is
           operational.";
      }
    }
    description
      "This enum describes the ICCP state as defined by the
       IETF in TBD.";
  }

  identity icpm-type {
    description
      "Base identity from which ICPM types can be derived. As this is
       an extensible protocol, new types are expected.";
  }
  identity icpm-type-iccp {
    base icpm-type;
    description
       "ICCP Interchassis Communication Protocol.";
  }

  identity iccp-type {
    description
      "Base identity from which ICCP types can be derived. As this is
       an extensible protocol, new types are expected.";
  }
  identity iccp-type-mlacp {
    base iccp-type;
    description
       "MLACP Multi-chassic Link Aggregation Control Protocol.";
  }


  identity nsr-peer-sync-state {
    description
      "Base identity for LDP NSR Peer Synchronization State.";
  }
  identity ldp-nsr-peer-sync-st-none {
    base nsr-peer-sync-state;
    description
      "LDP NSR peer synchronization none.";
  }
  identity ldp-nsr-peer-sync-st-wait {
    base nsr-peer-sync-state;
    description
      "LDP NSR peer synchronization is wait.";
  }
  identity ldp-nsr-peer-sync-st-ready {
    base nsr-peer-sync-state;
    description
      "LDP NSR peer synchronization is ready.";
  }
  identity ldp-nsr-peer-sync-st-prep {
    base nsr-peer-sync-state;
    description
      "LDP NSR peer synchronization is prep.";
  }
  identity ldp-nsr-peer-sync-st-app-wait {
    base nsr-peer-sync-state;
    description
      "LDP NSR peer synchronization is app wait.";
  }
  identity ldp-nsr-peer-sync-st-oper {
    base nsr-peer-sync-state;
    description
      "LDP NSR peer synchronization is operational.";
  }

  identity nsr-status {
    description
      "Base identity for Non-Stop Routing State Type.";
  }
  identity nsr-status-ready {
    base nsr-status;
    description
      "Device is NSR Ready.";
  }
  identity nsr-status-not-ready {
    base nsr-status;
    description
      "Device is not NSR Ready.";
  }
  identity nsr-status-disabled {
    base nsr-status;
    description
      "NSR is not enabled.";
  }


  identity down-nbr-reason {
    description
      "Base identity for the reason a neighbor is down.";
  }
  identity down-nbr-reason-na {
    base down-nbr-reason;
    description
      "Not applicable, the neighbor is up..";
  }
  identity down-nbr-reason-nbr-hold {
    base down-nbr-reason;
    description
      "The neighbor sent error, hold time expired..";
  }
  identity down-nbr-reason-disc-hello {
    base down-nbr-reason;
    description
      "The local discovery hello timer expired..";
  }

  identity route-path-lbl-owner {
    description
      "Base Route path label owner type.";
  }
  identity "route-path-lbl-owner-none" {
    base route-path-lbl-owner;
     description
       "No label and no owner.";
  }
  identity "route-path-lbl-owner-ldp" {
    base route-path-lbl-owner;
    description
      "Path outgoing label owned by LDP.";
  }
  identity "route-path-lbl-owner-bgp" {
    base route-path-lbl-owner;
    description
      "Path outgoing label owned by BGP.";
  }
  identity "route-path-lbl-owner-static" {
    base route-path-lbl-owner;
    description
      "Path outgoing label statically configured.";
  }


  identity label-type {
    description
      "Base type for LDP Label Type";
  }
  identity label-type-mpls {
    base label-type;
    description
      "The is an MPLS Label.";
  }
  identity label-type-un-labeled {
    base label-type;
    description
      "This is unlabeled";
  }
  identity label-type-unknown {
    base label-type;
    description
      "The label is unknown.";
  }


  identity route-path-type {
    description
      "Base type for Route path type.";
  }

  identity route-path-ip-no-flag {
    base route-path-type;
    description
      "A primary path with no special flag/attribute";
  }
  identity route-path-ip-protected {
    base route-path-type;
    description
      "A primary path with LFA FRR protection";
  }
  identity route-path-ip-backup {
    base route-path-type;
    description
      "A non-primary local LFA FRR (pure) backup path";
  }
  identity route-path-ip-backup-remote {
    base route-path-type;
    description
      "A non-primary remote LFA FRR (pure) backup path";
  }
  identity route-path-ip-bgp-backup {
    base route-path-type;
    description
      "A non-primary BGP backup path";
  }

  typedef dhc-state {
    type enumeration {
      enum "none" {
        description
          "There is no current Directed Hello Control State.";
      }
      enum "dhc-active" {
        description
          "The Directed Hello is Active.";
      }
      enum "dhc-passive" {
        description
          "The Directed Hello is Passive.";
      }
      enum "dhc-active-passive" {
        description
          "The Directed Hello is both Active and Passive.";
      }
    }
    description
      "This is the Directed Hello Control State Type.";
  }

  identity igp-sync-down-reason {
    description
      "Base identity reason IGP Sync was not achieved.";
  }
  identity igp-sync-down-reason-na {
    base igp-sync-down-reason;
    description
      "Not Applicable.";
  }
  identity igp-sync-down-reason-no-hello-adj {
    base igp-sync-down-reason;
    description
      "No hello adjacency.";
  }
  identity igp-sync-down-reason-no-peer-sess {
    base igp-sync-down-reason;
    description
      "No peer session.";
  }
  identity igp-sync-down-reason-peer-update-not-done {
    base igp-sync-down-reason;
    description
      "Initial update to peer not done yet.";
  }
  identity igp-sync-down-reason-peer-update-not-received {
    base igp-sync-down-reason;
    description
      "Initial update from peer not received yet.";
  }
  identity igp-sync-down-reason-internal {
    base igp-sync-down-reason;
    description
      "Internal reason.";
  }

  typedef igp-sync-state {
    type enumeration {
      enum "isync-ready" {
        description
          "Achieved";
      }
      enum "isync-not-ready" {
        description
          "Not achieved";
      }
      enum "isync-deferred" {
        description
          "Deferred due to interface delay or global
           restart delay";
      }
    }
    description
      "This is the IGP Synchronization State.";
  }

  typedef local-label-state {
    type enumeration {
      enum "local-label-state-none" {
        value 1;
        description
          "None";
      }
      enum "local-label-state-assigned" {
        value 2;
        description
          "Assigned";
      }
      enum "local-label-state-withdrawn" {
        value 3;
        description
          "Withdrawn";
      }
    }
    description
      "This id the MPLS LDP Local Label State Type.";
  }

  typedef af {
    type enumeration {
      enum "ldp-af-none" {
        description
          "No Address Family";
      }
      enum "ldp-af-ipv4" {
        description
          "IPv4 AFI";
      }
      enum "ldp-af-ipv6" {
        description
          "IPv6 AFI";
      }
      enum "ldp-af-ipv4-ipv6" {
        description
          "Both IPv4/IPv6 AFIs";
      }
    }
    description
      "LDP Address Family";
  }

  typedef af-id {
    type enumeration {
      enum "ldp-af-id-none" {
        description

          "No Address Family";
      }
      enum "ldp-af-id-ipv4" {
        description
          "IPv4 AFI";
      }
      enum "ldp-af-id-ipv6" {
        description
          "IPv6 AFI";
      }
    }
    description
      "LDP AF type";
  }

  grouping MSG-COUNTERS {
    description
      "MPLS LDP Session Message Counters Information";
    /* CLI: (XR) show mpls ldp statistics msg-counters */
    leaf total-count {
      type yang:counter32;
      description
        "Total count of all messages.";
    }
    leaf init-count {
      type yang:counter32;
      description
        "Init message count.";
    }
    leaf address-count {
      type yang:counter32;
      description
        "Address message count.";
    }
    leaf address-withdraw-count {
      type yang:counter32;
      description
        "Address withdraw count.";
    }
    leaf label-map-count {
      type yang:counter32;
      description
        "Label map count.";
    }
    leaf label-withdraw-count {
      type yang:counter32;
      description
        "Label withdraw count.";
    }
    leaf label-release-count {
      type yang:counter32;
      description
        "Label release count.";
    }
    leaf label-request-count {
      type yang:counter32;
      description
        "Label request count.";
    }
    leaf label-abort-request-count {
      type yang:counter32;
      description
        "Label abort request count.";
    }
    leaf notification-count {
      type yang:counter32;
      description
        "Notification count.";
    }
    leaf keep-alive-count {
      type yang:counter32;
      description
        "Keepalive count.";
    }
    leaf iccp-rg-conn-count {
      type yang:counter32;
      description
        "ICCP RG Connect count.";
    }
    leaf iccp-rg-disconn-count {
      type yang:counter32;
      description
        "ICCP RG Disconnect count.";
    }
    leaf iccp-rg-notif-count {
      type yang:counter32;
      description
        "ICCP RG Notify count";
    }
    leaf iccp-rg-app-data-count {
      type yang:counter32;
      description
        "ICCP RG App Data count.";
    }
  }

  grouping FWD-RW-PFX-LBL-SUM {
    description
      "MPLS LDP forwarding rewrite prefix next hops
       labeled summary";
    leaf labeled-pfxs {
      type uint16;
      description
        "Count of labeled prefixes with 1 or more paths
         labeled";
    }
    leaf labeled-pfxs-partial {
      type uint16;
      description
        "Count of labeled prefixes with some (but not
         ALL) paths labeled";
    }
    leaf unlabeled-pfxs {
      type uint16;
      description
        "Count of labeled prefixes with ALL paths
         unlabeled";
    }
  }

  grouping FWD-SUMM-INFO {
    description
      "MPLS LDP forwarding summary";
    container pfxs {
      description
        "MPLS LDP forwarding prefix rewrite summary";
      container labeled-pfxs-aggr {
        description
          "Labeled prefix count for all paths";
        uses FWD-RW-PFX-LBL-SUM;
      }
      container labeled-pfxs-primary {
        description
          "Labeled prefix count related to primary paths
           only";
        uses FWD-RW-PFX-LBL-SUM;
      }
      container labeled-pfxs-backup {
        description
          "Labeled prefix count related to backup paths
           only";
        uses FWD-RW-PFX-LBL-SUM;
      }
      leaf total-pfxs {
        type uint16;
        description
          "Total Prefix count";
      }
      leaf ecmp-pfxs {
        type uint16;
        description
          "Count of prefixes with ECMP";
      }
      leaf protected-pfxs {
        type uint16;
        description
          "Count of FRR protected prefixes";
      }
    }
    container nhs {
      description
        "MPLS LDP forwarding rewrite next-hop/path summary";
      leaf total-paths {
        type uint32;
        description
          "Total path count";
      }
      leaf protected-paths {
        type uint32;
        description
          "Count of FRR protected paths";
      }
      leaf backup-paths {
        type uint32;
        description
          "Count of non-primary backup paths";
      }
      leaf remote-backup-paths {
        type uint32;
        description
          "Count of non-primary remote backup paths";
      }
      leaf labeled-paths {
        type uint32;
        description
          "Count of all labeled paths";
      }
      leaf labeled-backup-paths {
        type uint32;
        description
          "Count of labeled backup paths";
      }
    }
    leaf intfs-fwd-count {
      type uint16;
      description
        "MPLS forwarding enabled interface count.";
    }
    leaf local-lbls {
      type uint16;
      description
        "Local label allocated count.";
    }
  }

  grouping LDPID-INFO {
    description
      "MPLS LDP Identifier Information";
    leaf lsr-id {
      type inet:ip-address;
      description
        "LSR identifier";
    }
    leaf label-space-id {
      type uint16;
      description
        "Label space identifier";
    }
  }

  grouping FWD-PATH-MPLS-NH-INFO {
    description
      "Forwarding Path MPLS nexthop info";
    container nexthop-peer-ldp-ident {
      description
        "Nexthop LDP peer";
      uses LDPID-INFO;
    }
    leaf out-label {
      type uint32;
      description
        "Outgoing label";
    }
    leaf out-label-type {
      type identityref {
        base label-type;
      }
      description
        "Outgoing Label Type";
    }
    leaf out-label-owner {
      type identityref {
        base route-path-lbl-owner;
      }
      description
        "Outgoing label owner";
    }
    leaf is-from-graceful-restartable-neighbor {
      type boolean;
      description
        "Is from a GR neighbor";
    }
    leaf is-stale {
      type boolean;
      description
        "Is the entry stale? This may happen during a graceful
         restart.";
    }
  }

  grouping BINDING-SUMM-INFO {
    description
      "MPLS LDP Binding Summary Information";

    leaf binding-total {
      type uint32;
      description
        "Total bindings";
    }
    leaf binding-no-route {
      type uint32;
      description
        "Bindings with no route";
    }
    leaf binding-local-no-route {
      type uint32;
      description
        "Local bindings with no route";
    }
    leaf binding-local {
      type uint32;
      description
        "Number of local bindings";
    }
    leaf binding-local-null {
      type uint32;
      description
        "Number of local null bindings";
    }
    leaf binding-local-implicit-null {
      type uint32;
      description
        "Number of local implicit null bindings";
    }
    leaf binding-local-explicit-null {
      type uint32;
      description
        "Number of local explicit null bindings";
    }
    leaf binding-local-non-null {
      type uint32;
      description
        "Number of local non-null bindings";
    }
    leaf binding-local-oor {
      type uint32;
      description
        "This is the number of local bindings needing label but which
         hit the Out-Of-Resource condition.";
    }
    leaf lowest-allocated-label {
      type uint32;
      description
        "Lowest allocated label";
    }
    leaf highest-allocated-label {
      type uint32;
      description
        "Highest allocated label";
    }
    leaf binding-remote {
      type uint32;
      description
        "Number of remote bindings";
    }
  }

  grouping SUMMARY-COMMON {
    description
      "MPLS LDP/MLDP common summary Information";
    leaf address-families {
      type af;
      description
        "Address Families enabled";
    }
    leaf number-of-neighbors {
      type uint32;
      description
        "Number of neighbor";
    }
    leaf number-of-graceful-restart-neighbors {
      type uint32;
      description
        "Number of Graceful Restart neighbor";
    }
    leaf number-of-downstream-on-demand-neighbors {
      type uint32;
      description
        "Number of Downstream-On-Demand neighbor";
    }
    leaf numberof-ipv4-hello-adj {
      type uint32;
      description
        "Number of LDP discovery IPv4 hello adjacencies";
    }
    leaf number-of-ipv4-routes {
      type uint32;
      description
        "Number of resolved IPv4 routes";
    }
    leaf number-of-ipv4-local-addresses {
      type uint32;
      description
        "Number of IPv4 local addresses.";
    }
    leaf number-of-ldp-interfaces {
      type uint32;
      description
        "Number of LDP configured interfaces";
    }
    leaf number-of-ipv4ldp-interfaces {
      type uint32;
      description
        "Number of LDP IPv4 configured interfaces";
    }
  }

  grouping SUMMARY {
    description
      "MPLS LDP Summarized Information";
    container common {
      if-feature mpls-ldp-extended;
      description
        "Common Summary information";
      uses SUMMARY-COMMON;
    }
    leaf number-of-vrf {
      type uint32;
      description
        "Number of configured VRFs (including default)";
    }
    leaf number-of-vrf-oper {
      type uint32;
      description
        "Number of configured operational VRFs (including
         default)";
    }
    leaf number-of-interfaces {
      type uint32;
      description
        "Number of known interfaces";
    }
    leaf number-of-fwd-ref-interfaces {
      type uint32;
      description
        "Number of Forward Reference interfaces.";
    }
    leaf number-of-autocfg-interfaces {
      type uint32;
      description
        "Number of auto-configured interfaces.";
    }
    leaf no-of-ipv4-rib-tbl {
      type uint32;
      description
        "Total number of ipv4 RIB tables";
    }
    leaf no-of-ipv4-rib-tbl-reg {
      type uint32;
      description
        "Number of ipv4 RIB tables registered";
    }
  }
  grouping CAP-DESC {
    description
      "MPLS LDP Capability Description";

    leaf cap-type {
      type uint16;
      description
        "Capability type (IANA assigned)";
    }
    leaf cap-des {
      type string {
        length "0..80";
      }
      description
        "Capability description";
    }
    leaf capability-data-length { //remove
      type uint16;
      description
        "Capability data length";
    }
    leaf capability-data {
      type string;
      description
        "Capability data";
    }
  }



  grouping ICPM-PR-LIST {
    description
      "This a list of icpm protocols and the accompanyting data.";
    list icpm-protocols {
      key icpm-type;
      description
        "This list contains all active icpm protocols.";
      leaf icpm-type {
        type identityref {
           base icpm-type;
        }
        description
          "ICPM Type.";
      }
      list redun-groups {
        key "rg-id";
        description
          "List of Redundancy Groups";
        leaf rg-id {
          type uint32;
          description
            "Redundancy Group Identifier.";
        }
        leaf peer-id {
          type inet:ip-address;
          description
             "LSR identifier.";
        }
        leaf client_id {
          type uint32;
          description
            "Client Identifier.";
        }
        leaf state {
          type string;
          description
            "ICCP State";
        }
        list iccp-apps {
          key iccp-app;
          description
            "List of apps";
          leaf iccp-app {
            type identityref {
              base iccp-type;
            }
            description
              "ICCP App Type.";
          }
          leaf app-state {
            type iccp-state;
            description
              "App State.";
          }
          leaf ptcl-ver {
            type uint32;
            description
              "ICCP App Protocol Version.";
          }
        } // iccp-apps
      } // redun-groups
    } // icpm-protocols
  } // ICPM-PR-LIST


  grouping ICPM-INFO {
    description
      "LDP ICPM Information.";
    /* Global Statistics */
    leaf iccp-rg-conn-count {
      type uint32;
      description
        "ICCP RG Connect count";
    }
    leaf iccp-rg-disconn-count {
      type uint32;
      description
        "ICCP RG Disconnect count";
    }
    leaf iccp-rg-notif-count {
      type uint32;
      description
        "ICCP RG Notif count";
    }
    leaf iccp-rg-app-data-count {
      type uint32;
      description
        "ICCP RG App Data count";
    }
    container icpm-rgid-table-info {
      description
        "This defines the ICPM RGID Table";
      list red-group {
        key rg-id;
        description
          "This is the data for an individual ICPM Rredundandy
           Group,";
        leaf rg-id {
          type uint32;
          description
            "This is the ICPM RG identifier.";
        }
        uses ICPM-PR-LIST;
      }
    }
    container icpm-session-table {
      description
        "This is a list of ICPM sessions.";
      list session-table {
        key session-id;
        description
          "ICPM LDP Session Table";
        leaf session-id {
          type uint32;
          description
            "This is the ICPM sesion identifier.";
        }
        uses ICPM-PR-LIST;
      }
    } //icpm-session-table
  }

  container mpls-ldp {
    description
      "MPLS LDP configuration and operational data.";

    container mpls-ldp-state {
      config false;
      description
        "MPLS LDP operational data.";

      container oper-summary {
        if-feature mpls-ldp-extended;
        description
          "LDP operational data summary";
        uses SUMMARY;
      }

      container forwarding-summary {
        description
          "Summary information regarding LDP forwarding
           setup";
        uses FWD-SUMM-INFO;
      }

      container bindings-summary {
        description
          "Aggregate counters for the MPLS LDP LIB.";
        uses BINDING-SUMM-INFO;
      }

      container nsr-summary-all {
        if-feature mpls-ldp-nsr;
        description
          "This is the LDP NSR summary for the device.";
        /* CLI (XR, IOS): show mpls ldp nsr statistics */

        leaf nsr-sum-in-label-reqs-created {
          type yang:counter32;
          description
            "In label Request Records created.";
        }
        leaf nsr-sum-in-label-reqs-freed {
          type yang:counter32;
          description
            "In label Request Records freed.";
        }
        leaf nsr-sum-in-label-withdraw-created {
          type yang:counter32;
          description
            "In label Withdraw Records created.";
        }
        leaf nsr-sum-in-label-withdraw-freed {
          type yang:counter32;
          description
            "In label Withdraw Records freed.";
        }
        leaf nsr-sum-lcl-addr-withdraw-set {
          type yang:counter32;
          description
            "Local Address Withdraw set.";
        }
        leaf nsr-sum-lcl-addr-withdraw-cleared {
          type yang:counter32;
          description
            "Local Address Withdraw cleared.";
        }
      }

      container icpm-summary-all {
        if-feature mpls-ldp-iccp;
        description
          "Summary info for LDP ICPM/ICCP.";
        /* CLI (IOS) show mpls ldp iccp */
        uses ICPM-INFO;
      }

      container parameters {
        /* TBD: Once MPLS LDP Confg is done, many of these may
         *  shift containers. */
        description
          "MPLS LDP Global Parameters";
        /* CLI (NXOS, IOS): show mpls ldp parameters */
        leaf global-md5-password-enabled {
          type boolean;
          description
            "Global MD5 password enabled";
        }
        leaf protocol-version {
          type uint32;
          description
            "Protocol version";
        }
        leaf keepalive-interval {
          type uint32;
          units seconds;
          description
            "Keepalive interval in seconds.";
        }
        leaf session-hold-time {
          type uint32;
          units seconds;
          description
            "Session hold time in seconds.";
        }
        leaf le-no-route-timeout {
          type uint32;
          units seconds;
          description
            "LIB entry no route timeout in second.";
        }
        leaf af-binding-withdraw-delay {
          type uint32;
          units seconds;
          description
            "Delay (sec) in Binding Withdrawal for an Address
             Family";
        }
        leaf max-intf-attached {
          type uint32;
          description
            "Maximum number of LDP enabled attached
             interfaces";
        }
        leaf max-intf-te {
          type uint32;
          description
            "Maximum number of LDP enabled TE interfaces";
        }
        leaf max-peer {
          type uint32;
          description
            "Maximum number of LDP peers";
        }
        leaf out-of-mem-state {
          type yang:counter32;
          description
            "This is a counter of the number of times LDP
             attempted to create a label or binding and
             failed due a memory allocation failure.";
        }

        /* CLI (NXOS, IOS) show mpls ldp sync */

        leaf discovery-quick-start-disabled-on-interfaces {
          type boolean;
          description
            "Discovery quick-start disabled on some
             enabled interfaces";
        }
        list address-family-parameter {
          key address-family;
          description
            "Per AF parameters";
          leaf address-family {
            type af;
            description
              "Address Family";
          }
          leaf discovery-transport-address {
            type inet:ip-address;
            description
              "This is the Discovery transport address.";
          }
          leaf is-accepting-targeted-hellos {
            type boolean;
            description
              "Accepting targeted Hellos";
          }
          leaf targeted-hello-filter {
            type string;
            description
              "This contains the filter name for targeted hellos.
               The filter type is device specific and could be
               an ACL, a prefix list, or other mechanism.";
          }
        }

        leaf dod-max-hop {
          type uint32;
          description
            "Maximum number of hops for Downstream-on-Demand.";
        }

        leaf-list feature { //TDB: string or list of identities?
          type string;
          description
            "This entry describes an LDP feature available on the
             device. This does not indicate whether the feature
             is enabled, just the raw ability to support the
             feature. The features may include, but are not
             limited to: 'Auto-Configuration', 'Basic', 'ICPM',
             'IP-over-MPLS', 'IGP-Sync', 'LLAF',
             'TCP-MD5-Rollover', 'TDP', and 'NSR'.";
        }
        leaf loop-detection {
          type loop-detection-type;
          description
            "A indication of whether this LSR has enabled loop
             detection. Since Loop Detection is determined during
             Session Initialization, an individual session
             may not be running with loop detection.  This
             object simply gives an indication of whether or not the
             LSR has the ability enabled to support Loop Detection
             and which types.";
        } // leaf loop-detection
      } // container parameters

      container capabilities {
        description
          "LDP capability database information";
        list capability {
          key cap-type;
          description
            "Information on LDP capability";
          leaf capability-owner {
            type string;
            description
              "Capability owner";
          }
          uses CAP-DESC;
        } // list capability
      } // container capabilities

      container backoff-parameters {
          /* CLI (NXOS,IOS): show mpls ldp parameters
           * ...
           * LDP initial/maximum backoff: 15/120 sec
           * ...
           */
        description
          "MPLS LDP Session Backoff Information";
        leaf initial-seconds {
          type uint32;
          units seconds;
          description
            "Initial backoff value in seconds.";
        }
        leaf maximum-seconds {
          type uint32;
          units seconds;
          description
            "Maximum backoff value in seconds.";
        }

        leaf backoff-seconds {
          type uint32;
          units seconds;
          description
            "Current backoff seconds count.";
        }
        leaf waiting-seconds {
          type uint32;
          units seconds;
          description
            "Current backoff waiting seconds count.";
        }
      } // container backoff-parameters

      container graceful-restart {
          /* CLI (NXOS, IOS) show mpls ldp graceful-restart */
        description
          "MPLS LDP Graceful Restart Information";

        leaf is-graceful-restart-configured {
          type boolean;
          description
            "Is graceful restart configured";
        }
        leaf graceful-restart-reconnect-timeout {
          type uint32;
          units seconds;
          description
            "Reconnect timeout value in seconds.";
        }
        leaf graceful-restart-forwarding-state-hold-time {
          type uint32;
          units seconds;
          description
            "Graceful restart forward state hold time in
             seconds.";
        }
        leaf is-forwarding-state-hold-timer-running {
          type empty;
          description
            "Is graceful restart forwarding state hold timer
             running";
        }
        leaf forwarding-state-hold-timer-remaining-seconds {
          type uint32;
          units seconds;
          description
            "Forwarding state hold timer remaining time in
             seconds";
        }
      } //container graceful-restart

      /*
       * And now the detailed information on a per-vrf basis.
       */
      container vrfs {
        description
          "MPLS LDP per-VRF operational data.";
        list vrf {
          key "vrf-name";
          description
            "MPLS LDP Operational data for a given VRF.";
          leaf vrf-name {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }

          container vrf-summary {
            if-feature mpls-ldp-extended;
            description
              "MPLS LDP per VRF summarized Information";
            uses SUMMARY-COMMON;
          }
          container afs {
            description
              "Address Family specific operational data";
            list af {
              key "af-name";
              description
                "MPLS LDP Operational data for this Address Family.";
              leaf af-name {
                type af;
                description
                  "Address Family name.";
              }
              container interface-summary {
                description
                  "This container holds a summary of information
                   across all interfaces in this AF,";

                leaf known-ip-interface-count {
                  type uint32;
                  description
                    "Number of known IP Interfaces";
                }
                leaf known-ip-interface-ldp-enabled {
                  type uint32;
                  description
                    "Number of known IP Interfaces with LDP Enabled";
                }
                leaf configured-attached-interface {
                  type uint32;
                  description
                    "Number of attached interfaces configured in
                     LDP";
                }
                leaf configured-te-interface {
                  type uint32;
                  description
                    "Number of TE tunnel interfaces configured in
                     LDP";
                }
                leaf forward-references {
                  type uint32;
                  description
                    "Number of forward referenced interfaces";
                }
                leaf auto-config-disabled {
                  type uint32;
                  description
                    "Autoconfigure disabled";
                }
                leaf auto-config {
                  type uint32;
                  description
                    "Auto-configured interfaces.";
                }
                leaf auto-config-forward-reference-interfaces {
                  type uint32;
                  description
                    "Auto-configured forward references";
                }
              } // container interface-summary

              container igp {
                description
                  "LDP IGP Synchronization related information";
                list sync {
                  key "interface";
                  description
                    "LDP-IGP Synchronization related information
                     for an interface";
                  leaf interface {
                    type if:interface-ref;
                    description
                      "This leaf contains the interface name for the
                       IGP Synchronization information.";
                  }
                  leaf igp-sync-state {
                    type igp-sync-state;
                    description
                      "IGP Sync state";
                  }
                  leaf is-delay-timer-running {
                    type empty;
                    description
                      "This is set when the sync delay timer
                       running.";
                  }
                  leaf delay-timer-remaining {
                    type uint32;
                    units seconds;
                    description
                      "Remaining timer (seconds) until expiry of sync
                       delay timer.";
                  }
                  leaf igp-sync-down-reason {
                    type identityref {
                      base igp-sync-down-reason;
                    }
                    description
                      "Reason IGP Sync Not Achieved";
                  }
                  list peers {
                    description
                      "MPLS LDP IGP Sync Interface Peer Information";
                    leaf peer-id {
                      type string;
                      description
                        "Peer Identifier";
                    }
                    leaf is-gr-enabled {
                      type boolean;
                      description
                        "Is GR enabled session";
                    }
                    leaf is-chkpt-created {
                      type empty;
                      description
                        "This is set if this peer was created due to
                         check-pointing";
                    }
                  } // list peers
                }  //list sync
              } //container igp

            } // list af
          } // container afs
        } // list vrf
      } // container vrfs

      container discovery {
        description
          "The LDP Discovery operational state";
        /* CLI: show mpls ldp discovery */
        container discovery-stats {
          description
            "MPLS LDP Discovery Summary Information";
          /* CLI: show mpls ldp discovery summary */
          leaf num-of-ldp-interfaces {
            type uint32;
            description
              "Total Number of LDP configured interfaces.";
          }
          leaf num-of-active-ldp-interfaces {
            type uint32;
            description
              "Number of active LDP enabled interfaces";
          }
          leaf num-of-lnk-disc-xmit {
            type uint32;
            description
              "Number of link hello discoveries in xmit state";
          }
          leaf num-of-tgt-disc-xmit {
            type uint32;
            description
              "Number of targeted hello discoveries in xmit
               state";
          }
          leaf num-of-lnk-disc-recv {
            type uint32;
            description
              "Number of link hello discoveries in recv state";
          }
          leaf num-of-tgt-disc-recv {
            type uint32;
            description
              "Number of targeted hello discoveries in recv
               state";
          }
        } // container discovery-stats

        /* CLI: show mpls ldp discovery detail */
        container link-hello-state {
          description
            "This container holds information for LDP Discovery
             using non-targeted Hellos. These are interface-based
             hellos which form one or more adjacencies for each
             interface and also form adjacencies on multiple
             intefrfaces. Link Hellos can therefore form multiple
             adjacencies with the same peer.";
          list link-hellos {
            key "interface nbr-transport-addr";
            description
              "Each entry represents a single LDP Hello Adjacency.
               An LDP Session can have one or more Hello
               Adjacencies.";
            leaf interface {
              type if:interface-ref;
              description
                "The Discovery Interface";
            }
            leaf nbr-transport-addr {
              type inet:ip-address;
              description
                "This is the MPLS LDP Hello Neighbor transport
                 address.";
            }
            leaf hello-interval {
              type uint32;
              units seconds;
              description
                "Hello interval in seconds. This is the value
                 used to send hello messages.";
            }
            /* CLI (NXOS, IOS) show mpls ldp discovery detail */
            leaf local-src-addr {
              type inet:ip-address;
              description
                "MPLS LDP Discovery Local source address";
            }
            leaf local-transport-addr {
              type inet:ip-address;
              description
                "MPLS LDP Discovery Local transport address";
            }
            leaf nbr-src-addr {
              type inet:ip-address;
              description
                "This is the MPLS LDP Hello Neighbor source
                 address.";
            }
            leaf nbr-ldp-id {
              type string;
              description
                "Neighbor LDP Identifier";
            }
            leaf session-up {
              type empty;
              description
                "Set when the session is up for this adjacency.";
            }
            leaf nbr-hold-time {
              type uint32 {
                range "0..65535";
              }
              description
               "The Hello hold time which is negotiated between
                the Entity and the Peer.  The entity associated
                with this Hello Adjacency issues a proposed
                Hello Hold Time value in the
                EntityHelloHoldTimer object.  The peer
                also proposes a value and this object represents
                the negotiated value.

                A value of 0 means the default,
                which is 15 seconds for Link Hellos
                and 45 seconds for Targeted Hellos.
                A value of 65535 indicates an
                infinite hold time.";
              reference
               "RFC3036, LDP Specification, Section 3.5.2
                Hello Message";
            }
            leaf next-hello {
              type uint32;
              units milliseconds;
              description
                "Next hello due time in milliseconds.";
            }
            leaf hold-time-remaining {
              type uint32 {
                range "0..65535";
              }
              units seconds;
              description
                "This is the MPLS LDP Hello Discovery expiry time
                 in seconds.
                 If the value of this object is 65535,
                 this means that the hold time is infinite
                 (i.e., wait forever).

                 Otherwise, the time remaining for
                 this Hello Adjacency to receive its
                 next Hello Message.

                 This interval will change when the 'next'
                 Hello Message which corresponds to this
                 Hello Adjacency is received unless it
                 is infinite.";
            }
          } // list link-hellos
        } // container link-hello-state (non targeted)

        container targeted-hellos {
          description
            "The LDP Discovery Targeted Hello state.";
          leaf targeted-hello-interval {
            type uint32;
            units seconds;
            description
              "Local Targeted Hello interval in seconds.";
          }
          leaf targeted-hello-hold-time {
            type uint32;
            units seconds;
            description
              "Local Targeted hold time in seconds.";
          }

          list targeted-hello {
            key "vrf-name target-address";
            description
              "The LDP targeted discovery information for a specific
               target. Targetted discovery creates a single adjacency
               between two addresses and not indiviual adjacencies
               across physical interfaces.";
            leaf vrf-name {
              type string;
              description
                "This contains the VRF Name, where 'default' is used
                 for the default vrf.";
            }
            leaf local-address {
              type inet:ip-address;
              description
                "Local IP Address";
            }
            leaf target-address {
              type inet:ip-address;
              description
                "The target IP Address";
            }
            leaf neighbor-ldp-identifier {
              type string;
              description
               "Neighbor LDP Identifier";
            }
            leaf state {
              type dhc-state;
              description
                "This is the MPLS LDP Targeted Hello state.";
            }

            leaf nbr-hold-time {
              type uint32 {
                range "0..65535";
              }
              description
               "The Hello hold time which is negotiated between
                the Entity and the Peer.  The entity associated
                with this Hello Adjacency issues a proposed
                Hello Hold Time value in the
                EntityHelloHoldTimer object.  The peer
                also proposes a value and this object represents
                the negotiated value.

                A value of 0 means the default,
                which is 15 seconds for Link Hellos
                and 45 seconds for Targeted Hellos.
                A value of 65535 indicates an
                infinite hold time.";
              reference
               "RFC3036, LDP Specification, Section 3.5.2
                Hello Message";
            }
            leaf next-hello {
              type uint32;
              units milliseconds;
              description
                "Next hello due time in milliseconds.";
            }
            leaf hold-time-remaining {
              type uint32 {
                range "0..65535";
              }
              units seconds;
              description
                "This is the MPLS LDP Hello Discovery expiry time
                 in seconds.
                 If the value of this object is 65535,
                 this means that the hold time is infinite
                 (i.e., wait forever).

                 Otherwise, the time remaining for
                 this Hello Adjacency to receive its
                 next Hello Message.

                 This interval will change when the 'next'
                 Hello Message which corresponds to this
                 Hello Adjacency is received unless it
                 is infinite.";
            }
          } //list targeted-hello
        } //container targeted-hellos
      } // container discovery

      container forwarding {
        description
          "Summary information regarding LDP forwarding
           setup and detailed LDP Forwarding rewrites";
        container forwarding-vrf-summs {
          description
            "Summary of forwarding info for this VRF.";
          list forwarding-vrf-summ {
            key "vrf-name";
            description
              "Summary of forwarding info for this VRF.";
            leaf vrf-name {
              type string;
              description
                "This contains the VRF Name, where 'default' is used
                 for the default vrf.";
            }
            uses FWD-SUMM-INFO;
          }
        }
        list forwarding-detail {
          key "vrf-name prefix";
          leaf vrf-name {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          description
            "This leaf contain the individual LDP forwarding rewrite
             for a single prefix.";
          leaf prefix {
            type inet:ip-prefix;
            description
              "The IP Prefix";
          }
          leaf fwd-prefix {
            type inet:ip-address;
            description
              "This is the MPLS LDP Forward IP Prefix.";
          }
          container route {
            description
              "MPLS LDP Forwarding Route information";
            leaf version {
              type uint32;
              description
                "Route RIB version.";
            }
            leaf priority {
              type uint8;
              description
                "Route priority";
            }
            leaf source {
              type uint16;
              description
                "Route source protocol Id";
            }
            leaf type {
              type uint16;
              description
                "Route type";
            }
            leaf metric {
              type uint32;
              description
                "Route metric";
            }
            leaf is-local-vrf-leaked {
              type boolean;
              description
                "Is this route leaked across local VRFs?";
            }
            leaf routing-update-count {
              type yang:counter32;
              description
                "Number of routing updates";
            }
            leaf routing-update-timestamp {
              type uint64;
              units nanoseconds;
              description
                "Last Routing update nanosec timestamp";
            }
            leaf routing-update-age {
              type uint64;
              units nanoseconds;
              description
                "Last Routing update nanosec age";
            }
            leaf local-label {
              type uint32;
              description
                "Local label";
            }
            leaf forwarding-update-count {
              type yang:counter32;
              description
                "Number of forwarding updates.";
            }
            leaf forwarding-update-timestamp {
              type uint64;
              units nanoseconds;
              description
                "Last Forwarding update nanosec timestamp.";
            }
            leaf forwarding-update-age {
              type uint64;
              units nanoseconds;
              description
                "Last Forwarding update nanosec age";
            }
          } // container route

          leaf table-id {
            type uint32;
            description
              "Table ID associated with IP prefix";
          }
          leaf prefix-length {
            type uint8;
            description
              "Prefix length";
          }
          list paths {
            description
              "MPLS LDP Forwarding Path info";
            container routing {
              description
                "MPLS LDP Forwarding Path IP Routing information";
              leaf next-hop {
                type inet:ip-address;
                description
                  "This is the Next Hop address.";
              }
              leaf remote-node-id {
                type inet:ip-address;
                description
                  "This is the Remote/PQ node address.";
              }
              leaf has-remote-lfa-bkup {
                type boolean;
                description
                  "This is true if the path has a remote LFA
                   backup.";
              }
              leaf interface {
                type if:interface-ref;
                description
                  "This is the interface.";
              }
              leaf nh-is-overriden {
                type empty;
                description
                  "This is set when the nexthop is overriden
                   by LDP.";
              }
              leaf nexthop-id {
                type uint32;
                description
                  "Nexthop Identifier";
              }
              leaf next-hop-table-id {
                type uint32;
                description
                  "Table ID for nexthop address";
              }
              leaf load-metric {
                type uint32;
                description
                  "Path's load metric for load balancing";
              }
              leaf path-id {
                type uint8;
                description
                  "path Id";
              }
              leaf bkup-path-id {
                type uint8;
                description
                  "Backup path Id";
              }
              leaf path-type {
                type identityref {
                  base route-path-type;
                }
                description
                  "Routing path type";
              }
            } // container routing
            container mpls {
              description
                "MPLS LDP Forwarding Path MPLS information";
              container mpls-outgoing-info {
                description
                  "MPLS nexthop info";
                uses FWD-PATH-MPLS-NH-INFO;
              }
              container remote-lfa {
                description
                  "MPLS LDP Forwarding Path Remote LFA-FRR backup
                   MPLS info";
                container mpls-outgoing-info {
                  description
                    "Remote LFA MPLS nexthop info";
                  uses FWD-PATH-MPLS-NH-INFO;
                }
                leaf has-remote-lfa-bkup {
                  type boolean;
                  description
                    "Whether path has remote LFA backup";
                }
              } // container remote-lfa
            } // container mpls
          } // list paths
        } // list forwarding-detail
      } // container forwarding

      container bindings {
        description
          "The detailed LDP Bindings.";
        container bindings-sum-afs {
          description
            "This container holds the bindings specific to this VRF
             and AF.";
          list binding-sum-af {
            key "vrf-name af-name";
            leaf vrf-name {
              type string;
              description
                "This contains the VRF Name, where 'default' is used
                 for the default vrf.";
            }
            leaf af-name {
              type af;
              description
                "Address Family name.";
            }
            description
              "Counters for the LDP Label Information Base for this
               VRF/AF.";
            uses BINDING-SUMM-INFO;
          }
        }
        list binding {
          key "vrf-name prefix";
          description
            "This list contains the MPLS LDP Label Bindings for each
             IP Prefix. Label bindings provide the local MPLS Label,
             a list of remote labels, any filters affecting
             advertisment of that filter, and a list of neighbors to
             which the label has been advertised.";
          leaf vrf-name {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          /* CLI: IOS, NXOS show mpls ldp binding detail */
          leaf prefix {
            type inet:ip-prefix;
            description
              "This leaf contains the IP Prefix being bound.";
          }
          leaf fwd-prefix {
            type inet:ip-address;
            description
              "This is the MPLS LDP Binding IP Prefix.";
          }
          leaf prefix-length {
            type uint8;
            description
              "This is the MPLS LDP Binding Prefix Length.";
          }
          leaf local-label {
            type uint32;
            description
              "This is the MPLS LDP Binding Local label.";
          }
          leaf le-local-binding-revision {
            type uint32;
            description
              "This is the MPLS LDP Binding Local Binding revision.";
          }
          leaf le-local-label-state {
            type local-label-state;
            description
              "This is the MPLS LDP Binding Local label state.";
          }
          leaf is-no-route {
            type boolean;
            description
              "This is true if the MPLS LDP Binding has no route.";
          }
          leaf label-oor {
            type boolean;
            description
              "This is true if the MPLS LDP Binding Label space is
               depleted, Out Of Resource. No new labels can
               be allocated.";
          }
          leaf advertise-prefix-filter {
            type string;
            description
              "This contains the filter name for this binding's
               prefix. The filter type is device specific and
               could be an ACL, a prefix list, or other mechanism.";
          }
          leaf advertise-lsr-filter {
            type string;
            description
              "This contains the filter name for this binding's
               Advertise LSR. The filter type is device specific
               and could be an ACL, a prefix list, or other
               mechanism.";
          }
          leaf config-enforced-local-label-value {
            type boolean;
            description
              "Config/User enforced local label value";
          }
          list remote-binding {
            description
              "MPLS LDP Remote Binding Information";
            container assigning-peer-ldp-ident {
              description
                "Assigning peer";
              uses LDPID-INFO;
            }
            leaf remote-label {
              type uint32;
              description
                "This is the remote Label.";
            }
            leaf is-stale {
              type boolean;
              description
                "Is the entry stale";
            }
          }
          list peers-advertised-to {
            description
              "Peers to which this entry is advertised.";
            uses LDPID-INFO;
          }
        } // list binding
      } //  container bindings

      container neighbors {
        description
          "The LDP Neighbors Information";
        /* CLI: (NXOS, IOS) show mpls ldp neighbor detail */
        list neighbor {
          key "vrf-name lsr-id";
          description
            "Information on a particular LDP neighbor";
          leaf vrf-name {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          leaf lsr-id {
            type inet:ip-address;
            description
              "LSR ID of neighbor";
          }
          leaf label-space-id {
            type uint32 {
              range "0..65535";
            }
            description
              "Label space ID of neighbor";
          }
          /* CLI (NXOS,IOS): show mpls ldp neighbor */


          leaf session-role {
            type enumeration {
              enum unknown {
                value 1;
                description
                  "The role of this LSR in the session is unknown.";
              }
              enum active {
                value 2;
                description
                "The role of this LSR in the session is active.";
              }
              enum passive {
                value 3;
                description
                  "The role of this LSR in the session is passive.";
              }
            }
            description
             "During session establishment the LSR/LER takes either
              the active role or the passive role based on address
              comparisons.  This object indicates whether this
              LSR/LER was behaving in an active role or passive role
              during this session's establishment.

              The value of unknown(1), indicates that the role is not
              able to be determined at the present time.";
            reference
             "RFC3036, LDP Specification, Section 2.5.3.,
              Session Initialization";
          }

          leaf session-prot-ver {
            type uint32 {
              range "1..65535";
            }
            description
             "The version of the LDP Protocol which
              this session is using.  This is the version of
              the LDP protocol which has been negotiated
              during session initialization.";
            reference
             "RFC3036, LDP Specification, Section 3.5.3,
              Initialization Message.";
          }

          leaf up-time-seconds {
            type uint32;
            units seconds;
            description
              "Up time in seconds";
          }

          leaf nbr-path-vector-limit {
            type int32 {
              range "0..255";
            }
            config false;
            description
             "If the value of this object is 0 (zero) then
              Loop Dection for Path Vectors for this neighor
              is disabled.

              Otherwise, if this object has a value greater than
              zero, then Loop Dection for Path  Vectors for this
              neighbor is enabled and the Path Vector Limit is
              this value.";
            reference
             "RFC3036, LDP Specification, Section 2.8 Loop Dection,
              Section 3.4.5 Path Vector TLV.";
          }

          container nbr-stats {
            description
              "Neighbor Statistics.";

            leaf ta-pies-sent {
              type yang:counter32;
              description
                "Number of MPLS LDP messages sent to this neighbor.";
            }

            leaf ta-pies-rcvd {
              type yang:counter32;
              description
                "Number of MPLS LDP messages received from this
                 neighbor.";
            }

            leaf num-of-nbr-ipv4-discovery {
              type uint32;
              description
                "Number of neighbor IPv4 discovery sources.";
            }
            leaf num-of-nbr-ipv6-discovery {
              type uint32;
              description
                "Number of neighbor IPv6 discovery sources.";
            }
            leaf num-of-nbr-ipv4-addresses {
              type uint32;
              description
                "Number of IPv4 addresses for which the neighbor is
                 advertising labels.";
            }
            leaf num-of-nbr-ipv6-addresses {
              type uint32;
              description
                "Number of IPv6 addresses for which the neighbor is
                 advertising labels.";
            }
            leaf num-of-nbr-ipv4-lbl {
              type uint32;
              description
                "Number of IPv4 labels the neighbor is advertising.";
            }
            leaf num-of-nbr-ipv6-lbl {
              type uint32;
              description
                "Number of IPv6 labels the neighbor is advertising.";
            }
          } // container nbr-stats

          /* CLI: (NXOS, IOS) show mpls ldp neighbor */
          container graceful-restart-adjacency {
            description
              "This container holds the graceful restart information
               for this adjacency.";
            /* CLI: (NXOS, IOS) show mpls ldp neighbor
             *   graceful-restart. */

            leaf is-graceful-restartable {
              type boolean;
              description
                "Is this neighbor graceful restartable?";
            }
            leaf reconnect-timeout {
              type uint32;
              units microseconds;
              description
                "This leaf is the reconnect timeout in
                 microseconds.";
            }
            leaf recovery-time {
              type uint32;
              units microseconds;
              description
                "This leaf is the recovery time in microseconds.";
            }
            leaf is-liveness-timer-running {
              type empty;
              description
                "This is set if the liveness timer is running.";
            }
            leaf liveness-timer-remaining-seconds {
              type uint32;
              units seconds;
              description
                "Remaining time from liveness timer in seconds.";
            }
            leaf is-recovery-timer-running {
              type empty;
              description
                "This is set if the recovery timer is running.";
            }
            leaf recovery-timer-remaining-seconds {
              type uint32;
              units seconds;
              description
                "Recovery timer remaining time in seconds.";
            }
            leaf down-nbr-flap-count {
              type uint32;
              description
                "This is the current count of back-to-back flaps.";
            }
            leaf down-nbr-down-reason {
              type identityref {
                base down-nbr-reason;
              }
              description
                "This identity provides the reason that the LDP
                 Session with this neighbor is down. The reason does
                 not persist if the session was down but is now
                 recovered.";
            }
          } // container graceful-restart-adjacency

          leaf downstream-on-demand {
            type boolean;
            description
              "Is Label advertisement mode in Downstream On
               Demand mode or not?";
          }

          container tcp-information {
            description
              "MPLS LDP Neighbor TCP Information";
            /* CLI (NXOS, IOS) show mpls ldp neighbor
             * Peer LDP Ident: 10.1.1.2:0; Local LDP Ident 10.1.1.1:0
             * TCP connection: 10.1.1.2.18 - 10.1.1.1.66
             * State: Oper; Msgs sent/rcvd: 12/11; Downstream
             * Up time: 00:00:10
             * ...
             */
            leaf foreign-host {
              type inet:ip-address;
              description
                "This is the foreign host address used by TCP.";
            }
            leaf local-host {
              type inet:ip-address;
              description
                "This is the local host address used by TCP.";
            }
            leaf foreign-port {
              type uint16;
              description
                "Foreign port number";
            }
            leaf local-port {
              type uint16;
              description
                "Local port number";
            }
            leaf is-md5-on {
              type boolean;
              description
                "Is MD5 Digest on";
            }
            leaf up-time {
                type string;
                description
                  "up time";
            }
          } //container tcp-information

          container capabilities {
            /* CLI (NXOS, IOS) show mpls ldp neighbor
             *   capabilities */
            description
              "Capabilities sent to and received from neighbor";
            list sent-caps {
              /* CLI (NXOS, IOS) show mpls ldp neighbor
               *                 capabilities
               * ...
               * Capabilities Sent:
               *   [Dynamic Announcement (0x0506)]
               *   [Typed Wildcard (0x050b)]
               * ...
               */
              key cap-type;
              description
                "List of sent capabilities";
              uses CAP-DESC;
            }
            list received-caps {
              /* CLI (NXOS, IOS) show mpls ldp neighbor
               *                capabilities
               * ...
               * Capabilities Received:
               *   [Dynamic Announcement (0x0506)]
               *   [Typed Wildcard (0x050b)]
               * ...
               */
              key cap-type;
              description
                "List of received capabilities";
              uses CAP-DESC;
            }
          }
          leaf peer-hold-time {
            /* CLI (NXOS, IOS) show mpls ldp neighbor detail
             *       holdtime: 15000 ms, hello interval: 5000 ms
             */
            type uint32;
            units seconds;
            description
              "Session holdtime value in seconds from the peer.";
          }
          leaf peer-keep-alive-interval {
            /* CLI (NXOS, IOS) show mpls ldp neighbor detail
             *       holdtime: 15000 ms, hello interval: 5000 ms
             */
            type uint32;
            units seconds;
            description
              "Session keepalive interval in seconds from the peer.";
          }

          leaf peer-state {
            type adj-state;
            description
              "LDP adjacency peer state.";
          }
          leaf inbound-ipv4 {
            /* CLI (NXOS,IOS): show mpls ldp bindings
             *                         advertisement-prefix-list
             * Advertisement spec:
             *    Prefix acl = p1; Peer acl = p2
             */
            type string {
              length "0..80";
            }
            description
              "This contains the IPv4 Inbound accept filter name.
               The filter type is device specific and could be an
               ACL, a prefix list, or other mechanism.";
          }
          leaf inbound-ipv6-filter {
            /* CLI (NXOS,IOS): show mpls ldp bindings
             *                    advertisement-prefix-list */
            type string {
              length "0..80";
            }
            description
              "This contains the IPv6 Inbound accept filter name.
               The filter type is device specific and could be an
               ACL, a prefix list, or other mechanism.";
          }
          leaf outbound-ipv4-filter {
            /* CLI (NXOS,IOS): show mpls ldp bindings
             *                    advertisement-prefix-list */
            type string {
              length "0..80";
            }
            description
              "This contains the IPv4 Outbound advertise filter
               name. The filter type is device specific and could
               be an ACL, a prefix list, or other mechanism.";
          }
          leaf outbound-ipv6-filter {
            /* CLI (NXOS,IOS): show mpls ldp bindings
             *                    advertisement-prefix-list */
            type string {
              length "0..80";
            }
            description
              "This contains the IPv6 Outbound advertise filter
               name. The filter type is device specific and could
               be an ACL, a prefix list, or other mechanism.";
          }
          leaf has-sp {
            type boolean;
            description
              "Session Protection enabled";
          }
          leaf sp-state {
            type string {
              length "0..80";
            }
            description
              "Session Protection state";
          }
          leaf sp-filter {
            type string {
              length "0..80";
            }
            description
              "This contains the Session Protection filter name.
               The filter type is device specific and could be an
               ACL, a prefix list, or other mechanism.";
          }
          /* CLI (NXOS, IOS) show mpls ldp discovery detail */
          leaf sp-has-duration {
            type boolean;
            description
              "Session Protection has non-default duration";
          }
          /* CLI (NXOS, IOS) show mpls ldp discovery detail */
          leaf sp-duration {
            type uint32;
            units seconds;
            description
              "Session protection holdup time duration in
               seconds.";
          }
          /* CLI (NXOS, IOS) show mpls ldp discovery detail */
          leaf spht-running {
            type boolean;
            description
              "Session Protection holdup timer is running";
          }
          /* CLI (NXOS, IOS) show mpls ldp discovery detail */
          leaf spht-remaining {
            type uint32;
            units seconds;
            description
              "Session Protection holdup time remaining value
               in seconds.";
          }
          leaf bgp-advertisement-state {
            if-feature mpls-ldp-bgp;
            type nbr-bgp-advt-state;
            description
              "BGP labeled prefixes advertisement state.";
          }
          leaf advertise-bgp-prefixes {
            if-feature mpls-ldp-bgp;
            type boolean;
            description
              "True if BGP labeled prefixes are advertised to the
               neighbor.";
          }
          leaf-list client {
            type string;
            description
              "Targeted Session clients.";
          }

          leaf-list duplicate-address {
            type inet:ip-address;
            description
              "Duplicate IPv4/IPv6 address bound to this peer";
          }
      
			/* CLI: (NXOS, IOS) show mpls ldp neighbor detail */
			leaf-list nbr-bound-address {
			  type inet:ip-address;
			  description
				"This is the MPLS LDP Neighbor Bound IPv4/IPv6
				 Address.";
			}
		}

        list nbr-adjs {
          description
            "For this Neighbor, this is the list of adjacencies
             between the neighbor and the local node.";
          choice hello-type {
            description
              "This adjacency is either in the form of an interface
               for Hellos or an IP address for Targetted Hellos,
               which are not tied to specific interfaces.";
            case link-hello-type {
              description
                "Shows the MPLS LDP hello state and settings.";
              leaf interface {
                type if:interface-ref;
                description
                  "This is the interface used by MPLS LDP Link
                   Hello.";
              }
            }
            case targeted-hello-type {
              description
                "Show the MPLS LDP Targeted Hello Information.";
              leaf local-address {
                type inet:ip-address;
                description
                  "This is the local address used to send the
                   Targeted Hello.";
              }
              leaf target-address {
                type inet:ip-address;
                description
                  "This is the destination address used to send the
                   Targeted Hello.";
              }
              leaf target-state {
                type dhc-state;
                description
                  "This is the state of this Targeted Hello
                   instance.";
              }
            } // case targeted-hello-type
          } // choice hello-type
        } // list nbr-adjs

        container stats-info {
          description
            "MPLS LDP Statistics Information";
          container message-out {
            /* CLI: (XR) show mpls ldp statistics msg-counters */
            description
              "MPLS LDP message sent counters to this neighbor.";
            uses MSG-COUNTERS;
          }
          container message-in {
            /* CLI: (XR) show mpls ldp statistics msg-counters */
            description
              "MPLS LDP message received counters from this
               neighbor.";
            uses MSG-COUNTERS;
          }
          /* The following stats are from the mpls ldp mib */
          leaf discon-time {
            type yang:timestamp;
            description
             "The value of sysUpTime on the most recent occasion
              at which any one or more of this entity's counters
              suffered a discontinuity.  The relevant counters
              are the specific instances associated with this
              entity of any counter32 object contained
              in the 'EntityStatsTable'.  If no such
              discontinuities have occurred since the last
              re-initialization of the local management
              subsystem, then this object contains a zero
              value.";
          }
          leaf session-attempts {
            type yang:counter32;
            description
             "A count of the Session Initialization messages
              which were sent or received by this LDP Entity and
              were NAK'd.   In other words, this counter counts
              the number of session initializations that failed.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
          }

          leaf sess-reject-no-hello {
            type yang:counter32;
            description
             "A count of the Session Rejected/No Hello Error
              Notification Messages sent or received by
              this LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
          }

          leaf sess-rej-ad {
            type yang:counter32;
            description
             "A count of the Session Rejected/Parameters
              Advertisement Mode Error Notification Messages sent
              or received by this LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
          }

          leaf sess-rej-max-pdu {
            type yang:counter32;
            description
             "A count of the Session Rejected/Parameters

              Max Pdu Length Error Notification Messages sent
              or received by this LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
          }

          leaf sess-rej-lr {
            type yang:counter32;
            description
             "A count of the Session Rejected/Parameters
              Label Range Notification Messages sent
              or received by this LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
          }

          leaf bad-ldpid {
            type yang:counter32;
            description
             "This object counts the number of Bad LDP Identifier
              Fatal Errors detected by the session(s)
              (past and present) associated with this LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
            reference
             "RFC3036, LDP Specification, Section 3.5.1.2.";
          }

          leaf bad-pdu-len {
            type yang:counter32;
            description
             "This object counts the number of Bad PDU Length
              Fatal Errors detected by the session(s)
              (past and present) associated with this LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
            reference
             "RFC3036, LDP Specification, Section 3.5.1.2.";
          }

          leaf bad-msg-len {
            type yang:counter32;
            description
             "This object counts the number of Bad Message
              Length Fatal Errors detected by the session(s)
              (past and present) associated with this LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
            reference
             "RFC3036, LDP Specification, Section 3.5.1.2.";
          }

          leaf bad-tlv-len {
            type yang:counter32;
            description
             "This object counts the number of Bad TLV
              Length Fatal Errors detected by the session(s)
              (past and present) associated with this LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
            reference
             "RFC3036, LDP Specification, Section 3.5.1.2.";
          }

          leaf malformed-tlv-val {
            type yang:counter32;
            description
             "This object counts the number of Malformed TLV
              Value Fatal Errors detected by the session(s)
              (past and present) associated with this
              LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
            reference
             "RFC3036, LDP Specification, Section 3.5.1.2.";
          }

          leaf keep-alive-exp {
            type yang:counter32;
            description
             "This object counts the number of Session Keep Alive
              Timer Expired Errors detected by the session(s)
              (past and present) associated with this LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
            reference
             "RFC3036, LDP Specification, Section 3.5.1.2.";
          }

          leaf shutdown-notif-rec {
            type yang:counter32;
            description
             "This object counts the number of Shutdown Notifications
              received related to session(s) (past and present)
              associated with this LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of
              discon-time.";
          }

          leaf shutdow-notif-sent {
            type yang:counter32;
            description
             "This object counts the number of Shutdown Notfications
              sent related to session(s) (past and present)
              associated with this LDP Entity.

              Discontinuities in the value of this counter can occur
              at re-initialization of the management system, and at
              other times as indicated by the value of

              discon-time.";
          }
        } //container stats-info

        container backoffs {
          description
            "LDP Backoff Information";
          leaf backoff-seconds {
            type uint32;
            units seconds;
            description
              "Current neighbor backoff count in seconds.";
          }
          leaf waiting-seconds {
            type uint32;
            units seconds;
            description
              "Current neighbor backoff waiting count in seconds.";
          }
        } //container backoffs

        container nsr-nbr-detail {
          /* CLI (XR, IOS) show mpls ldp nsr [ pending |
           *                                 statistics ] */
          if-feature mpls-ldp-nsr;
          description
            "This is the LDP NSR state for this neighbor.";

          leaf nsr-state {
            if-feature mpls-ldp-nsr;
            type identityref {
              base nsr-status;
            }
            description
              "Non-Stop Routing State.";
          }

          leaf nsr-nbr-sync-state {
            if-feature mpls-ldp-nsr;
            type identityref {
              base nsr-peer-sync-state;
            }
            description
              "NSR Sync State";
          }

          leaf nsr-nbr-last-sync-error {
            if-feature mpls-ldp-nsr;
            type identityref  {
               base nsr-peer-sync-err;
            }
            description
              "This is the last NSR sync error recieved. It
               indicates the last reason the sync failed
               even if the sync has now succeeded. This
               allows this information to be viewed
               when the state is flapping, even if
               the syncronization is successful at the
               time of the query.";
          }
          leaf nsr-nbr-last-sync-nack-reason {
            if-feature mpls-ldp-nsr;
            type identityref  {
               base nsr-sync-nack-rsn;
            }
            description
              "Last NSR sync NACK reason.";
          }
          leaf nsr-nbr-pend-label-req-resps {
            type yang:counter32;
            description
              "Pending Label-Request responses";
          }
          leaf nsr-nbr-pend-label-withdraw-resps {
            type yang:counter32;
            description
              "Pending Label-Withdraw responses";
          }
          leaf nsr-nbr-pend-lcl-addr-withdraw-acks {
            type yang:counter32;
            description
              "Pending Local Address Withdraw Acks:";
          }
          leaf nsr-nbr-in-label-reqs-created {
            type yang:counter32;
            description
              "In label Request Records created.";
          }
          leaf nsr-nbr-in-label-reqs-freed {
            type yang:counter32;
            description
              "In label Request Records freed.";
          }
          leaf nsr-nbr-in-label-withdraw-created {
            type yang:counter32;
            description
              "In label Withdraw Records created.";
          }
          leaf nsr-nbr-in-label-withdraw-freed {
            type yang:counter32;
            description
              "In label Withdraw Records freed.";
          }
          leaf nsr-nbr-lcl-addr-withdraw-set {
            type yang:counter32;
            description
              "Local Address Withdraw set.";
          }
          leaf nsr-nbr-lcl-addr-withdraw-cleared {
            type yang:counter32;
            description
              "Local Address Withdraw cleared.";
          }
          leaf nsr-nbr-xmit-ctxt-enq {
            type yang:counter32;
            description
              "Transmit contexts enqueued.";
          }
          leaf nsr-nbr-xmit-ctxt-deq {
            type yang:counter32;
            description
              "Transmit contexts dequeued.";
          }

          container nbr-sess {
            description
              "This container holds session information about the
               sessions between these two neighbors.";

            leaf last-stat-change {
              type yang:timestamp;
              description
               "The value of sysUpTime at the time this
                Session entered its current state as
                denoted by the SessionState
                object.";
            }

            leaf state {
              type enumeration {
                enum nonexistent {
                  value 1;
                  description
                    "State: nonexistent.";
                }
                enum initialized {
                  value 2;
                  description
                    "State: initialized.";
                }
                enum openrec     {
                  value 3;
                  description
                    "State: openrec.";
                }
                enum opensent    {
                  value 4;
                  description
                    "State: opensent.";
                }
                enum operational {
                  value 5;
                  description
                    "State: operational.";
                }
              }
              description
               "The current state of the session, all of the
                states 1 to 5 are based on the state machine
                for session negotiation behavior.";
              reference
               "RFC3036, LDP Specification, Section 2.5.4,
                Initialization State Machine.";
            }


            leaf keep-alive-remain {
              type uint32;
              units seconds;
              description
               "The keep alive hold time remaining for
                this session in seconds.";
            }

            leaf keep-alive-time {
              type uint32 {
                range "1..65535";
              }
              units "seconds";
              description
               "The negotiated KeepAlive Time which
                represents the amount of seconds between
                keep alive messages.  The
                EntityKeepAliveHoldTimer
                related to this Session is the
                value that was proposed as the
                KeepAlive Time for this session.

                This value is negotiated during
                session initialization between
                the entity's proposed value
                (i.e., the value configured in
                EntityKeepAliveHoldTimer)
                and the peer's proposed
                KeepAlive Hold Timer value.
                This value is the smaller
                of the two proposed values.";
              reference
               "RFC3036, LDP Specification, Section 3.5.3,
                Initialization Message.";
            }

            leaf max-pdu {
              type uint32 {
                range "1..65535";
              }
              units "octets";
              description
               "The value of maximum allowable length for LDP PDUs
                this session.  This value may have been negotiated
                for during the Session Initialization.  This object
                is related to the EntityMaxPduLength object.  The
                EntityMaxPduLength object specifies the requested
                LDP PDU length, and this object reflects the
                negotiated LDP PDU length between the Entity and
                the Peer.";
              reference
               "RFC3036, LDP Specification, Section 3.5.3,
                Initialization Message.";
            }

            leaf discon-time {
              type yang:timestamp;
              description
               "The value of sysUpTime on the most recent occasion
                at which any one or more of this session's counters
                suffered a discontinuity.  The relevant counters are
                the specific instances associated with this session
                of any counter32 object contained in the
                session-stats table.

                The initial value of this object is the value of
                sysUpTime when the entry was created in this table.

                Also, a command generator can distinguish when a
                session between a given Entity and Peer goes away
                and a new session is established.  This value would
                change and thus indicate to the command generator
                that this is a different session.";
            }

            leaf unknown-mess-err {
              type yang:counter32;
              description
               "This object counts the number of Unknown Message Type
                Errors detected by this LSR/LER during this session.

                Discontinuities in the value of this counter can
                occur at re-initialization of the management system,
                and at other times as indicated by the value of
                discon-time.";
            }

            leaf unknown-tlv {
              type yang:counter32;
              description
               "This object counts the number of Unknown TLV Errors
                detected by this LSR/LER during this session.

                Discontinuities in the value of this counter can
                occur at re-initialization of the management system,
                and at other times as indicated by the value of
                discon-time.";
            }
          } // container nbr-sess
          leaf path-vector-limit {
            type int32 {
              range "0..255";
            }
            description
             "If the value of this object is 0 (zero) then
              Loop Dection for Path Vectors for this Peer
              is disabled.

              Otherwise, if this object has a value greater than
              zero, then Loop Dection for Path  Vectors for this
              Peer is enabled and the Path Vector Limit is this
              value.";
            reference
             "RFC3036, LDP Specification, Section 2.8 Loop Dection,
              Section 3.4.5 Path Vector TLV.";
          }
        } // list neighbor
      } // container neighbors
      container label-ranges {
        description
          "This contaions holds all the label ranges in use
           by this LDP instance.";

        list label-range {
          key "lr-min lr-max";
          description
            "This entry contains a single range of labels
             represented by the configured Upper and Lower
             Bounds pairs.  NOTE: there is NO corresponding
             LDP message which relates to the information
             in this table, however, this table does provide
             a way for a user to 'reserve' a generic label
             range.

             NOTE:  The ranges for a specific LDP Entity
             are UNIQUE and non-overlapping.";

          leaf lr-min {
            type uint32 {
              range "0..1048575";
            }
            // config false;
            description
             "The minimum label configured for this range.";
          }

          leaf lr-max {
            type uint32 {
              range "0..1048575";
            }
            // config false;
            description
             "The maximum label configured for this range.";
          }
        } // list label-range
      } //container label-ranges
    } // container mpls-ldp-state

    /*
     * This container holds the MPLS LDP Configuration.
     */
    container mpls-ldp-config {
      description
        "MPLS LDP Configuration.";

      container global-cfg {
        description
          "This contains hold all MPLS LDP Configuration with Global
           scope. These values affect the entire LSR unless
           overiddden by a parameter with a more localized scope.";
        /*
         * NXOS
         * (config)# mpls ldp configuration
         * (config-ldp)# shutdown
         */
        leaf shutdown {
          type empty;
          description
            "Writing this leaf tears down all LDP sessions, withdraws
             all outgoing labels from the forwarding plane, and frees
             all local labels that have been allocated.";
        }

        leaf enable-nsr {
          if-feature mpls-ldp-nsr;
          type boolean;
          description
            "This leaf controls whether Non-Stop-Routing should
             be enabled to include MPLS LDP.";
        }
        leaf disable-quick-start {
          type boolean;
          description
            "When set to true, disable LDP discovery's quick
             start mode for this LSR.";
        }

        leaf loop-detection {
          type boolean;
          description
            "This leaf enables or disables Loop Detection globally
             for the LSR.";
        }
        leaf admin-status {
          type enumeration {
            enum enable {
              value 1;
              description
                "Enable LDP globablly on this LSR.";
            }
            enum disable {
              value 2;
              description
                "Disable LDP globablly on this LSR.";
            }
          }
          description
            "This leaf controls the administrative status of LDP for
             this LSR. If set to disable, then all LDP activity will
             be disabled and all LDP sessions with peers will
             terminate. The LDP configuration will remain intact.

             When the admin status is set back to 'enable', then
             LDP will resume operations and attempt to establish new
             sessions with the peers.";
        }
        choice pak-priority {
          description
            "This provides options of increasing the LDP packet
             priority. This allows you to set high priority for LDP
             messages sent by a router locally using TCP connections.

             During heavy network traffic, LDP session keepalive
             messages can be dropped from the outgoing interface
             output queue. As a result, keepalives can timeout
             causing LDP sessions to go down.

             Previously established LDP sessions are not affected
             when you change the priority.";

             /*
              * IOS: mpls ldp tcp pak-priority
              * XR:  mpls ldp signalling dscp <0 to 63>
              */
          case dscp {
            description
              "This allows setting the 6-bit Differentiated Services
               Code Point (DSCP) value in the TCP packets for LDP
               messages being sent from the LSR.";
            leaf dcsp-val {
              type uint32 {
                range "0..63";
              }
              description
                "This sets the 6-bit Differentiated Services
                 Code Point (DSCP) value in the TCP packets for LDP
                 messages being sent from the LSR.";
            }
          }
          case internal {
            description
              "This sets the priority within the LSR for TCP packets
               for LDP messages being sent from the LSR.";
            leaf high-priority {
              type boolean;
              description
                "This sets the priority within the LSR for TCP
                 packets for LDP messages being sent from the LSR.
                 They are given a higher transmission priorty and
                 will avoid being queued behind lower priority
                 messages.";
            }
          }
        }
        choice igp-sync-delay-val {
          /* CLI XR: mpls ldp igp sync delay on-session-up <sec> */
          description
            "This leaf sets the delay in IGP synch up after session
             up for the entire LSR unless overidden for a specific
             interface.
             By default, LDP declares LDP sync up as soon as all the
             requisite conditions are met, namely:

               LDP session is up.
               LDP has sent all its label bindings to at least one
                   peer.
               LDP has received at least one label binding from a
                   peer.

             This minimizes traffic loss on link up but can still
             lead to substantial traffic loss under certain
             circumstances (for example, when interoperating with
             an LSR with ordered mode operation). It may be necessary
             to delay declaration of sync up after the session comes
             up by configuring a timeout period.
             When the graceful-restart event is configured, the IGP
             sync delay timer does not take effect.";
          case timer {
            leaf seconds {
              type uint32 {
                range "5..300";
              }
              units "second";
              description
                "Time in seconds to delay IGP sync after session
                 comes up";
            }
          }
          case disable {
            leaf disable-delay {
              type empty;
              description
                "This choice causes IGP sync up immediately upon
                 session up.";
            }
          }
        }

        choice igp-sync-delay-proc {
          /* CLI XR:
           *   mpls ldp igp sync delay on-proc restart <secs> */
          description
            "This leaf enables a process-level delay for IGP
             synchronization events when the LDP fails or restarts.
             This delay defers the sending of sync-up events to the
             IGP until most or all the LDP sessions converge and also
             allows the LDP to stabilize. This allows the LDP process
             failure to be less stressful because IGPs receive all
             the sync-up events in bulk. This means that the IGP is
             required to run the shortest path first (SPF) and
             link-state advertisements (LSAs) only one time with an
             overall view of the sync-up events.";
          case timer {
            leaf seconds-delay-proc {
              type uint32 {
                range "5..300";
              }
              units "second";
              description
                "Time in seconds to delay IGP sync after session
                 comes up";
            }
          }
          case disable {
            leaf disable-delay-proc {
              type empty;
              description
                "This choice causes IGP sync up immediately upon
                 session up.";
            }
            description
              "This choice causes IGP sync up immediately upon
               session up.";
          }
        }

        list router-id {
          key vrf-name;
          description
            "Configuration for LDP Router ID (LDP ID)";
          leaf vrf-name {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          choice router-id-val {
            description
              "This choice provides the LSR ID value either as an
               IP address or through an interface.";
            case interface  {
              description
                "This case provides the LSR ID through an
                 interface.";
              leaf lsr-id-if {
                type if:interface-ref;
                description
                  "This defines the interface to use for the LDP LSR
                   identifier address for all sessions. The IP
                   address of this interface will be used as the
                   identifier.";
              }
            }
            case ip-address {
              description
                "This case provides the LSR ID through an
                 interface.";
              leaf lsr-id-ip {
                type inet:ip-address;
                description
                  "This is the IP address to be used as the LDP
                   LSR ID for all sessions.";
              }
            }
          } // choice router-id-val
          leaf force {
            type empty;
            description
              "Force the router to use the specified identifier
               as the router ID more quickly.";
          }
        } // list router-id
        container session {
          description
            "Configure session parameters. Session parameters effect
             the session between LDP peers once the session has been
             established.";

          list downstream-on-demand {
            key vrf-name;
            description
              "This container holds config for Downstream on Demand.
               For it to be enabled, the Downstream on demand
               feature has to be configured on both peers of the
               session. If only one peer in the session has
               downstream-on-demand feature configured, then the
               session does not use downstream-on-demand mode.
               If, after, a label request is sent, and no remote
               label is received from the peer, the router will
               periodically resend the label request. After the
               peer advertises a label after receiving the label
               request, it will automatically readvertise the label
               if any label attribute changes subsequently.";
            leaf vrf-name {
              type string;
              description
                "This contains the VRF Name, where 'default' is used
                 for the default vrf.";
            }
            leaf enabled {
              type boolean;
              description
                "Enable Downstream on Demand for this LSR. In this
                 mode a label is not advertised to a peer, unless
                 the peer explicitly requests it. At the same time,
                 since the peer does not automatically advertise
                 labels, the label request is sent whenever the
                 next-hop points out to a peer that no remote label
                 has been assigned.";
            }
            leaf filter {
              type string;
              description
                "This filter contains a list of peer IDs that are
                 configured for downstream-on-demand mode. When the
                 filter is changed or configured, the list of
                 established neighbors is traversed. If a session's
                 downstream-on-demand configuration has changed, the
                 session is reset in order that the new
                 down-stream-on-demand mode can be configured. The
                 reason for resetting the session is to ensure that
                 the labels are properly advertised between the
                 peers. When a new session is established, the ACL
                 is verified to determine whether the session should
                 negotiate for downstream-on-demand mode. If the
                 filter string is configured and the corresponding
                 filter does not exist or is empty, then
                 downstream-on-demand mode is not configured for any
                 neighbor.
                 The filter type is device specific and could be an
                 ACL, a prefix list, or other mechanism.";
            }
          }  // list downstream-on-demand

          /*
           * XR/IOS/NXOS [mpls ldp] backoff <initial> <maximum>
           */
          leaf backoff-init {
            type uint32;
            units seconds;
            default "15";
            description
              "Initial session backoff time (seconds).
               The LDP backoff mechanism prevents two incompatibly
               configured label switch routers (LSRs) from engaging
               in an unthrottled sequence of session setup failures.

               For example, an incompatibility arises when two
               neighboring routers attempt to perform LC-ATM
               (label-controlled ATM) but the two are using different
               ranges of VPI/VCI values for labels.

               If a session setup attempt fails due to an
               incompatibility, each LSR delays its next attempt
               (that is, backs off), increasing the delay
               exponentially with each successive failure until the
               maximum backoff delay is reached.

               The default settings correspond to the lowest settings
               for initial and maximum backoff values defined by the
               LDP protocol specification. You should change the
               settings from the default values only if such settings
               result in undesirable behavior.";
          }
          leaf backoff-max {
            type uint32;
            units seconds;
            default "15";
            description
              "The maximum session backoff time (seconds)
               The LDP backoff mechanism prevents two incompatibly
               configured label switch routers (LSRs) from engaging
               in an unthrottled sequence of session setup failures.

               For example, an incompatibility arises when two
               neighboring routers attempt to perform LC-ATM
               (label-controlled ATM) but the two are using different
               ranges of VPI/VCI values for labels.

               If a session setup attempt fails due to an
               incompatibility, each LSR delays its next attempt
               (that is, backs off), increasing the delay
               exponentially with each successive failure until the
               maximum backoff delay is reached.

               The default settings correspond to the lowest settings
               for initial and maximum backoff values defined by the
               LDP protocol specification. You should change the
               settings from the default values only if such settings
               result in undesirable behavior.";
          }

          /*
           * XR/IOS/NXOS [mpls ldp] holdtime <seconds>
           */
          choice hold-time {
            description
              "This contains the hold time, with is the time, in
               seconds, an LDP session is maintained in the
               absence of LDP messages from the session peer.
               the time may be specified in seconds or as infinite.

               When an LDP session is established between two LSRs,
               the hold time used for the session is the lower of
               the values configured on the two LSRs.

               The session hold time is separate from the discovery
               holdtime. The discovery hold time covers the
               hello based and targetted-hello based mechanism for
               peer reachability. This session hold time based covers
               the TCP session. Peer state will be maintained for
               this hold time even in the face of discovery
               timeout.";
            case seconds {
              leaf seconds {
                type uint16;
                description
                  "Number from 15 to 2147483, that defines the time,
                   in seconds, an LDP session is maintained in the
                   absence of LDP messages from the session peer.";
              }
            }
            case infinite {
              leaf infinite {
                type boolean;
                description
                  "If set to true, the session is held indefinitely
                   in the absence of LDP messages from the peer.";
              }
            }
          } //choice holdtime
          container protection {
            description
              "Configure Session Protection parameters";
            leaf enable-prot {
              type boolean;
              description
                "This is set true to enable session protection.";
            }
            leaf peer-filter {
              type string;
              description
                "This is an optional filter to restrict session
                 protection. If the string is null or unconfigured
                 then session protection applied to all peers. The
                 filter type is device specific and could be an ACL,
                 a prefix list, or other mechanism.";
            }
            choice duration {
              description
                "The duration may either be a value in seconds or
                 infinite.";
              case finite {
                description
                  "The holdup duration is finite and specified in the
                   seconds leaf.";
                leaf seconds {
                  type uint32 {
                    range "30..2147483";
                  }
                  description
                    "This is the sessiom holdup duration in
                     seconds.";
                }
              }
              case infinite {
                description
                  "The holdup duration is infinite";
                leaf inf {
                  type empty;
                  description
                    "This sessiom holdup duration is infinite.";
                }
              }
            } //choice duration
          } // container protection
        } // container session

        container per-af {
          description
            "This container holds the global per address family
             configuration.";
          list af-cfg {
            key "vrf-name af-name";
            description
              "This container holds the global per address family
               configuration.";
            leaf vrf-name {
              type string;
              description
                "This contains the VRF Name, where 'default' is used
                 for the default vrf.";
            }
            leaf af-name {
              type af;
              description
                "Address Family name.";
            }
            leaf default-route {
              /*
               * IOS/NXOS [mpls ip] default-route
               * XR mpls ldp address-family <af> label local
               *     default-route
               *   Allow MPLS forwarding for ip default route
               */
              type boolean;
              description
                "When set true, this enables MPLS forwarding for the
                 ip default route.";
            }
            choice disc-trans-addr {
              description
                "This sets the Discovery transport address.
                 Establishing an LDP session between two routers
                 requires a session TCP connection. To establish the
                 session TCP connection, each router must know the
                 transport address (IP address) of the other router.
                 The LDP discovery mechanism provides the means for
                 a router to advertise transport addresses. The
                 transport address may be implicit or explicit.
                 Implicit addresses do not appear as part of the
                 contents of the discovery hello messages sent to the
                 peer. If explicit, the advertisement appears as part
                 of the contents of discovery hello messages sent to
                 the peer.
                 The discovery transport-address command modifies the
                 default behavior described above. Using the
                 interface option, LDP advertises the IP address of
                 the interface in LDP discovery hello messages sent
                 from the interface. Using the ip-address argument,
                 LDP advertises the IP address in LDP discovery
                 hello messages sent from the interface.";
              case exp-addr {
                leaf ipaddr {
                  type inet:ip-address;
                  description
                    "Advertise this address as the explicit address
                     in LDP discovery hello messages and use it
                     for LDP transport.";
                }
              }
              case exp-int {
                leaf interface {
                  type if:interface-ref;
                  description
                    "Advertise this interface's address as the
                     explicit address in LDP discovery hello messages
                     and use it for LDP transport.";
                }
              }
              case imp-addr {
                leaf implicit {
                  type empty;
                  description
                    "Do not advertise an explicit address in LDP
                     discovery hello messages or advertise a default
                     address. Use the default address for LDP
                     transport.";
                }
              }
            } // choice disc-trans-addr
          } // list af-cfg
        } // container per-af
        /* CLI (IOS) mpls label protocol {ldp | tdp | both}  */
        leaf protocol {
          type enumeration {
            enum "ldp" {
              value 1;
              description
               "This LSR should use the LDP tagging protocol.";
            }
            enum "tdp" {
              value 2;
              description
               "This LSR should use the TDP tagging protocol.";
            }
            enum "both" {
              value 3;
              description
               "This LSR should use the both LDP and TDP tagging
                protocol.";
            }
          }
          description
            "This leaf defines the protocol to be used. The default
             is LDP.";
        }
        leaf init-sess-thresh {
          type int32 {
            range "0..100";
          }
          description 
           "When attempting to establish a session with
            a given Peer, the given LDP Entity should
            send out the YANG notification,
            'init-sess-thresh-ex', when
            the number of Session Initialization messages
            sent exceeds this threshold.
            
            The notification is used to notify an
            operator when this Entity and its Peer are
            possibly engaged in an endless sequence
            of messages as each NAKs the other's
            
            Initialization messages with Error Notification
            messages.  Setting this threshold which triggers
            the notification is one way to notify the
            operator.  The notification should be generated
            each time this threshold is exceeded and
            for every subsequent Initialization message
            which is NAK'd with an Error Notification
            message after this threshold is exceeded.
            
            A value of 0 (zero) for this object
            indicates that the threshold is infinity, thus
            the YANG notification will never be generated.";
          reference   
           "RFC3036, LDP Specification,
            Section 2.5.3 Session Initialization.";
        }
      } //container global-cfg

      container nbr-table {
        description
          "This container holds the list of neighbor configuration
           parameters.";
        list nbr-cfg {
          key "nbr-vrf nbr-ip";
          description
            "This entry holds the configuration of a single neighbor
             identified by the IP address of that neighbor.";
          leaf nbr-vrf {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          leaf nbr-ip {
            type inet:ip-address-no-zone;
            description
              "The IP address for the LDP neighbor. This may be
               IPv4 or IPv6.";
          }
          leaf admin-status {
            /* MIB-ONLY */
            type enumeration {
              enum enable  {
                value 1;
                description
                 "Set the administrative status of this neighbor
                  to enabled.";
              }
              enum disable {
                value 2;
                description
                 "Set the administrative status of this neighbor
                  to disabled.";
              }
            }
            description
             "The administrative status of this neighbor.
              If this object is changed from 'enable' to 'disable'
              and this entity has already attempted to establish
              contact with a neighbor, a 'tear-down' for that session
              is issued and the session and all information related
              to that session ceases to exist).

              When the admin status is set back to 'enable', then
              this Entity will attempt to establish a new session
              with the neighbor.";
          }
          /*
           * XR/IOS/NXOS
           *   [mpls ldp] neighbor 1.2.3.4 implicit-withdraw
           */
          leaf implicit-withdraw {
            type boolean;
            description
              "Enable LDP implicit withdraw label for this peer.";
          }

          /*
           * XR: mpls ldp address-family <af> neighbor <ip-addr>
           *            targeted
           * NXOS: neighbor 1.2.3.4 targeted
           * IOS: [mpls ldp] [ vrf vrfname ] ip-address targeted
           *            [ ldp | tdp ]
           */
          leaf targeted {
            type boolean;
            description
              "Establish or delete a targeted session.";
          }
          /*
           * IOS: [mpls ldp] [ vrf vrfname ] ip-address targeted
           *            [ ldp | tdp ]
           */
          leaf label-protocol {
            type enumeration {
              enum "ldp" {
                value 1;
                description
                 "This LSR should use the LDP tagging protocol.";
              }
              enum "tdp" {
                value 2;
                description
                 "This LSR should use the TDP tagging protocol.";
              }
            }
            description
              "This leaf defines the protocol to be used. The default
               is LDP.";
          }
          /*
           *
           * XR
           * (config)# ipv4 prefix-list pfx_acl_1
           * (config-ipv4_pfx)# 10 permit 10.0.0.0/8 le 32
           * (config)# mpls ldp
           * (config-ldp)# label accept for pfx_acl_1 from \
           *                  192.168.1.1
           * (post 5.3.0) mpls ldp address-family <af> label remote
           *              accept from <ldp-id> for <pfx-acl>
           *
           * IOS
           * (config)# ip access-list standard 1
           * (config-std-nacl)# permit 10.0.0.0
           * (config-std-nacl)# exit
           * (config)# mpls ldp neighbor 10.12.12.12 labels accept 1
           *
           * NXOS
           * (config)# ip prefix-list p1 permit 10.0.0.0/32
           * (config-ldp)# neighbor 10.12.12.12 labels accept p1
           */
          leaf label-binding-filter {
            type string;
            description
              "Accept only labels matching this filter.
               The filter type is device specific and could be an
               ACL, a prefix list, or other mechanism.";
          }

          /*
           * XR/IOS/NXOS:
           *   [mpls ldp] neighbor 1.2.3.4 password 0 passwd
           */
          leaf password {
            type string; //TBD really want crypt-hash;
            description
              "Enables password authentication and stores the
               password using a cryptographic hash.";
          }
        } // list nbr-cfg
      } // container nbr-table
      container passwords {
        description
          "This holds the MPLS LDP password configuration for use
           with LDP neighbors.";
        /* CLI xr:
         *  mpls ldp [ neighbor <ldp-id> ] password { clear |
         *     encrypted } password
         * IOS:
         *  mpls ldp neighbor  [ vrf vrfname ] ip-address password
         *     [ 0 | 7 ] password
         *  mpls ldp password required [for ip-acl]
         *  mpls ldp password option <number> for <ip-acl>
         *     { key-chain <keychain-name> | [ 0 | 7 ] <password> }
         *  mpls ldp password fallback { key-chain <keychain-name>
         *     | [ 0 | 7 ] <password> }
         */
        list password {
          key "nbr-vrf nbr-id password-num";
          description
            "This holds the MPLS LDP password configuration for use
             with a single LDP neighbor or group of LDP neighbors.";
          leaf nbr-vrf {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          leaf nbr-id {
            type union {
              type inet:ip-address; /* lsr-id */
              type string; /*filter */
            }
            description
              "This leaf holds the neighbor id for this password.
               This id may be an lsr-id, an ip-address, or
               a filter describing a group of neighbors.";
          } //leaf nbr-id
          leaf password-num {
            type uint32;
            description
              "This is a user-assigned unique number identifying a
               password for this neighbor or group of neighbors.
               Multiple passwords may be assigned to a neighbor.
               If that is the case, each password is tried starting
               with the lowest number to the highest until a
               passsword matches or the list is exhausted.";
          }
          leaf pass-required {
            type boolean;
            description
              "This leaf is set true if the password is required
               and false if the password is not required.";
          }
          choice password {
            description
              "This is the password for this neighbor or group of
               neighbors.";
            case clear {
              leaf clear-pass {
                type string;
                description
                  "This is a clear-text (non-encrypted password to be
                   used with the neighbor.";
              }
            }
            case encrypt {
              leaf encrypt-pass {
                type string;
                description
                  "This is an encrypted password to be used with the
                   neighbor.";
              }
            }
            case keychain {
              leaf keychain-pass {
                type string;
                description
                  "This is a keychain identifier, which identifies
                   an separately configured keychain to be used with
                   the neighbor neighbor.";
              }
            }
          } // choice password
        } // list password
      } //container passwords

      container session {
        description
          "Configure session parameters";

        /*
         * XR/IOS/NXOS [mpls ldp] backoff <initial> <maximum>
         */
        leaf backoff {
          type uint32;
          default "15";
          description
            "Initial session backoff time (seconds)";
        }

        /*
         * XR/IOS/NXOS [mpls ldp] holdtime <seconds>
         */
        choice holdtime {
          description
            "This contains the hold time, which can either be in
             seconds or infinite.";
          case seconds {
            leaf seconds {
              type uint16;
              description
                "Session holdtime in seconds";
            }
          }
          case infinite {
            leaf infinite {
              type empty;
              description
                "Ignore LDP session holdtime";
            }
          }
        }
      } // container session

      container label-cfg {
        description
          "This container holds the label allocation and
           advertisement configuration for the LDP Label Information
           Base. These control what prefixes may be allocated and
           advertised to peers.";
        list label-af-cfg {
          key "vrf-name af-name";
          description
            "This is an allocation filter and advertisement filters
             for LDP labels in this address family.";

          leaf vrf-name {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          leaf af-name {
            type af;
            description
              "Address Family name.";
          }
          choice alloc-filter {
            description
              "MPLS LDP Binding local label allocation filter for
               this address family.";
            case prefix {
              leaf prefix-filter {
                type string {
                  length "0..64";
                }
                description
                  "This contains the filter name for this label's
                   prefix. The filter type is device specific and
                   could be an ACL, a prefix list, or other
                   mechanism.";
              }
            }
            case host-route-only {
              leaf host-route-enable {
                type boolean;
                description
                  "True if this LSR should allocate host-routes
                   only.";
              }
            }
          } // choice alloc-filter

          list advt-filter {
            key "prefix-filter peer-filter interface";
            description
              "MPLS LDP Label advertisement filter restrictions.";
            leaf prefix-filter {
              type string {
                length "0..64";
              }
              description
                "This contains the filter name for this label's
                 prefix.  The filter type is device specific and
                 could be an ACL, a prefix list, or other
                 mechanism.";
            }
            leaf peer-filter {
              type string {
                length "0..64";
              }
              description
                "This contains the filter name for this label's
                 Peer. The filter type is device specific and could
                 be an ACL, a prefix list, or other mechanism.";
            }
            leaf interface {
              type if:interface-ref;
              description
                "This is an optional interface that may be used to
                 restrict the scope of the label advertisement.";
            }
            leaf adv-label-cfg {
              type adv-label-type;
              description
                "This leaf controls what type of label is advertised
                 for matching prefixes to the matching peers.";
            }
          } // list advt-filter
        } //list label-af-cfg
      } // container label-cfg

      container discovery {
        description
          "LDP discovery";

        container link-hello {
          description
            "This container holds the parameters for the non-targeted
             link hello.";
          /*
           * XR/IOS/NXOS
           *    [mpls ldp] discovery hello holdtime <seconds>
           */
          leaf holdtime {
            type uint16;
            description
              "LDP discovery link hello holdtime in seconds";
          }

          /*
           * XR/IOS/NXOS:
           *  [mpls ldp] discovery hello interval <seconds>
           */
          leaf interval {
            type uint16;
            description
              "LDP discovery link hello interval in seconds";
          }
        }

        container targeted-hello {
          description
            "This container holds the parameters for the targeted
             link hello.";
          /*
           * XR/IOS/NXOS:
           *   [mpls ldp] discovery targeted-hello holdtime <seconds>
           */
          leaf holdtime {
            type uint16;
            description
              "LDP discovery targeted hello holdtime in seconds.";
          }

          /*
           * XR/IOS/NXOS:
           *   [mpls ldp] discovery targeted-hello interval <seconds>
           */
          leaf interval {
            type uint16;
            description
              "LDP discovery targeted hello interval in seconds.";
          }

            leaf enable {
              type boolean;
              description
                "Set to true if targeted hello messages may be
                 accepted.";
            }

          /*
           * XR mpls ldp address-family <af> discovery targeted-hello
           *        accept [ from <acl> ]
           * IOS/NXOS:
           *   [mpls ldp] discovery targeted-hello \
           *                accept [from <acl name or #>]
           */
          container accept {
            description
              "Enables router to respond to requests for targeted
               hello messages";
            leaf enable {
              type boolean;
              description
                "Set to true if targeted hello messages may be
                 accepted.";
            }
            leaf src-filter {
              type string;
              description
                "Only respond to requests for targeted hello messages
                 from sources matching this filter.
                 The filter type is device specific and could be
                 an ACL, a prefix list, or other mechanism.";
            }
          } // container accept
        } // container targeted-hello
        leaf instance-tlv {
          /*
           * CLI (XR-only) discovery instance-tlv disable
           */
          type boolean;
          description
            "Set this leaf to true to disable transmit and receive
             processing for Type-Length-Value (TLV) in the discovery
             messages.";
        }
        container int-trans-addrs {
          description
            "This list contains the per-interface transport
             addresses, which overide the global and default
             values.";
          list int-trans-addr {
            key "af-name int-name";
            description
              "This entry contains the per-interface transport
               addresses, which overide the global and default
               values.";
            leaf af-name {
              type af;
              description
                "Address Family name.";
            }
            leaf int-name {
              type if:interface-ref;
              description
                "The Interface Name";
            }
            choice disc-trans-addr-int {
              description
                "This sets the Discovery transport address for
                 this interface and address family..
                 Establishing an LDP session between two routers
                 requires a session TCP connection. To establish the
                 session TCP connection, each router must know the
                 transport address (IP address) of the other router.
                 The LDP discovery mechanism provides the means for
                 a router to advertise transport addresses.
                 The discovery transport-address command modifies the
                 default behavior described above. Using the
                 interface option, LDP advertises the IP address of
                 the interface in LDP discovery hello messages sent
                 from the interface. Using the ip-address argument,
                 LDP advertises the IP address in LDP discovery
                 hello messages sent from the interface.";
              case addr {
                leaf trans-ip {
                  type inet:ip-address;
                  description
                    "Advertise this address as the address in LDP
                     discovery hello messages and use it for LDP
                     transport.";
                }
              }
              case int {
                leaf trans-int {
                  type if:interface-ref;
                  description
                    "Advertise this interface's address as the
                     address in LDP discovery hello messages
                     and use it for LDP transport.";
                }
              }
            } // choice disc-trans-addr-int
          } // list int-trans-addr
        } // container int-trans-addrs
      } // container discovery


      container graceful-restart {
        description
          "Configure LDP Graceful Restart";
        /* CLI: graceful-restart [timers {forwarding-holding seconds
         *      | max-recovery seconds | neighbor-liveness seconds}]
         */
        leaf is-graceful-restartable {
          type boolean;
          description
            "Enable graceful restartable.";
        }
        leaf forwarding-holding {
          type uint32 {
            range "5..300";
          }
          units seconds;
          description
            "Specifies the amount of time the MPLS LDP forwarding
             state must be preserved after the control plane
             restarts.";
        }
        leaf max-recovery {
          type uint32 {
            range "5..300";
          }
          units seconds;
          description
            "Amount of time (in seconds) that the router should hold
             stale label-FEC bindings after an LDP session has been
             reestablished.";
        }
        leaf nbr-liveness {
          type uint32 {
            range "5..300";
          }
          units seconds;
          description
            "Amount of time (in seconds) that the router must wait
             for an LDP session to be reestablished.";
        }
        list helper {
          key "helper-vrf helper-filter";
          description
            "This contains the filter name for peers for which this
             LSR will act as a graceful-restart helper.";
          leaf helper-vrf {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          leaf helper-filter {
            type string {
              length "0..64";
            }
            description
              "This contains the filter name for peers for which this
               LSR will act as a graceful-restart helper.
               The filter type is device specific and could be an
               ACL, a prefix list, or other mechanism.";
          }
        } // list helper
      } // container graceful-restart

      container logging {
        description
          "Enable LDP logging";
        leaf graceful-restart {
          type boolean;
          description
           "Enable logging of graceful-restart messages.";
        }
        leaf neighbor {
          type boolean;
          description
           "Enable logging of neighbor messages.";
        }
        leaf nsr {
          type boolean;
          description
           "Enable logging of nsr messages.";
        }
        leaf adjacency {
          type boolean;
          description
           "Enable logging of adjacency messages.";
        }
        leaf session-protection {
          type boolean;
          description
           "Enable logging of session-protection messages.";
        }
        container password {
          description
           "Enable logging of password messages.";
          container config-msg {
            description
              "Log MPLS LDP password configuration changes.";
            leaf enable {
              type boolean;
              description
                "Log MPLS LDP password configuration changes.";
            }
            leaf rate-limit {
              type uint32;
              description
                "This is the number of messages per minute to limit
                 the logging. A value of 0 indicates no limits on
                 the number of logged messages.";
            }
          } // container config-msg
          container rollover-msg {
            description
              "Log MPLS LDP password rollover messages.";
            leaf enable {
              type boolean;
              description
                "Log MPLS LDP password rollover messages.";
            }
            leaf rate-limit {
              type uint32;
              description
                "This is the number of messages per minute to limit
                 the logging. A value of 0 indicates no limits on
                 the number of logged messages.";
            }
          } // container rollover-msg
        } // container password
      } // container logging

      container interfaces {
        description
          "MPLS LDP Interface configuration commands.";
        list interface {
          key "vrf interface";
          description
            "MPLS LDP Interface configuration commands. Where a
             corresponding global configuration command exists, the
             interface level command will take precedence when
             configured.";

          leaf vrf {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          leaf interface {
            type if:interface-ref;
            description
              "The Interface Name";
          }

          leaf link-hello-int {
            type uint32;
            units "second";
            default "5";
            description
              "LDP discovery link hello interval in seconds for this
               interface. This value overides the global setting.";
          }
          leaf link-hello-hold {
            type uint32;
            units "second";
            default "15";
            description
              "LDP discovery link hello holdtime in seconds for this
               interface. This value overides the global setting.";
          }

          leaf disable-quick-start-int {
            type boolean;
            description
              "When set to true, disable LDP discovery's quick
               start mode for this interface.";
          }
          choice igp-sync-delay {
            /* CLI XR/IOS/NXOS:
             * mpls ldp igp sync delay on-session-up <sec>
             */
            description
              "This leaf sets the delay in IGP synch up after session
               up for this interface.
               By default, LDP declares LDP sync up as soon as all
               the requisite conditions are met, namely:

                 LDP session is up.
                 LDP has sent all its label bindings to at least one
                     peer.
                 LDP has received at least one label binding from a
                     peer.

               This minimizes traffic loss on link up but can still
               lead to substantial traffic loss under certain
               circumstances (for example, when interoperating with
               an LSR with ordered mode operation). It may be
               necessary to delay declaration of sync up after the
               session comes up by configuring a timeout period.
               When the graceful-restart event is configured, the IGP
               sync delay timer does not take effect.";
            case timer {
              leaf seconds {
                type uint32 {
                  range "5..300";
                }
                units "second";
                description
                  "Time in seconds to delay IGP sync after session
                   comes up.";
              }
            }
            case disable {
              leaf disable-delay {
                type empty;
                description
                  "This choice causes IGP sync up immediately upon
                   session up.";
              }
              description
                "This choice causes IGP sync up immediately upon
                 session up.";
            }
          }
          container afs {
            description
              "Address Family specific operational data";
            list af {
              key "af-name";
              description
                "MPLS LDP Operational data for this Address Family.";
              leaf af-name {
                type af;
                description
                  "Address Family name.";
              }
              leaf enable {
                /*
                 * CLI XR: mpls ldp <ifname> address-family <af>
                 * CLI (IOS,NXOS): mpls ip
                 */
                type boolean;
                description
                  "This is set true to enable LDP on this
                   interface.";
              }

              container bgp-redist {
                description
                  "MPLS LDP configuration for protocol
                  redistribution. By default, redistribution of BGP
                  routes is disabled. It can be enabled for all
                  BGP routes or for a specific AS. Also it can be
                  redistributed to all LDP peers or to a filtered
                  group of peers.";
                leaf as-xx {
                  type uint32 {
                    range "0..65535";
                  }
                  description
                    "First half of BGP AS number in XX.YY
                    format.  Mandatory Must be a non-zero
                    value if second half is zero.";
                }
                leaf as-yy {
                  type uint32 {
                    range "0..4294967295";
                  }
                  description
                    "Second half of BGP AS number in XX.YY
                    format. Mandatory Must be a non-zero value
                    if first half is zero.";
                }
                leaf advertise-to {
                  type string;
                  description
                    "Filter of neighbors to receive BGP route
                     redistributions from LDP. If the list is
                     empty or unset, all LDP neighbors will
                     receive redistributions.";
                  }
                leaf enable {
                  type boolean;
                  description
                    "This is set true to allow LDP to redistribute
                     BGP routes.";
                }
              } // container bgp-redist
              leaf autoconfig-disable {
                type boolean;
                description
                  "True if LDP autoconfig is explicitly disabled
                   on this interface.";
              }
            } // list af
          } // container afs
        } // list interface
      } // container interfaces

      container routing {
        description
          "This containter provides the MPLS LDP config for routing
           protocols from which it can obtain addresses to
           associate with labels.";
        /*
         * These are from CLI commands run in an IGP submode.
         * IOS,NXOS:
         *    mpls ldp autoconfig area area-id
         *    mpls ldp autoconfig {level-1 | level-1-2 | level-2}
         *    mpls ldp sync
         */
        list routing-inst {
          key routing-inst-name;
          description
            "This entry provides the MPLS LDP config for this
             routing instance.";
          leaf routing-inst-name {
            //ideally type rt:routing-instance-state-ref;
            type string;
            description
              "Name of the routing instance for which this MPLS LDP
               configuration applies.";
          }
          leaf autoconfig-enable {
            type boolean;
            description
              "This leaf enables or disables LDP for all interfaces
               covered by this routing instance subject to the
               autoconfig-scope.";
          }
          choice autoconfig-scope {
            description
              "This contains the autoconfig configuration for this
               routing instance.";
            case "area" {
              leaf area-id {
                type uint32;
                description
                  "This leaf restricts the LDP Autoconfiguration
                   feature to enable LDP on interfaces belonging to
                   an OSPF process for a specific area. If no area
                   is specified, then this applies to all interfaces
                   associated with the. If an area ID is specified,
                   then only interfaces associated with that OSPF
                   area are automatically enabled with LDP.
                   Any interface-specific ldp configuration will
                   overide this setting for that interface.";
              }
            }
            case "level" {
              leaf level-id {
                type enumeration {
                  enum "level-1" {
                    value 1;
                    description
                      "This leaf restricts the LDP Autoconfiguration
                       feature to enable LDP on interfaces belonging
                       to an IS-IS process level 1.
                       Any interface-specific ldp configuration will
                       overide this setting for that interface.";
                  }
                  enum "level-2" {
                    value 2;
                    description
                      "This leaf restricts the LDP Autoconfiguration
                       feature to enable LDP on interfaces belonging
                       to an IS-IS process level 1.
                       Any interface-specific ldp configuration will
                       overide this setting for that interface.";
                  }
                  enum "level-1-2" {
                    value 3;
                    description
                      "This leaf restricts the LDP Autoconfiguration
                       feature to enable LDP on interfaces belonging
                       to an IS-IS process level 2.
                       Any interface-specific ldp configuration will
                       overide this setting for that interface.";
                  }
                }
                description
                  "This leaf restricts the LDP Autoconfiguration
                   feature to enable LDP on interfaces belonging to
                   an ISIS process for a specific level. If no level
                   is specified, then this applies to all interfaces
                   associated with the. If a level is specified,
                   then only interfaces associated with that ISIS
                   level are automatically enabled with LDP.
                   Any interface-specific ldp configuration will
                   overide this setting for that interface.";
              }  // leaf level-id
            } // case level
          } // choice autoconfig-scope
          leaf sync {
            type boolean;
            description
              "When set to true this enables LDP IGP synchronization.
               Without syncrhonization, packet loss can occur because
               the actions of the IGP and LDP are not synchronized.";
          }
        } // list routing-inst
      } // container routing
      container dual-stack {
        /*
         * XR CLI:
         *    mpls ldp neighbor dual-stack transport-connection
         *                  max-wait <0-60>
         *    mpls ldp neighbor dual-stack transport-connection
         *                   prefer ipv4 for-peers
         */
        description
          "This container holds the configuration of dual IPv4 and
           IPv6 stack peers.";
        leaf max-wait {
          type uint32 {
            range "0..60";
          }
          description
            "Wait time in seconds (0 indicates no preference)";
        }
        leaf prefer-ipv4-peers {
          type string;
          description
            "This contains the filter name for peers where IPv4
             connections are preferred over IPv6 connections.
             The filter type is device specific and could be
             an ACL, a prefix list, or other mechanism.";
        }
      }
    } // container mpls-ldp-config
  } // container mpls-ldp-state

  // Notifications start here.

  notification init-sess-thresh-ex {
    description     
     "This notification is generated when the value of
      the 'init-sess-thresh' object
      is not zero, and the number of Session
      Initialization messages exceeds the value
      of the 'init-sess-thresh' object.";

    uses LDPID-INFO; // provides lsr-id, label-space-id

    leaf init-sess-thresh {
      type int32 {
        range "0..100";
      }
      description 
       "When attempting to establish a session with
        a given Peer, the given LDP Entity should
        send out the YANG notification, 
        'init-sess-thresh-ex', when the number of Session
        Initialization messages sent exceeds this threshold.
        
        The notification is used to notify an
        operator when this Entity and its Peer are
        possibly engaged in an endless sequence
        of messages as each NAKs the other's
        
        Initialization messages with Error Notification
        messages.  Setting this threshold which triggers
        the notification is one way to notify the
        operator.  The notification should be generated
        each time this threshold is exceeded and
        for every subsequent Initialization message
        which is NAK'd with an Error Notification
        message after this threshold is exceeded.
        
        A value of 0 (zero) for this object
        indicates that the threshold is infinity, thus
        the YANG notification will never be generated.";
      reference   
       "RFC3036, LDP Specification,
        Section 2.5.3 Session Initialization.";
    }
  } // notification init-sess-thresh-ex

  notification path-vector-limit-mismatch {
    description     
     "This notification is sent when the
      local path-vector-limit does NOT match
      the value of the 'peer-path-vector-limit' for
      a specific Entity.";
    reference       
     "RFC3036, LDP Specification, Section 3.5.3.";

    uses LDPID-INFO; // provides lsr-id, label-space-id

    leaf path-vector-limit {
      type int32 {
        range "0..255";
      }
      description 
       "If the value of this object is 0 (zero) then
        Loop Detection for Path Vectors is disabled.
        
        Otherwise, if this object has a value greater than
        zero, then Loop Dection for Path Vectors is enabled,
        and the Path Vector Limit is this value.
        Also, the value of the object,
        'LsrLoopDetectionCapable', must be set to
        either 'pathVector(4)' or 'hopCountAndPathVector(5)',
        if this object has a value greater than 0 (zero),
        otherwise it is ignored.";
      reference   
       "RFC3036, LDP Specification, Section 2.8 Loop Dection,
        Section 3.4.5 Path Vector TLV.";
    }

    leaf peer-id {
      type inet:ip-address;
      description
        "This leaf holds the peer id for this notification
         This id is simply an IP address.";
    } //leaf peer-id

    leaf peer-path-vector-limit {
      type int32 {
        range "0..255";
      }
      description 
       "If the value of this object is 0 (zero) then
        Loop Dection for Path Vectors for this Peer
        is disabled.
        
        Otherwise, if this object has a value greater than
        zero, then Loop Dection for Path  Vectors for this
        Peer is enabled and the Path Vector Limit is this value.";
      reference   
       "RFC3036, LDP Specification, Section 2.8 Loop Dection,
        Section 3.4.5 Path Vector TLV.";
    }
  } // notification path-vector-limit-mismatch

  notification session-up {
    description     
     "If this notification is sent when the
      value of 'session-state' enters
      the 'operational(5)' state.";

    uses LDPID-INFO; // provides lsr-id, label-space-id

    leaf peer-id {
      type inet:ip-address;
      description
        "This leaf holds the peer id for this notification
         This id is simply an IP address.";
    } //leaf peer-id

    leaf session-state {
      type session-state;
      description 
       "The current state of the session, all of the
        states 1 to 5 are based on the state machine
        for session negotiation behavior.";
      reference   
       "RFC3036, LDP Specification, Section 2.5.4,
        Initialization State Machine.";
    }

    leaf session-discon-time {
      type yang:timestamp;
      description 
       "The value of sysUpTime on the most recent occasion
        at which any one or more of this session's counters
        suffered a discontinuity.  The relevant counters are
        the specific instances associated with this session
        of any counter32 object contained in the
        session-stats-table.
        
        The initial value of this object is the value of
        sysUpTime when the entry was created in this table.
        
        Also, a command generator can distinguish when a session
        between a given Entity and Peer goes away and a new
        session is established.  This value would change and
        thus indicate to the command generator that this is a
        different session.";
    }

    leaf unknown-mes-type-errors {
      type yang:counter32;
      description 
       "This object counts the number of Unknown Message Type
        Errors detected by this LSR/LER during this session.
        
        Discontinuities in the value of this counter can occur
        at re-initialization of the management system, and at
        other times as indicated by the value of
        session-discon-time.";
    }

    leaf unknown-tlv-errors {
      type yang:counter32;
      description 
       "This object counts the number of Unknown TLV Errors
        detected by this LSR/LER during this session.
        
        Discontinuities in the value of this counter can occur
        at re-initialization of the management system, and at
        other times as indicated by the value of
        SessionDiscontinuityTime.";
    }
  } // notification session-up

  notification session-down {
    description     
     "This notification is sent when the value of 'session-state'
      leaves the 'operational(5)' state.";

    uses LDPID-INFO; // provides lsr-id, label-space-id

    leaf peer-id {
      type inet:ip-address;
      description
        "This leaf holds the peer id for this notification
         This id is simply an IP address.";
    } //leaf peer-id

    leaf state {
      type session-state;
      description 
       "The current state of the session, all of the
        states 1 to 5 are based on the state machine
        for session negotiation behavior.";
      reference   
       "RFC3036, LDP Specification, Section 2.5.4,
        Initialization State Machine.";
    }

    leaf session-discon-time {
      type yang:timestamp;
      description 
       "The value of sysUpTime on the most recent occasion
        at which any one or more of this session's counters
        suffered a discontinuity.  The relevant counters are
        the specific instances associated with this session
        of any counter32 object contained in the
        session-stats table.
        
        The initial value of this object is the value of
        sysUpTime when the entry was created in this table.
        
        Also, a command generator can distinguish when a session
        between a given Entity and Peer goes away and a new
        session is established.  This value would change and
        thus indicate to the command generator that this is a
        different session.";
    }

    leaf unknown-mes-type-errors {
      type yang:counter32;
      description 
       "This object counts the number of Unknown Message Type
        Errors detected by this LSR/LER during this session.
        
        Discontinuities in the value of this counter can occur
        at re-initialization of the management system, and at
        other times as indicated by the value of
        session-discon-time.";
    }

    leaf unknown-tlv-errors {
      type yang:counter32;
      description 
       "This object counts the number of Unknown TLV Errors
        detected by this LSR/LER during this session.
        
        Discontinuities in the value of this counter can occur
        at re-initialization of the management system, and at
        other times as indicated by the value of
        session-discon-time.";
    }
  } // notification session-down
  // RPCs start here:

  // Clear mpls ldp msg-counters neighbor
  rpc clear-msg-counters {
    description
      "This RPC clears the LDP message counters for either a single
       neighbor or for all neighbors.";
    input {
      choice scope {
        description
          "This choice provides either the LSR ID of the
           neighbor whose data should be cleared or 'all'
           to specify all neighbors.";
        case lsr-id {
          description
            "This case provides the LSR ID of the neighbor
             whose data should be cleared.";
          leaf vrf-name {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          leaf nbr-ip {
            type inet:ip-address;
            description
              "LSR ID of the neighbor";
          }
        } // case lsr-id
        case all {
          description
            "This case is used to clear the information for all
             neighbors.";
          leaf all {
            type empty;
            description
             "Clear information for all neighbors.";
          }
        } // case all
      } // choice scope
    } // input
    output {
      leaf status {
        type string;
        description
          "Return status will be 'OK' on success or an explanation
           string on failure.";
      } // leaf status
    } // output
  }

  // clear mpls ldp neighbor [ip-address]
  rpc restart-neighbor {
    description
      "This RPC restarts a single LDP session or all LDP sessions,
       but does not restart the LDP process itself, if the device
       supports that capability.";
    input {
      choice scope {
        description
          "This choice provides either the LSR ID of the
           neighbor whose session(s) should be restarted or
           'all' to specify all neighbors.";
        case lsr-id {
          description
            "This case provides the LSR ID of the neighbor
            whoses session(s) should be restarted.";
          leaf vrf-name {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          leaf nbr-ip {
            type inet:ip-address;
            description
                "LSR ID of the neighbor";
          }
        } // case lsr-id
        case all {
          description
            "This case is used to restart the sessions for all
             neighbors.";
          leaf all {
            type empty;
            description
              "Restart sessions for all neighbors.";
          }
        } // case all
      } // choice scope
    } // input
    output {
      leaf status {
        type string;
        description
          "Return status will be 'OK' on success or an explanation
           string on failure.";
      } // leaf status
    } // output
  } //rpc clear neighbor

  // clear mpls ldp forwarding [ ip-address ]
  rpc clear-forwarding {
    description
      "This command resets LDP installed forwarding state for all
       prefixes or a given prefix. It is useful when installed 
       LDP forwarding state needs to be reprogrammed in LSD and
       MPLS forwarding.";
    input {
      choice scope {
        description
          "This choice provides either the ip prefix of the
           forwarding entries that should be cleared or 'all'
           to specify all neighbors.";
        case prefix-addr {
          description
            "This case provides the IP prefix for the forwarding
             entry whose data should be cleared.";
          leaf vrf-name {
            type string;
            description
              "This contains the VRF Name, where 'default' is used
               for the default vrf.";
          }
          leaf prefix-ip {
            type inet:ip-address;
            description
              "This case provides the IP prefix for the forwarding
               entry whose data should be cleared.";
          }
        } // case lsr-id
        case all {
          description
            "This case is used to clear the forwarding entries
             for all prefixes.";
          leaf all {
            type empty;
            description
              "This case is used to clear the forwarding entries
               for all prefixes.";
          }
        } // case all
      } // choice scope
    } // input
    output {
      leaf status {
        type string;
        description
          "Return status will be 'OK' on success or an explanatory
           string on failure.";
      } // leaf status
    } // output
  } //rpc clear-forwarding
} // module mpls-ldp
