/*
 * Generated by confdc --mib2yang-std
 * Source: mgmt/dmi/model/mib/src/patched/CISCO-FLASH-MIB.mib
 */
/*
 * This YANG module has been generated by smidump 0.5.0:
 *
 *      smidump -f yang CISCO-FLASH-MIB
 *
 * Do not edit. Edit the source file instead!
 */

module CISCO-FLASH-MIB {

  namespace "urn:ietf:params:xml:ns:yang:smiv2:CISCO-FLASH-MIB";
  prefix CISCO-FLASH-MIB;

  import CISCO-QOS-PIB-MIB {
    prefix "cisco-qos";
  }

  import ENTITY-MIB {
    prefix "entity-mib";
  }

  import INET-ADDRESS-MIB {
    prefix "inet-address";
  }

  import SNMPv2-TC {
    prefix "snmpv2-tc";
  }

  import ietf-inet-types {
    prefix "inet";
  }

  import ietf-yang-smiv2 {
    prefix "smiv2";
  }

  import ietf-yang-types {
    prefix "yang";
  }

  organization
   "Cisco Systems, Inc.";

  contact
   "Cisco Systems
    Customer Service
    
    Postal: 170 W. Tasman Drive
    San Jose, CA  95134
    USA
    
    Tel: +1 800 553-NETS
    
    E-mail: cs-snmp@cisco.com";

  description
   "This MIB provides for the management of Cisco
    Flash Devices.";

  revision 2013-08-06 {
    description
     "Added new notification ciscoFlashPartitionLowSpaceNotif.
      Added new notification ciscoFlashPartitionLowSpaceRecoveryNotif.
      Added new object ciscoFlashPartitionLowSpaceNotifEnable.
      Added new object ciscoFlashPartitionLowSpaceNotifThreshold.
      Added new object group ciscoFlashPartitionInfoGroupRev1.
      Added new notification group ciscoFlashNotifGroupRev3.
      Added new compliance group ciscoFlashMIBComplianceRev11 which
      deprecates ciscoFlashMIBComplianceRev10.";
  }

  revision 2011-03-16 {
    description
     "Added ciscoFlashDeviceMinPartitionSizeExtended to support flash
      devices of sizes greater than 4 GB.
      
      Added new object group ciscoFlashDeviceInfoExtGroupSupRev1.
      
      Added new compliance group ciscoFlashMIBComplianceRev10 which
      deprecates ciscoFlashMIBComplianceRev9.";
  }

  revision 2009-06-03 {
    description
     "Added 'copyProhibited' enum value to ciscoFlashCopyStatus object.";
  }

  revision 2008-12-08 {
    description
     "Added ciscoFlashDeviceSizeExtended,
      ciscoFlashPartitionFreeSpaceExtended and
      ciscoFlashPartitionSizeExtended to support flash devices
      of sizes greater than 4 GB.";
  }

  revision 2007-03-21 {
    description
     "Added ciscoFlashFileTypeTable.";
  }

  revision 2006-11-08 {
    description
     "DISPLAY-HINT for CheckSumString TEXTUAL CONVENTION
      is changed from 'x' to '1x'.";
  }

  revision 2005-06-01 {
    description
     "Added ciscoFlashFileDate to ciscoFlashFileTable
      
      Added ciscoFlashCopyRemotePassword to
                ciscoFlashCopyTable.
      
      Added following enumerations to
      ciscoFlashCopyProtocol -
       ftp, scp, sftp.";
  }

  revision 2005-01-28 {
    description
     "Added a new status copyOperationPending(0)
      to object ciscoFlashCopyStatus.";
  }

  revision 2004-03-18 {
    description
     "The object ciscoFlashCopyServerAddress is
      deprecated since it supports only IPv4 address. Two
      new objects ciscoFlashCopyServerAddrRev1
      ciscoFlashCopyServerAddrType are defined.";
  }

  revision 2003-04-23 {
    description
     "Added ciscoFlashDeviceNameExtended to support upto
      255 characters in flash device name.
      Deprecated ciscoFlashDeviceName.";
  }

  revision 2003-01-31 {
    description
     "Add ciscoFlashCopyVerify object to
      CiscoFlashCopyEntry, & ciscoFlashCopyOpGroup.
      Fix scalability problem for the following tables and
      MIB objects: ciscoFlashDevicesSupported,
      ciscoFlashDeviceTable, ciscoFlashPhyEntIndex (added),
      ciscoFlashPartitionTable and ciscoFlashFileTable.";
  }

  revision 2002-04-01 {
    description
     "Added Notifications ciscoFlashDeviceInsertedNotif
      and ciscoFlashDeviceRemovedNotif. Deprecated the
      ciscoFlashDeviceChangeTrap.
      Added Scalars ciscoFlashCfgDevInsNotifEnable and
      ciscoFlashCfgDevRemNotifEnable to control the above
      notifications.";
  }

  revision 2002-01-25 {
    description
     "Added object ciscoFlashFileType to
      ciscoFlashFileTable and
      added FlashFileType as a TEXTUAL-CONVENTION.";
  }

  revision 2002-01-22 {
    description
     "Fixing several problems with the previous
      version of the MIB:
       o Changing MAX-ACCESS of ciscoFlashDeviceIndex
         back to 'not-accessible'.  The change described
         below in REVISION '200102211234Z' was not legal.
       o Changing the definition of the
         ciscoFlashDeviceChangeTrap notification.
         The original definition of this notification include
         a 'not-accessible' object (ciscoFlashDeviceIndex).
         It will instead include the following objects:
            ciscoFlashDeviceMinPartitionSize
            ciscoFlashDeviceName
         Instances of these object will carry the value of
         ciscoFlashDeviceIndex implicitly in their object
         identifiers.  This change is being made without
         deprecation of the notification and has the
         potential to cause problems with existing
         implementations of the notification on the agent
         and the manager.
       o Past versions of the MIB have had a incorrectly
         formatted REVISION/DESCRIPTION section.  That will
         be corrected in this REVISION.
       o Past versions of the MIB have not defined a
         NOTIFICATION-GROUP for the notifications defined
         by this MIB.  That will be corrected in this
         REVISION by adding ciscoFlashNotifGroup.  This
         group will be considered optional for
         implementation.
       o Gratuitous ranges specified in Entry definitions
         have been removed.";
  }

  revision 2001-02-21 {
    description
     "Change MAX-ACCESS of CiscoFlashDeviceIndex
      from not-accessible to accessible-to-notfiy";
  }

  revision 1998-08-27 {
    description
     "Change ciscoFlashChipCode to match implementation,
      and remove FlashChipCode as a TEXTUAL-CONVENTION.";
  }

  revision 1996-04-17 {
    description
     "Add enumerations to objects in ciscoFlashMiscOpTable
      to support formatting of flash devices.";
  }

  revision 1995-10-18 {
    description
     "Add enumerations to a couple objects, and clarify
      several object DESCRIPTIONs.";
  }

  revision 1995-08-15 {
    description
     "Specify a correct (non-negative) range for several
      index objects.";
  }

  revision 1995-04-29 {
    description
     "Miscellaneous updates, including updated description of
      ciscoFlashDeviceCard object.";
  }

  revision 1995-01-13 {
    description
     "Initial version of Flash operations MIB module.";
  }

  typedef ChecksumString {
    type binary;
    description
     "Represents the checksum of a file.";
  }

  typedef FlashFileType {
    type enumeration {
      enum "unknown" {
        value "1";
      }
      enum "config" {
        value "2";
      }
      enum "image" {
        value "3";
      }
      enum "directory" {
        value "4";
      }
      enum "crashinfo" {
        value "5";
      }
    }
    description
     "File types for files in a flash.
      
      unknown        - file type is not one of the following.
      config         - configuration file like
                       startup configuration or
                       running configuration.
      image          - image file.
      directory      - directory entry.
      crashinfo      - file containing crashinfo.";
  }


  container CISCO-FLASH-MIB {
    config false;

    container ciscoFlashDevice {
      smiv2:oid "1.3.6.1.4.1.9.9.10.1.1";

      leaf ciscoFlashDevicesSupported {
        type uint32;
        description
         "Number of Flash devices supported by the system.
          If the system does not support any Flash devices, this
          MIB will not be loaded on that system. The value of this
          object will therefore be atleast 1.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.1";
      }
    }

    container ciscoFlashCfg {
      smiv2:oid "1.3.6.1.4.1.9.9.10.1.4";

      leaf ciscoFlashCfgDevInsNotifEnable {
        type boolean;
        description
         "Specifies whether or not a notification should be
          generated on the insertion of a Flash device.
          
          If the value of this object is 'true' then the
          ciscoFlashDeviceInsertedNotif notification
          will be generated.
          
          If the value of this object is 'false' then the
          ciscoFlashDeviceInsertedNotif notification
          will not be generated.
          
          It is the responsibility of the management entity to
          ensure that the SNMP administrative model is
          configured in such a way as to allow the
          notification to be delivered.";
        smiv2:defval "false";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.4.1";
      }

      leaf ciscoFlashCfgDevRemNotifEnable {
        type boolean;
        description
         "Specifies whether or not a notification should be
          generated on the removal of a Flash device.
          
          If the value of this object is 'true' then the
          ciscoFlashDeviceRemovedNotif notification
          will be generated.
          
          If the value of this object is 'false' then the
          ciscoFlashDeviceRemovedNotif notification
          will not be generated.
          
          It is the responsibility of the management entity to
          ensure that the SNMP administrative model is
          configured in such a way as to allow the
          notification to be delivered.";
        smiv2:defval "false";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.4.2";
      }

      leaf ciscoFlashPartitionLowSpaceNotifEnable {
        type boolean;
        description
         "This object specifies whether or not a notification should be
          generated when the free space falls below the threshold value on
          a flash partition and on recovery from low space.
          
          If the value of this object is 'true' then
          ciscoFlashPartitionLowSpaceNotif and
          ciscoFlashPartitionLowSpaceRecoveryNotif notifications will be
          generated.
          
          If the value of this object is 'false' then the
          ciscoFlashPartitionLowSpaceNotif  and
          ciscoFlashPartitionLowSpaceRecoveryNotif notifications
          will not be generated.
          
          It is the responsibility of the management entity to
          ensure that the SNMP administrative model is
          configured in such a way as to allow the
          notifications to be delivered.";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.4.3";
      }
    }

    container ciscoFlashDeviceTable {
      description
       "Table of Flash device properties for each initialized
        Flash device. Each Flash device installed in a system
        is detected, sized, and initialized when the system
        image boots up.
        For removable Flash devices, the device properties
        will be dynamically deleted and recreated as the
        device is removed and inserted. Note that in this
        case, the newly inserted device may not be the same as
        the earlier removed one. The ciscoFlashDeviceInitTime
        object is available for a management station to determine
        the time at which a device was initialized, and thereby
        detect the change of a removable device.
        A removable device that has not been installed will
        also have an entry in this table. This is to let a
        management station know about a removable device that
        has been removed. Since a removed device obviously
        cannot be sized and initialized, the table entry for
        such a device will have
        ciscoFlashDeviceSize equal to zero,
        and the following objects will have
        an indeterminate value:
                ciscoFlashDeviceMinPartitionSize,
                ciscoFlashDeviceMaxPartitions,
                ciscoFlashDevicePartitions, and
                ciscoFlashDeviceChipCount.
        ciscoFlashDeviceRemovable will be
        true to indicate it is removable.";
      smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2";

      list ciscoFlashDeviceEntry {
        key "ciscoFlashDeviceIndex";
        description
         "An entry in the table of flash device properties for
          each initialized flash device.
          Each entry can be randomly accessed by using
          ciscoFlashDeviceIndex as an index into the table.
          Note that removable devices will have an entry in
          the table even when they have been removed. However,
          a non-removable device that has not been installed
          will not have an entry in the table.";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1";

        leaf ciscoFlashDeviceIndex {
          type uint32 {
            range "1..4294967295";
          }
          description
           "Flash device sequence number to index within the
            table of initialized flash devices.
            The lowest value should be 1. The highest should be
            less than or equal to the value of the
            ciscoFlashDevicesSupported object.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.1";
        }

        leaf ciscoFlashDeviceSize {
          type uint32 {
            range "0..4294967295";
          }
          units "bytes";
          description
           "Total size of the Flash device.
            For a removable device, the size will be zero if
            the device has been removed.
            
            If the total size of the flash device is greater than the
            maximum value reportable by this object then this object
            should report its maximum value(4,294,967,295) and
            ciscoFlashDeviceSizeExtended must be used to report the
            flash device's size.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.2";
        }

        leaf ciscoFlashDeviceMinPartitionSize {
          type uint32 {
            range "0..4294967295";
          }
          units "bytes";
          description
           "This object will give the minimum partition size
            supported for this device. For systems that execute code
            directly out of Flash, the minimum partition size needs
            to be the bank size. (Bank size is equal to the size of a
            chip multiplied by the width of the device. In most cases,
            the device width is 4 bytes, and so the bank size would be
            four times the size of a chip). This has to be so because
            all programming commands affect the operation of an
            entire chip (in our case, an entire bank because all
            operations are done on the entire width of the device)
            even though the actual command may be localized to a small
            portion of each chip. So when executing code out of Flash,
            one needs to be able to write and erase some portion of
            Flash without affecting the code execution.
            For systems that execute code out of DRAM or ROM, it is
            possible to partition Flash with a finer granularity (for
            eg., at erase sector boundaries) if the system code supports
            such granularity.
            
            This object will let a management entity know the
            minimum partition size as defined by the system.
            If the system does not support partitioning, the value
            will be equal to the device size in ciscoFlashDeviceSize.
            The maximum number of partitions that could be configured
            will be equal to the minimum of
            ciscoFlashDeviceMaxPartitions
            and
            (ciscoFlashDeviceSize / ciscoFlashDeviceMinPartitionSize).
            
            If the total size of the flash device is greater than the
            maximum value reportable by this object then this object should
            report its maximum value(4,294,967,295) and
            ciscoFlashDeviceMinPartitionSizeExtended must be used to report
            the flash device's minimum partition size.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.3";
        }

        leaf ciscoFlashDeviceMaxPartitions {
          type uint32;
          description
           "Max number of partitions supported by the system for
            this Flash device. Default will be 1, which actually
            means that partitioning is not supported. Note that
            this value will be defined by system limitations, not
            by the flash device itself (for eg., the system may
            impose a limit of 2 partitions even though the device
            may be large enough to be partitioned into 4 based on
            the smallest partition unit supported).
            On systems that execute code out of Flash, partitioning
            is a way of creating multiple file systems in the Flash
            device so that writing into or erasing of one file system
            can be done while executing code residing in another file
            system.
            For systems executing code out of DRAM, partitioning
            gives a way of sub-dividing a large Flash device for
            easier management of files.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.4";
        }

        leaf ciscoFlashDevicePartitions {
          type uint32 {
            range "0..4294967295";
          }
          description
           "Flash device partitions actually present. Number of
            partitions cannot exceed the minimum of
            ciscoFlashDeviceMaxPartitions
            and
            (ciscoFlashDeviceSize / ciscoFlashDeviceMinPartitionSize).
            Will be equal to at least 1, the case where the partition
            spans the entire device (actually no partitioning).
            A partition will contain one or more minimum partition
            units (where a minimum partition unit is defined by
            ciscoFlashDeviceMinPartitionSize).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.5";
        }

        leaf ciscoFlashDeviceChipCount {
          type int32 {
            range "0..64";
          }
          description
           "Total number of chips within the Flash device.
            The purpose of this object is to provide information
            upfront to a management station on how much chip info
            to expect and possibly help double check the chip index
            against an upper limit when randomly retrieving chip
            info for a partition.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.6";
        }

        leaf ciscoFlashDeviceName {
          type snmpv2-tc:DisplayString {
            length "0..16";
          }
          status deprecated;
          description
           "Flash device name. This name is used to refer to the
            device within the system. Flash operations get directed
            to a device based on this name.
            The system has a concept of a default device.
            This would be the primary or most used device in case of
            multiple devices. The system directs an operation to the
            default device whenever a device name is not specified.
            The device name is therefore mandatory except when the
            operation is being done on the default device, or,
            the system supports only a single Flash device.
            The device name will always be available for a
            removable device, even when the device has been removed.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.7";
        }

        leaf ciscoFlashDeviceDescr {
          type snmpv2-tc:DisplayString {
            length "0..64";
          }
          description
           "Description of a Flash device. The description is meant
            to explain what the Flash device and its purpose is.
            Current values are:
              System flash - for the primary Flash used to store full
                             system images.
              Boot flash   - for the secondary Flash used to store
                             bootstrap images.
            The ciscoFlashDeviceDescr, ciscoFlashDeviceController
            (if applicable), and ciscoFlashPhyEntIndex objects are
            expected to collectively give all information about a
            Flash device.
            The device description will always be available for a
            removable device, even when the device has been removed.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.8";
        }

        leaf ciscoFlashDeviceController {
          type snmpv2-tc:DisplayString {
            length "0..64";
          }
          description
           "Flash device controller. The h/w card that actually
            controls Flash read/write/erase. Relevant for the AGS+
            systems where Flash may be controlled by the MC+, STR or
            the ENVM cards, cards that may not actually contain the
            Flash chips.
            For systems that have removable PCMCIA flash cards that
            are controlled by a PCMCIA controller chip, this object
            may contain a description of that controller chip.
            Where irrelevant (Flash is a direct memory mapped device
            accessed directly by the main processor), this object will
            have an empty (NULL) string.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.9";
        }

        leaf ciscoFlashDeviceCard {
          type snmpv2-tc:InstancePointer;
          status deprecated;
          description
           "This object will point to an instance of a card entry
            in the cardTable. The card entry will give details about
            the card on which the Flash device is actually located.
            For most systems, this is usually the main processor board.
            On the AGS+ systems, Flash is located on a separate multibus
            card such as the MC.
            This object will therefore be used to essentially index
            into cardTable to retrieve details about the card such as
            cardDescr, cardSlotNumber, etc.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.10";
        }

        leaf ciscoFlashDeviceProgrammingJumper {
          type enumeration {
            enum "installed" {
              value "1";
            }
            enum "notInstalled" {
              value "2";
            }
            enum "unknown" {
              value "3";
            }
          }
          description
           "This object gives the state of a jumper (if present and can be
            determined) that controls the programming voltage called Vpp
            to the Flash device. Vpp is required for programming (erasing
            and writing) Flash. For certain older technology chips it is
            also required for identifying the chips (which in turn is
            required to identify which programming algorithms to use;
            different chips require different algorithms and commands).
            The purpose of the jumper, on systems where it is available,
            is to write protect a Flash device.
            On most of the newer remote access routers, this jumper is
            unavailable since users are not expected to visit remote sites
            just to install and remove the jumpers when upgrading software
            in the Flash device. The unknown(3) value will be returned for
            such systems and can be interpreted to mean that a programming
            jumper is not present or not required on those systems.
            On systems where the programming jumper state can be read back
            via a hardware register, the installed(1) or notInstalled(2)
            value will be returned.
            This object is expected to be used in conjunction with the
            ciscoFlashPartitionStatus object whenever that object has
            the readOnly(1) value. In such a case, this object will
            indicate whether the programming jumper is a possible reason
            for the readOnly state.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.11";
        }

        leaf ciscoFlashDeviceInitTime {
          type yang:timestamp;
          description
           "System time at which device was initialized.
            For fixed devices, this will be the system time at
            boot up.
            For removable devices, it will be the time at which
            the device was inserted, which may be boot up time,
            or a later time (if device was inserted later).
            If a device (fixed or removable) was repartitioned,
            it will be the time of repartitioning.
            The purpose of this object is to help a management
            station determine if a removable device has been
            changed. The application should retrieve this
            object prior to any operation and compare with
            the previously retrieved value.
            Note that this time will not be real time but a
            running time maintained by the system. This running
            time starts from zero when the system boots up.
            For a removable device that has been removed, this
            value will be zero.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.12";
        }

        leaf ciscoFlashDeviceRemovable {
          type boolean;
          description
           "Whether Flash device is removable. Generally, only PCMCIA
            Flash cards will be treated as removable. Socketed Flash
            chips and Flash SIMM modules will not be treated as removable.
            Simply put, only those Flash devices that can be inserted
            or removed without opening the hardware casing will be
            considered removable.
            Further, removable Flash devices are expected to have
            the necessary hardware support -
              1. on-line removal and insertion
              2. interrupt generation on removal or insertion.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.13";
        }

        leaf ciscoFlashPhyEntIndex {
          type entity-mib:PhysicalIndexOrZero;
          description
           "This object indicates the physical entity index of a
            physical entity in entPhysicalTable which the flash
            device actually located.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.14";
        }

        leaf ciscoFlashDeviceNameExtended {
          type snmpv2-tc:DisplayString {
            length "0..255";
          }
          description
           "Extended Flash device name whose size can be upto
            255 characters. This name is used to refer to the
            device within the system. Flash operations get directed
            to a device based on this name.
            The system has a concept of a default device.
            This would be the primary or most used device in case
            of multiple devices. The system directs an operation
            to the default device whenever a device name is not
            specified. The device name is therefore mandatory
            except when the operation is being done on the
            default device, or, the system supports only a single
            Flash device. The device name will always be available
            for a removable device, even when the device has been
            removed.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.15";
        }

        leaf ciscoFlashDeviceSizeExtended {
          type yang:gauge64;
          units "bytes";
          description
           "Total size of the Flash device.
            For a removable device, the size will be zero if
            the device has been removed.
            
            This object is a 64-bit version of ciscoFlashDeviceSize.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.16";
        }

        leaf ciscoFlashDeviceMinPartitionSizeExtended {
          type yang:gauge64;
          description
           "This object provides the minimum partition size supported for
            this device. This object is a 64-bit version of 
            ciscoFlashDeviceMinPatitionSize.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.2.1.17";
        }
      }
    }

    container ciscoFlashChipTable {
      description
       "Table of Flash device chip properties for each
        initialized Flash device.
        This table is meant primarily for aiding error
        diagnosis.";
      smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.3.1";

      list ciscoFlashChipEntry {
        key "ciscoFlashDeviceIndex ciscoFlashChipIndex";
        description
         "An entry in the table of chip info for each
          flash device initialized in the system.
          An entry is indexed by two objects - the
          device index and the chip index within that
          device.";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.3.1.1";

        leaf ciscoFlashDeviceIndex {
          type leafref {
            path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
          }
        }

        leaf ciscoFlashChipIndex {
          type int32 {
            range "1..64";
          }
          description
           "Chip sequence number within selected flash device.
            Used to index within chip info table.
            Value starts from 1 and should not be greater than
            ciscoFlashDeviceChipCount for that device.
            When retrieving chip information for chips within a
            partition, the sequence number should lie between
            ciscoFlashPartitionStartChip & ciscoFlashPartitionEndChip
            (both inclusive).";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.3.1.1.1";
        }

        leaf ciscoFlashChipCode {
          type snmpv2-tc:DisplayString {
            length "0..5";
          }
          description
           "Manufacturer and device code for a chip.
            Lower byte will contain the device code.
            Upper byte will contain the manufacturer code.
            If a chip code is unknown because it could not
            be queried out of the chip, the value of this
            object will be 00:00.
            Since programming algorithms differ from chip type to
            chip type, this chip code should be used to determine
            which algorithms to use (and thereby whether the chip
            is supported in the first place).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.3.1.1.2";
        }

        leaf ciscoFlashChipDescr {
          type snmpv2-tc:DisplayString {
            length "0..32";
          }
          description
           "Flash chip name corresponding to the chip code.
            The name will contain the manufacturer and the
            chip type. It will be of the form :
              Intel 27F008SA.
            In the case where a chip code is unknown, this
            object will be an empty (NULL) string.
            In the case where the chip code is known but the
            chip is not supported by the system, this object
            will be an empty (NULL) string.
            A management station is therefore expected to use the
            chip code and the chip description in conjunction
            to provide additional information whenever the
            ciscoFlashPartitionStatus object has the readOnly(1)
            value.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.3.1.1.3";
        }

        leaf ciscoFlashChipWriteRetries {
          type yang:counter32;
          description
           "This object will provide a cumulative count
            (since last system boot up or initialization) of
            the number of write retries that were done in the chip.
            If no writes have been done to Flash, the count
            will be zero. Typically, a maximum of 25 retries are
            done on a single location before flagging a write
            error.
            A management station is expected to get this object
            for each chip in a partition after a write failure
            in that partition. To keep a track of retries for
            a given write operation, the management station would
            have to retrieve the values for the concerned chips
            before and after any write operation.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.3.1.1.4";
        }

        leaf ciscoFlashChipEraseRetries {
          type yang:counter32;
          description
           "This object will provide a cumulative count
            (since last system boot up or initialization) of
            the number of erase retries that were done in the chip.
            Typically, a maximum of 2000 retries are done in a
            single erase zone (which may be a full chip or a
            portion, depending on the chip technology) before
            flagging an erase error.
            A management station is expected to get this object
            for each chip in a partition after an erase failure
            in that partition. To keep a track of retries for
            a given erase operation, the management station would
            have to retrieve the values for the concerned chips
            before and after any erase operation.
            Note that erase may be done through an independent
            command, or through a copy-to-flash command.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.3.1.1.5";
        }

        leaf ciscoFlashChipMaxWriteRetries {
          type uint32;
          description
           "The maximum number of write retries done at any
            single location before declaring a write failure.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.3.1.1.6";
        }

        leaf ciscoFlashChipMaxEraseRetries {
          type uint32;
          description
           "The maximum number of erase retries done within
            an erase sector before declaring an erase failure.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.3.1.1.7";
        }
      }
    }

    container ciscoFlashPartitionTable {
      description
       "Table of flash device partition properties for each
        initialized flash partition. Whenever there is no
        explicit partitioning done, a single partition spanning
        the entire device will be assumed to exist. There will
        therefore always be atleast one partition on a device.";
      smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1";

      list ciscoFlashPartitionEntry {
        key "ciscoFlashDeviceIndex ciscoFlashPartitionIndex";
        description
         "An entry in the table of flash partition properties
          for each initialized flash partition. Each entry
          will be indexed by a device number and a partition
          number within the device.";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1";

        leaf ciscoFlashDeviceIndex {
          type leafref {
            path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
          }
        }

        leaf ciscoFlashPartitionIndex {
          type uint32 {
            range "1..4294967295";
          }
          description
           "Flash partition sequence number used to index within
            table of initialized flash partitions.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.1";
        }

        leaf ciscoFlashPartitionStartChip {
          type int32 {
            range "1..64";
          }
          description
           "Chip sequence number of first chip in partition.
            Used as an index into the chip table.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.2";
        }

        leaf ciscoFlashPartitionEndChip {
          type int32 {
            range "1..64";
          }
          description
           "Chip sequence number of last chip in partition.
            Used as an index into the chip table.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.3";
        }

        leaf ciscoFlashPartitionSize {
          type uint32 {
            range "1..4294967295";
          }
          units "bytes";
          description
           "Flash partition size. It should be an integral
            multiple of ciscoFlashDeviceMinPartitionSize.
            If there is a single partition, this size will be equal
            to ciscoFlashDeviceSize.
            
            If the size of the flash partition is greater than the
            maximum value reportable by this object then this object
            should report its maximum value(4,294,967,295) and
            ciscoFlashPartitionSizeExtended must be used to report the
            flash partition's size.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.4";
        }

        leaf ciscoFlashPartitionFreeSpace {
          type yang:gauge32;
          units "bytes";
          description
           "Free space within a Flash partition.
            Note that the actual size of a file in Flash includes
            a small overhead that represents the file system's
            file header.
            Certain file systems may also have a partition or
            device header overhead to be considered when
            computing the free space.
            Free space will be computed as total partition size
            less size of all existing files (valid/invalid/deleted
            files and including file header of each file),
            less size of any partition header, less size of
            header of next file to be copied in. In short, this
            object will give the size of the largest file that
            can be copied in. The management entity will not be
            expected to know or use any overheads such as file
            and partition header lengths, since such overheads
            may vary from file system to file system.
            Deleted files in Flash do not free up space.
            A partition may have to be erased in order to reclaim
            the space occupied by files.
            
            If the free space within a flash partition is greater than
            the maximum value reportable by this object then this object
            should report its maximum value(4,294,967,295) and
            ciscoFlashPartitionFreeSpaceExtended
            must be used to report the flash partition's free space.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.5";
        }

        leaf ciscoFlashPartitionFileCount {
          type yang:gauge32;
          description
           "Count of all files in a flash partition. Both
            good and bad (deleted or invalid checksum) files
            will be included in this count.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.6";
        }

        leaf ciscoFlashPartitionChecksumAlgorithm {
          type enumeration {
            enum "simpleChecksum" {
              value "1";
            }
            enum "undefined" {
              value "2";
            }
            enum "simpleCRC" {
              value "3";
            }
          }
          description
           "Checksum algorithm identifier for checksum method
            used by the file system. Normally, this would be
            fixed for a particular file system. When a file
            system writes a file to Flash, it checksums the
            data written. The checksum then serves as a way
            to validate the data read back whenever the file
            is opened for reading.
            Since there is no way, when using TFTP, to guarantee
            that a network download has been error free (since
            UDP checksums may not have been enabled), this
            object together with the ciscoFlashFileChecksum
            object provides a method for any management station
            to regenerate the checksum of the original file
            on the server and compare checksums to ensure that
            the file download to Flash was error free.
            simpleChecksum represents a simple 1s complement
            addition of short word values. Other algorithm
            values will be added as necessary.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.7";
        }

        leaf ciscoFlashPartitionStatus {
          type enumeration {
            enum "readOnly" {
              value "1";
            }
            enum "runFromFlash" {
              value "2";
            }
            enum "readWrite" {
              value "3";
            }
          }
          description
           "Flash partition status can be :
            
            * readOnly if device is not programmable either because
            chips could not be recognized or an erroneous mismatch
            of chips was detected. Chip recognition may fail either
            because the chips are not supported by the system,
            or because the Vpp voltage required to identify chips
            has been disabled via the programming jumper.
            The ciscoFlashDeviceProgrammingJumper, ciscoFlashChipCode,
            and ciscoFlashChipDescr objects can be examined to get
            more details on the cause of this status
            * runFromFlash (RFF) if current image is running from
            this partition.
            The ciscoFlashPartitionUpgradeMethod object will then
            indicate whether the Flash Load Helper can be used
            to write a file to this partition or not.
            
            * readWrite if partition is programmable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.8";
        }

        leaf ciscoFlashPartitionUpgradeMethod {
          type enumeration {
            enum "unknown" {
              value "1";
            }
            enum "rxbootFLH" {
              value "2";
            }
            enum "direct" {
              value "3";
            }
          }
          description
           "Flash partition upgrade method, ie., method by which
            new files can be downloaded into the partition.
            FLH stands for Flash Load Helper, a feature provided
            on run-from-Flash systems for upgrading Flash. This
            feature uses the bootstrap code in ROMs to help in
            automatic download.
            This object should be retrieved if the partition
            status is runFromFlash(2).
            If the partition status is readOnly(1), the upgrade
            method would depend on the reason for the readOnly
            status. For eg., it may simply be a matter of installing
            the programming jumper, or it may require execution of a
            later version of software that supports the Flash chips.
            
            unknown      -  the current system image does not know
                            how Flash can be programmed. A possible
                            method would be to reload the ROM image
                            and perform the upgrade manually.
            rxbootFLH    -  the Flash Load Helper is available to
                            download files to Flash. A copy-to-flash
                            command can be used and this system image
                            will automatically reload the Rxboot image
                            in ROM and direct it to carry out the
                            download request.
            direct       -  will be done directly by this image.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.9";
        }

        leaf ciscoFlashPartitionName {
          type snmpv2-tc:DisplayString {
            length "0..16";
          }
          description
           "Flash partition name used to refer to a partition
            by the system. This can be any alpha-numeric character
            string of the form AAAAAAAAnn, where A represents an
            optional alpha character and n a numeric character.
            Any numeric characters must always form the trailing
            part of the string. The system will strip off the alpha
            characters and use the numeric portion to map to a
            partition index.
            Flash operations get directed to a device partition
            based on this name.
            The system has a concept of a default partition. This
            would be the first partition in the device. The system
            directs an operation to the default partition whenever
            a partition name is not specified.
            The partition name is therefore mandatory except when
            the operation is being done on the default partition, or
            the device has just one partition (is not partitioned).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.10";
        }

        leaf ciscoFlashPartitionNeedErasure {
          type boolean;
          description
           "This object indicates whether a partition requires
            erasure before any write operations can be done in it.
            A management station should therefore retrieve this
            object prior to attempting any write operation.
            A partition requires erasure after it becomes full
            free space left is less than or equal to the
            (filesystem file header size).
            A partition also requires erasure if the system does
            not find the existence of any file system when it
            boots up.
            The partition may be erased explicitly through the
            erase(5) command, or by using the copyToFlashWithErase(1)
            command.
            If a copyToFlashWithoutErase(2) command is issued
            when this object has the TRUE value, the command
            will fail.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.11";
        }

        leaf ciscoFlashPartitionFileNameLength {
          type int32 {
            range "1..256";
          }
          description
           "Maximum file name length supported by the file
            system.
            Max file name length will depend on the file
            system implemented. Today, all file systems
            support a max length of at least 48 bytes.
            A management entity must use this object when
            prompting a user for, or deriving the Flash file
            name length.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.12";
        }

        leaf ciscoFlashPartitionSizeExtended {
          type yang:gauge64;
          units "bytes";
          description
           "Flash partition size. It should be an integral
            multiple of ciscoFlashDeviceMinPartitionSize.
            If there is a single partition, this size will be equal
            to ciscoFlashDeviceSize.
            
            This object is a 64-bit version of ciscoFlashPartitionSize";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.13";
        }

        leaf ciscoFlashPartitionFreeSpaceExtended {
          type yang:gauge64;
          units "bytes";
          description
           "Free space within a Flash partition.
            Note that the actual size of a file in Flash includes
            a small overhead that represents the file system's
            file header.
            Certain file systems may also have a partition or
            device header overhead to be considered when
            computing the free space.
            Free space will be computed as total partition size
            less size of all existing files (valid/invalid/deleted
            files and including file header of each file),
            less size of any partition header, less size of
            header of next file to be copied in. In short, this
            object will give the size of the largest file that
            can be copied in. The management entity will not be
            expected to know or use any overheads such as file
            and partition header lengths, since such overheads
            may vary from file system to file system.
            Deleted files in Flash do not free up space.
            A partition may have to be erased in order to reclaim
            the space occupied by files.
            
            This object is a 64-bit version of ciscoFlashPartitionFreeSpace";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.14";
        }

        leaf ciscoFlashPartitionLowSpaceNotifThreshold {
          type cisco-qos:Percent;
          description
           "This object specifies the minimum threshold value in percentage
            of free space for each partition. If the free space available
            goes below this threshold value and if
            ciscoFlashPartionLowSpaceNotifEnable is set to true,
            ciscoFlashPartitionLowSpaceNotif will be generated. When the
            available free space comes back to the threshold value
            ciscoFlashPartionLowSpaceRecoveryNotif will be generated.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.1.1.15";
        }
      }
    }

    container ciscoFlashFileTable {
      description
       "Table of information for files in a Flash partition.";
      smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.1";

      list ciscoFlashFileEntry {
        key "ciscoFlashDeviceIndex ciscoFlashPartitionIndex ciscoFlashFileIndex";
        description
         "An entry in the table of Flash file properties
          for each initialized Flash partition. Each entry
          represents a file and gives details about the file.
          An entry is indexed using the device number,
          partition number within the device, and file
          number within the partition.";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.1.1";

        leaf ciscoFlashDeviceIndex {
          type leafref {
            path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
          }
        }

        leaf ciscoFlashPartitionIndex {
          type leafref {
            path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionIndex";
          }
        }

        leaf ciscoFlashFileIndex {
          type uint32 {
            range "1..4294967295";
          }
          description
           "Flash file sequence number used to index within
            a Flash partition directory table.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.1.1.1";
        }

        leaf ciscoFlashFileSize {
          type uint32;
          units "bytes";
          description
           "Size of the file in bytes. Note that this size does
            not include the size of the filesystem file header.
            File size will always be non-zero.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.1.1.2";
        }

        leaf ciscoFlashFileChecksum {
          type CISCO-FLASH-MIB:ChecksumString;
          description
           "File checksum stored in the file header. This
            checksum is computed and stored when the file is
            written into Flash. It serves to validate the data
            written into Flash.
            Whereas the system will generate and store the checksum
            internally in hexadecimal form, this object will
            provide the checksum in a string form.
            The checksum will be available for all valid and
            invalid-checksum files.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.1.1.3";
        }

        leaf ciscoFlashFileStatus {
          type enumeration {
            enum "deleted" {
              value "1";
            }
            enum "invalidChecksum" {
              value "2";
            }
            enum "valid" {
              value "3";
            }
          }
          description
           "Status of a file.
            A file could be explicitly deleted if the file system
            supports such a user command facility. Alternately,
            an existing good file would be automatically deleted
            if another good file with the same name were copied in.
            Note that deleted files continue to occupy prime
            Flash real estate.
            
            A file is marked as having an invalid checksum if any
            checksum mismatch was detected while writing or reading
            the file. Incomplete files (files truncated either
            because of lack of free space, or a network download
            failure) are also written with a bad checksum and
            marked as invalid.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.1.1.4";
        }

        leaf ciscoFlashFileName {
          type snmpv2-tc:DisplayString {
            length "1..255";
          }
          description
           "Flash file name as specified by the user copying in
            the file. The name should not include the colon (:)
            character as it is a special separator character used
            to delineate the device name, partition name, and the
            file name.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.1.1.5";
        }

        leaf ciscoFlashFileType {
          type CISCO-FLASH-MIB:FlashFileType;
          description
           "Type of the file.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.1.1.6";
        }

        leaf ciscoFlashFileDate {
          type snmpv2-tc:DateAndTime;
          description
           "The time at which this file was created.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.1.1.7";
        }
      }
    }

    container ciscoFlashFileByTypeTable {
      description
       "Table of information for files on the manageable
        flash devices sorted by File Types.";
      smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.2";

      list ciscoFlashFileByTypeEntry {
        key "ciscoFlashFileType ciscoFlashDeviceIndex ciscoFlashPartitionIndex ciscoFlashFileIndex";
        description
         "An entry in the table of Flash file properties
          for each initialized Flash partition. Each entry
          represents a file sorted by file type.
          
          This table contains exactly the same set of rows
          as are contained in the ciscoFlashFileTable but
          in a different order, i.e., ordered by
          
          the type of file, given by  ciscoFlashFileType;
          the device number, given by ciscoFlashDeviceIndex;
          the partition number within the device, given by
          ciscoFlashPartitionIndex;
          the file number within the partition, given by
          ciscoFlashFileIndex.";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.2.1";

        leaf ciscoFlashFileType {
          type leafref {
            path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashFileTable/CISCO-FLASH-MIB:ciscoFlashFileEntry/CISCO-FLASH-MIB:ciscoFlashFileType";
          }
        }

        leaf ciscoFlashDeviceIndex {
          type leafref {
            path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
          }
        }

        leaf ciscoFlashPartitionIndex {
          type leafref {
            path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionIndex";
          }
        }

        leaf ciscoFlashFileIndex {
          type leafref {
            path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashFileTable/CISCO-FLASH-MIB:ciscoFlashFileEntry/CISCO-FLASH-MIB:ciscoFlashFileIndex";
          }
        }

        leaf ciscoFlashFileByTypeSize {
          type uint32;
          units "bytes";
          description
           "This object represents exactly the
            same info as ciscoFlashFileSize
            object in ciscoFlashFileTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.2.1.1";
        }

        leaf ciscoFlashFileByTypeChecksum {
          type CISCO-FLASH-MIB:ChecksumString;
          description
           "This object represents exactly the
            same info as ciscoFlashFileChecksum
            object in ciscoFlashFileTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.2.1.2";
        }

        leaf ciscoFlashFileByTypeStatus {
          type enumeration {
            enum "deleted" {
              value "1";
            }
            enum "invalidChecksum" {
              value "2";
            }
            enum "valid" {
              value "3";
            }
          }
          description
           "This object represents exactly the
            same info as ciscoFlashFileStatus
            object in ciscoFlashFileTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.2.1.3";
        }

        leaf ciscoFlashFileByTypeName {
          type snmpv2-tc:DisplayString {
            length "1..255";
          }
          description
           "This object represents exactly the
            same info as ciscoFlashFileName
            object in ciscoFlashFileTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.2.1.4";
        }

        leaf ciscoFlashFileByTypeDate {
          type snmpv2-tc:DateAndTime;
          description
           "This object represents exactly the
            same info as ciscoFlashFileDate
            object in ciscoFlashFileTable.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2.2.1.5";
        }
      }
    }

    container ciscoFlashCopyTable {
      description
       "A table of Flash copy operation entries. Each
        entry represents a Flash copy operation (to or
        from Flash) that has been initiated.";
      smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1";

      list ciscoFlashCopyEntry {
        key "ciscoFlashCopySerialNumber";
        description
         "A Flash copy operation entry. Each entry consists
          of a command, a source, and optional parameters such
          as protocol to be used, a destination, a server address,
          etc.
          
          A management station wishing to create an entry should
          first generate a pseudo-random serial number to be used
          as the index to this sparse table.  The station should
          then create the associated instance of the row status
          object. It must also, either in the same or in successive
          PDUs, create the associated instance of the command and
          parameter objects. It should also modify the default values
          for any of the parameter objects if the defaults are not
          appropriate.
          
          Once the appropriate instances of all the command
          objects have been created, either by an explicit SNMP
          set request or by default, the row status should be set
          to active to initiate the operation. Note that this entire
          procedure may be initiated via a single set request which
          specifies a row status  of createAndGo as well as specifies
          valid values for the non-defaulted parameter objects.
          
          Once an operation has been activated, it cannot be
          stopped.
          
          Once the operation completes, the management station should
          retrieve the value of the status object (and time if
          desired), and delete the entry.  In order to prevent old
          entries from clogging the table, entries will be aged out,
          but an entry will never be deleted within 5 minutes of
          completing.";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1";

        leaf ciscoFlashCopySerialNumber {
          type int32 {
            range "0..2147483647";
          }
          description
           "Object which specifies a unique entry in the
            table. A management station wishing to initiate a
            copy operation should use a pseudo-random value for
            this object when creating or modifying an instance of
            a ciscoFlashCopyEntry.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.1";
        }

        leaf ciscoFlashCopyCommand {
          type enumeration {
            enum "copyToFlashWithErase" {
              value "1";
            }
            enum "copyToFlashWithoutErase" {
              value "2";
            }
            enum "copyFromFlash" {
              value "3";
            }
            enum "copyFromFlhLog" {
              value "4";
            }
          }
          description
           "The copy command to be executed. Mandatory.
            Note that it is possible for a system to support
            multiple file systems (different file systems on
            different Flash devices, or different file systems
            on different partitions within a device). Each such
            file system may support only a subset of these commands.
            If a command is unsupported, the invalidOperation(3)
            error will be reported in the operation status.
            
            Command                 Remarks
            copyToFlashWithErase    Copy a file to flash; erase
                                    flash before copy.
                                    Use the TFTP or rcp protocol.
            copyToFlashWithoutErase Copy a file to flash; do not
                                    erase.
                                    Note that this command will fail
                                    if the PartitionNeedErasure
                                    object specifies that the
                                    partition being copied to needs
                                    erasure.
                                    Use the TFTP or rcp protocol.
            copyFromFlash           Copy a file from flash using
                                    the TFTP, rcp or lex protocol.
                                    Note that the lex protocol
                                    can only be used to copy to a
                                    lex device.
            copyFromFlhLog          Copy contents of FLH log to
                                    server using TFTP protocol.
            
            
            Command table           Parameters
            copyToFlashWithErase    CopyProtocol
                                    CopyServerAddress
                                    CopySourceName
                                    CopyDestinationName (opt)
                                    CopyRemoteUserName (opt)
                                    CopyNotifyOnCompletion (opt)
            copyToFlashWithoutErase CopyProtocol
                                    CopyServerAddress
                                    CopySourceName
                                    CopyDestinationName (opt)
                                    CopyRemoteUserName (opt)
                                    CopyNotifyOnCompletion (opt)
            copyFromFlash           CopyProtocol
                                    CopyServerAddress
                                    CopySourceName
                                    CopyDestinationName (opt)
                                    CopyRemoteUserName (opt)
                                    CopyNotifyOnCompletion (opt)
            copyFromFlhLog          CopyProtocol
                                    CopyServerAddress
                                    CopyDestinationName
                                    CopyNotifyOnCompletion (opt)";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.2";
        }

        leaf ciscoFlashCopyProtocol {
          type enumeration {
            enum "tftp" {
              value "1";
            }
            enum "rcp" {
              value "2";
            }
            enum "lex" {
              value "3";
            }
            enum "ftp" {
              value "4";
            }
            enum "scp" {
              value "5";
            }
            enum "sftp" {
              value "6";
            }
          }
          description
           "The protocol to be used for any copy. Optional.
            Will default to tftp if not specified.
            
            Since feature support depends on a software release,
            version number within the release, platform, and
            maybe the image type (subset type), a management
            station would be expected to somehow determine
            the protocol support for a command.";
          smiv2:defval "tftp";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.3";
        }

        leaf ciscoFlashCopyServerAddress {
          type inet:ipv4-address;
          status deprecated;
          description
           "The server address to be used for any copy. Optional.
            Will default to 'FFFFFFFF'H  (or 255.255.255.255).
            
            Since this object can just hold only IPv4 Transport
            type, it is deprecated and replaced by
            ciscoFlashCopyServerAddrRev1.";
          smiv2:defval "'ffffffff'H";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.4";
        }

        leaf ciscoFlashCopySourceName {
          type snmpv2-tc:DisplayString {
            length "1..255";
          }
          description
           "Source file name, either in Flash or on a server,
            depending on the type of copy command. Mandatory.
            
            For a copy from Flash:
            File name must be of the form
                    [device>:][:]
            where  is a value obtained from FlashDeviceName,
                     is obtained from FlashPartitionName
                and  is the name of a file in Flash.
            A management station could derive its own partition name
            as per the description for the ciscoFlashPartitionName
            object.
            If <device> is not specified, the default Flash device
            will be assumed.
            If <partition> is not specified, the default partition
            will be assumed. If a device is not partitioned into 2
            or more partitions, this value may be left out.
            
            For a copy to Flash, the file name will be as per
            the file naming conventions and path to the file on
            the server.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.5";
        }

        leaf ciscoFlashCopyDestinationName {
          type snmpv2-tc:DisplayString {
            length "0..255";
          }
          description
           "Destination file name.
            
            For a copy to Flash:
            File name must be of the form
                    {device>:][<partition>:]<file>
            where <device> is a value obtained from FlashDeviceName,
                  <partition> is obtained from FlashPartitionName
              and <file> is any character string that does not have
            embedded colon characters.
            A management station could derive its own partition name
            as per the description for the ciscoFlashPartitionName
            object.
            If <device> is not specified, the default Flash device
            will be assumed.
            If <partition> is not specified, the default partition
            will be assumed. If a device is not partitioned into 2
            or more partitions, this value may be left out.
            If <file> is not specified, it will default to <file>
            specified in ciscoFlashCopySourceName.
            
            For a copy from Flash via tftp or rcp, the file name will be
            as per the file naming conventions and destination sub-directory
            on the server. If not specified, <file> from the source
            file name will be used.
            For a copy from Flash via lex, this string will consist
            of numeric characters specifying the interface on the
            lex box that will receive the source flash image.";
          smiv2:defval "";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.6";
        }

        leaf ciscoFlashCopyRemoteUserName {
          type snmpv2-tc:DisplayString {
            length "1..255";
          }
          description
           "Remote user name for copy via rcp protocol. Optional.
            This object will be ignored for protocols other than
            rcp.
            If specified, it will override the remote user-name
            configured through the
                    rcmd remote-username
            configuration command.
            The remote user-name is sent as the server user-name
            in an rcp command request sent by the system to a
            remote rcp server.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.7";
        }

        leaf ciscoFlashCopyStatus {
          type enumeration {
            enum "copyOperationPending" {
              value "0";
            }
            enum "copyInProgress" {
              value "1";
            }
            enum "copyOperationSuccess" {
              value "2";
            }
            enum "copyInvalidOperation" {
              value "3";
            }
            enum "copyInvalidProtocol" {
              value "4";
            }
            enum "copyInvalidSourceName" {
              value "5";
            }
            enum "copyInvalidDestName" {
              value "6";
            }
            enum "copyInvalidServerAddress" {
              value "7";
            }
            enum "copyDeviceBusy" {
              value "8";
            }
            enum "copyDeviceOpenError" {
              value "9";
            }
            enum "copyDeviceError" {
              value "10";
            }
            enum "copyDeviceNotProgrammable" {
              value "11";
            }
            enum "copyDeviceFull" {
              value "12";
            }
            enum "copyFileOpenError" {
              value "13";
            }
            enum "copyFileTransferError" {
              value "14";
            }
            enum "copyFileChecksumError" {
              value "15";
            }
            enum "copyNoMemory" {
              value "16";
            }
            enum "copyUnknownFailure" {
              value "17";
            }
            enum "copyInvalidSignature" {
              value "18";
            }
            enum "copyProhibited" {
              value "19";
            }
          }
          description
           "The status of the specified copy operation.
            
            copyOperationPending :
                    operation request is received and
                    pending for validation and process
            
            copyInProgress :
                    specified operation is active
            
            copyOperationSuccess :
                    specified operation is supported and
                    completed successfully
            
            copyInvalidOperation :
                    command invalid or command-protocol-device
                    combination unsupported
            
            copyInvalidProtocol :
                    invalid protocol specified
            
            copyInvalidSourceName :
                    invalid source file name specified
                    For the  copy from flash to lex operation, this
                    error code will be returned when the source file
                    is not a valid lex image.
            
            copyInvalidDestName :
                    invalid target name (file or partition or
                    device name) specified
                    For the  copy from flash to lex operation, this
                    error code will be returned when no lex devices
                    are connected to the router or when an invalid
                    lex interface number has been specified in
                    the destination string.
            
            copyInvalidServerAddress :
                    invalid server address specified
            
            copyDeviceBusy :
                    specified device is in use and locked by
                    another process
            
            copyDeviceOpenError :
                    invalid device name
            
            copyDeviceError :
                    device read, write or erase error
            
            copyDeviceNotProgrammable :
                    device is read-only but a write or erase
                    operation was specified
            
            copyDeviceFull :
                    device is filled to capacity
            
            copyFileOpenError :
                    invalid file name; file not found in partition
            
            copyFileTransferError :
                    file transfer was unsuccessfull; network failure
            
            copyFileChecksumError :
                    file checksum in Flash failed
            
            copyNoMemory :
                    system running low on memory
            
            copyUnknownFailure :
                    failure unknown
            
            copyProhibited:
                  stop user from overwriting current boot image file.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.8";
        }

        leaf ciscoFlashCopyNotifyOnCompletion {
          type boolean;
          description
           "Specifies whether or not a notification should be
            generated on the completion of the copy operation.
            If specified, ciscoFlashCopyCompletionTrap
            will be generated. It is the responsibility of the
            management entity to ensure that the SNMP administrative
            model is configured in such a way as to allow the
            notification to be delivered.";
          smiv2:defval "false";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.9";
        }

        leaf ciscoFlashCopyTime {
          type yang:timeticks;
          description
           "Time taken for the copy operation. This object will
            be like a stopwatch, starting when the operation
            starts, stopping when the operation completes.
            If a management entity keeps a database of completion
            times for various operations, it can then use the
            stopwatch capability to display percentage completion
            time.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.10";
        }

        leaf ciscoFlashCopyEntryStatus {
          type snmpv2-tc:RowStatus;
          description
           "The status of this table entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.11";
        }

        leaf ciscoFlashCopyVerify {
          type boolean;
          description
           "Specifies whether the file that is copied need to
            be verified for integrity / authenticity, after
            copy succeeds. If it is set to true, and if the
            file that is copied doesn't have integrity /authenticity
            attachement, or the integrity / authenticity check
            fails, then the command will be aborted, and the file
            that is copied will be deleted from the destination
            file system.";
          smiv2:defval "false";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.12";
        }

        leaf ciscoFlashCopyServerAddrType {
          type inet-address:InetAddressType;
          description
           "This object indicates the transport type of the
            address contained in
            ciscoFlashCopyServerAddrRev1. Optional.
            Will default to '1' (IPv4 address type).";
          smiv2:defval "ipv4";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.13";
        }

        leaf ciscoFlashCopyServerAddrRev1 {
          type inet-address:InetAddress;
          description
           "The server address to be used for any copy. Optional.
            Will default to 'FFFFFFFF'H  (or 255.255.255.255).
            
            The Format of this address depends on the value of the
            ciscoFlashCopyServerAddrType.
            
            This object deprecates the old
            ciscoFlashCopyServerAddress object.";
          smiv2:defval "'ffffffff'H";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.14";
        }

        leaf ciscoFlashCopyRemotePassword {
          type snmpv2-tc:DisplayString {
            length "1..40";
          }
          description
           "Password used by ftp, sftp or scp for copying a file
            to/from an ftp/sftp/scp server. This object must be
            created when the ciscoFlashCopyProtocol is ftp, sftp or
            scp. Reading it returns a zero-length string for
            security reasons.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.1.1.15";
        }
      }
    }

    container ciscoFlashPartitioningTable {
      description
       "A table of Flash partitioning operation entries. Each
        entry represents a Flash partitioning operation that
        has been initiated.";
      smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.2";

      list ciscoFlashPartitioningEntry {
        key "ciscoFlashPartitioningSerialNumber";
        description
         "A Flash partitioning operation entry. Each entry
          consists of the command, the target device, the
          partition count, and optionally the partition sizes.
          
          A management station wishing to create an entry should
          first generate a pseudo-random serial number to be used
          as the index to this sparse table.  The station should
          then create the associated instance of the row status
          object. It must also, either in the same or in successive
          PDUs, create the associated instance of the command and
          parameter objects. It should also modify the default values
          for any of the parameter objects if the defaults are not
          appropriate.
          
          Once the appropriate instances of all the command
          objects have been created, either by an explicit SNMP
          set request or by default, the row status should be set
          to active to initiate the operation. Note that this entire
          procedure may be initiated via a single set request which
          specifies a row status of createAndGo as well as specifies
          valid values for the non-defaulted parameter objects.
          
          Once an operation has been activated, it cannot be
          stopped.
          
          Once the operation completes, the management station should
          retrieve the value of the status object (and time if
          desired), and delete the entry.  In order to prevent old
          entries from clogging the table, entries will be aged out,
          but an entry will never be deleted within 5 minutes of
          completing.";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.2.1";

        leaf ciscoFlashPartitioningSerialNumber {
          type int32 {
            range "0..2147483647";
          }
          description
           "Object which specifies a unique entry in the partitioning
            operations table. A management station wishing to initiate
            a partitioning operation should use a pseudo-random value
            for this object when creating or modifying an instance of
            a ciscoFlashPartitioningEntry.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.2.1.1";
        }

        leaf ciscoFlashPartitioningCommand {
          type enumeration {
            enum "partition" {
              value "1";
            }
          }
          description
           "The partitioning command to be executed. Mandatory.
            If the command is unsupported, the
            partitioningInvalidOperation
            error will be reported in the operation status.
            
            Command                 Remarks
            partition               Partition a Flash device.
                                    All the prerequisites for
                                    partitioning must be met for
                                    this command to succeed.
            
            Command table           Parameters
            1) partition            PartitioningDestinationName
                                    PartitioningPartitionCount
                                    PartitioningPartitionSizes (opt)
                                    PartitioningNotifyOnCompletion (opt)";
          smiv2:defval "partition";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.2.1.2";
        }

        leaf ciscoFlashPartitioningDestinationName {
          type snmpv2-tc:DisplayString {
            length "0..255";
          }
          description
           "Destination device name. This name will be the value
            obtained from FlashDeviceName.
            If the name is not specified, the default Flash device
            will be assumed.";
          smiv2:defval "";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.2.1.3";
        }

        leaf ciscoFlashPartitioningPartitionCount {
          type uint32 {
            range "1..4294967295";
          }
          description
           "This object is used to specify the number of
            partitions to be created. Its value cannot exceed
            the value of ciscoFlashDeviceMaxPartitions.
            
            To undo partitioning (revert to a single partition),
            this object must have the value 1.";
          smiv2:defval "2";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.2.1.4";
        }

        leaf ciscoFlashPartitioningPartitionSizes {
          type snmpv2-tc:DisplayString;
          description
           "This object is used to explicitly specify the size
            of each partition to be created.
            The size of each partition will be in units of
            ciscoFlashDeviceMinPartitionSize.
            The value of this object will be in the form:
                    <part1>:<part2>...:<partn>
            
            If partition sizes are not specified, the system
            will calculate default sizes based on the partition
            count, the minimum partition size, and the device
            size. Partition size need not be specified when
            undoing partitioning (partition count is 1).
            If partition sizes are specified, the number of
            sizes specified must exactly match the partition
            count. If not, the partitioning command will be
            rejected with the invalidPartitionSizes error .";
          smiv2:defval "";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.2.1.5";
        }

        leaf ciscoFlashPartitioningStatus {
          type enumeration {
            enum "partitioningInProgress" {
              value "1";
            }
            enum "partitioningOperationSuccess" {
              value "2";
            }
            enum "partitioningInvalidOperation" {
              value "3";
            }
            enum "partitioningInvalidDestName" {
              value "4";
            }
            enum "partitioningInvalidPartitionCount" {
              value "5";
            }
            enum "partitioningInvalidPartitionSizes" {
              value "6";
            }
            enum "partitioningDeviceBusy" {
              value "7";
            }
            enum "partitioningDeviceOpenError" {
              value "8";
            }
            enum "partitioningDeviceError" {
              value "9";
            }
            enum "partitioningNoMemory" {
              value "10";
            }
            enum "partitioningUnknownFailure" {
              value "11";
            }
          }
          description
           "The status of the specified partitioning operation.
            partitioningInProgress :
                    specified operation is active
            
            partitioningOperationSuccess :
                    specified operation is supported and completed
                    successfully
            
            partitioningInvalidOperation :
                    command invalid or command-protocol-device
                    combination unsupported
            
            partitioningInvalidDestName :
                    invalid target name (file or partition or
                    device name) specified
            
            partitioningInvalidPartitionCount :
                    invalid partition count specified for the
                    partitioning command
            
            partitioningInvalidPartitionSizes :
                    invalid partition size, or invalid count of
                    partition sizes
            
            partitioningDeviceBusy :
                    specified device is in use and locked by
                    another process
            
            partitioningDeviceOpenError :
                    invalid device name
            
            partitioningDeviceError :
                    device read, write or erase error
            
            partitioningNoMemory :
                    system running low on memory
            
            partitioningUnknownFailure :
                    failure unknown";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.2.1.6";
        }

        leaf ciscoFlashPartitioningNotifyOnCompletion {
          type boolean;
          description
           "Specifies whether or not a notification should be
            generated on the completion of the partitioning operation.
            If specified, ciscoFlashPartitioningCompletionTrap
            will be generated. It is the responsibility of the
            management entity to ensure that the SNMP administrative
            model is configured in such a way as to allow the
            notification to be delivered.";
          smiv2:defval "false";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.2.1.7";
        }

        leaf ciscoFlashPartitioningTime {
          type yang:timeticks;
          description
           "Time taken for the operation. This object will
            be like a stopwatch, starting when the operation
            starts, stopping when the operation completes.
            If a management entity keeps a database of completion
            times for various operations, it can then use the
            stopwatch capability to display percentage completion
            time.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.2.1.8";
        }

        leaf ciscoFlashPartitioningEntryStatus {
          type snmpv2-tc:RowStatus;
          description
           "The status of this table entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.2.1.9";
        }
      }
    }

    container ciscoFlashMiscOpTable {
      description
       "A table of misc Flash operation entries. Each
        entry represents a Flash operation that
        has been initiated.";
      smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.3";

      list ciscoFlashMiscOpEntry {
        key "ciscoFlashMiscOpSerialNumber";
        description
         "A Flash operation entry. Each entry consists of a
          command, a target, and any optional parameters.
          
          A management station wishing to create an entry should
          first generate a pseudo-random serial number to be used
          as the index to this sparse table.  The station should
          then create the associated instance of the row status
          object. It must also, either in the same or in successive
          PDUs, create the associated instance of the command and
          parameter objects. It should also modify the default values
          for any of the parameter objects if the defaults are not
          appropriate.
          
          Once the appropriate instances of all the command
          objects have been created, either by an explicit SNMP
          set request or by default, the row status should be set
          to active to initiate the operation. Note that this entire
          procedure may be initiated via a single set request which
          specifies a row status of createAndGo as well as specifies
          valid values for the non-defaulted parameter objects.
          
          Once an operation has been activated, it cannot be
          stopped.
          
          Once the operation completes, the management station should
          retrieve the value of the status object (and time if
          desired), and delete the entry.  In order to prevent old
          entries from clogging the table, entries will be aged out,
          but an entry will never be deleted within 5 minutes of
          completing.";
        smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.3.1";

        leaf ciscoFlashMiscOpSerialNumber {
          type int32 {
            range "0..2147483647";
          }
          description
           "Object which specifies a unique entry in the
            table. A management station wishing to initiate a
            flash operation should use a pseudo-random value for
            this object when creating or modifying an instance of
            a ciscoFlashMiscOpEntry.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.3.1.1";
        }

        leaf ciscoFlashMiscOpCommand {
          type enumeration {
            enum "erase" {
              value "1";
            }
            enum "verify" {
              value "2";
            }
            enum "delete" {
              value "3";
            }
            enum "undelete" {
              value "4";
            }
            enum "squeeze" {
              value "5";
            }
            enum "format" {
              value "6";
            }
          }
          description
           "The command to be executed. Mandatory.
            Note that it is possible for a system to support
            multiple file systems (different file systems on
            different Flash devices, or different file systems
            on different partitions within a device). Each such
            file system may support only a subset of these commands.
            If a command is unsupported, the miscOpInvalidOperation(3)
            error will be reported in the operation status.
            
            Command         Remarks
            erase           Erase flash.
            verify          Verify flash file checksum.
            delete          Delete a file.
            undelete        Revive a deleted file .
                            Note that there are limits on
                            the number of times a file can
                            be deleted and undeleted. When
                            this limit is exceeded, the
                            system will return the appropriate
                            error.
            squeeze         Recover space occupied by
                            deleted files. This command
                            preserves the good files, erases
                            out the file system, then restores
                            the preserved good files.
            format          Format a flash device.
            
            Command table   Parameters
            erase           MiscOpDestinationName
                            MiscOpNotifyOnCompletion (opt)
            verify          MiscOpDestinationName
                            MiscOpNotifyOnCompletion (opt)
            delete          MiscOpDestinationName
                            MiscOpNotifyOnCompletion (opt)
            undelete        MiscOpDestinationName
                            MiscOpNotifyOnCompletion (opt)
            squeeze         MiscOpDestinationName
                            MiscOpNotifyOnCompletion (opt)
            format          MiscOpDestinationName
                            MiscOpNotifyOnCompletion (opt)";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.3.1.2";
        }

        leaf ciscoFlashMiscOpDestinationName {
          type snmpv2-tc:DisplayString {
            length "0..255";
          }
          description
           "Destination file, or partition name.
            File name must be of the form
                    [device>:][<partition>:]<file>
            where <device> is a value obtained from FlashDeviceName,
                  <partition> is obtained from FlashPartitionName
              and <file> is the name of a file in Flash.
            While leading and/or trailing whitespaces are acceptable,
            no whitespaces are allowed within the path itself.
            
            A management station could derive its own partition name
            as per the description for the ciscoFlashPartitionName
            object.
            If <device> is not specified, the default Flash device
            will be assumed.
            If <partition> is not specified, the default partition
            will be assumed. If a device is not partitioned into 2
            or more partitions, this value may be left out.
            
            For an operation on a partition, eg., the erase
            command, this object would specify the partition name
            in the form:
                    [device>:][<partition>:]";
          smiv2:defval "";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.3.1.3";
        }

        leaf ciscoFlashMiscOpStatus {
          type enumeration {
            enum "miscOpInProgress" {
              value "1";
            }
            enum "miscOpOperationSuccess" {
              value "2";
            }
            enum "miscOpInvalidOperation" {
              value "3";
            }
            enum "miscOpInvalidDestName" {
              value "4";
            }
            enum "miscOpDeviceBusy" {
              value "5";
            }
            enum "miscOpDeviceOpenError" {
              value "6";
            }
            enum "miscOpDeviceError" {
              value "7";
            }
            enum "miscOpDeviceNotProgrammable" {
              value "8";
            }
            enum "miscOpFileOpenError" {
              value "9";
            }
            enum "miscOpFileDeleteFailure" {
              value "10";
            }
            enum "miscOpFileUndeleteFailure" {
              value "11";
            }
            enum "miscOpFileChecksumError" {
              value "12";
            }
            enum "miscOpNoMemory" {
              value "13";
            }
            enum "miscOpUnknownFailure" {
              value "14";
            }
            enum "miscOpSqueezeFailure" {
              value "18";
            }
            enum "miscOpNoSuchFile" {
              value "19";
            }
            enum "miscOpFormatFailure" {
              value "20";
            }
          }
          description
           "The status of the specified operation.
            miscOpInProgress :
                    specified operation is active
            
            miscOpOperationSuccess :
                    specified operation is supported and completed
                    successfully
            
            miscOpInvalidOperation :
                    command invalid or command-protocol-device
                    combination unsupported
            
            miscOpInvalidDestName :
                    invalid target name (file or partition or
                    device name) specified
            
            miscOpDeviceBusy :
                    specified device is in use and locked by another
                    process
            
            miscOpDeviceOpenError :
                    invalid device name
            
            miscOpDeviceError :
                    device read, write or erase error
            
            miscOpDeviceNotProgrammable :
                    device is read-only but a write or erase
                    operation was specified
            
            miscOpFileOpenError :
                    invalid file name; file not found in partition
            
            miscOpFileDeleteFailure :
                    file could not be deleted; delete count exceeded
            
            miscOpFileUndeleteFailure :
                    file could not be undeleted; undelete count
                    exceeded
            
            miscOpFileChecksumError :
                    file has a bad checksum
            
            miscOpNoMemory :
                    system running low on memory
            
            miscOpUnknownFailure :
                    failure unknown
            
            miscOpSqueezeFailure :
                    the squeeze operation failed
            
            miscOpNoSuchFile :
                    a valid but nonexistent file name was specified
            
            miscOpFormatFailure :
                    the format operation failed";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.3.1.4";
        }

        leaf ciscoFlashMiscOpNotifyOnCompletion {
          type boolean;
          description
           "Specifies whether or not a notification should be
            generated on the completion of an operation.
            If specified, ciscoFlashMiscOpCompletionTrap
            will be generated. It is the responsibility of the
            management entity to ensure that the SNMP administrative
            model is configured in such a way as to allow the
            notification to be delivered.";
          smiv2:defval "false";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.3.1.5";
        }

        leaf ciscoFlashMiscOpTime {
          type yang:timeticks;
          description
           "Time taken for the operation. This object will
            be like a stopwatch, starting when the operation
            starts, stopping when the operation completes.
            If a management entity keeps a database of completion
            times for various operations, it can then use the
            stopwatch capability to display percentage completion
            time.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.3.1.6";
        }

        leaf ciscoFlashMiscOpEntryStatus {
          type snmpv2-tc:RowStatus;
          description
           "The status of this table entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.4.1.9.9.10.1.2.3.1.7";
        }
      }
    }
  }

  notification ciscoFlashCopyCompletionTrap {
    description
     "A ciscoFlashCopyCompletionTrap is sent at the
      completion of a flash copy operation if such a trap
      was requested when the operation was initiated.";
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3.0.1";

    container object-1 {

      leaf ciscoFlashCopySerialNumber {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashCopyTable/CISCO-FLASH-MIB:ciscoFlashCopyEntry/CISCO-FLASH-MIB:ciscoFlashCopySerialNumber";
        }
      }

      leaf ciscoFlashCopyStatus {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashCopyTable/CISCO-FLASH-MIB:ciscoFlashCopyEntry/CISCO-FLASH-MIB:ciscoFlashCopyStatus";
        }
      }
    }
  }

  notification ciscoFlashPartitioningCompletionTrap {
    description
     "A ciscoFlashPartitioningCompletionTrap is sent at the
      completion of a partitioning operation if such a trap
      was requested when the operation was initiated.";
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3.0.2";

    container object-1 {

      leaf ciscoFlashPartitioningSerialNumber {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitioningTable/CISCO-FLASH-MIB:ciscoFlashPartitioningEntry/CISCO-FLASH-MIB:ciscoFlashPartitioningSerialNumber";
        }
      }

      leaf ciscoFlashPartitioningStatus {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitioningTable/CISCO-FLASH-MIB:ciscoFlashPartitioningEntry/CISCO-FLASH-MIB:ciscoFlashPartitioningStatus";
        }
      }
    }
  }

  notification ciscoFlashMiscOpCompletionTrap {
    description
     "A ciscoFlashMiscOpCompletionTrap is sent at the
      completion of a miscellaneous flash operation
      (enumerated in ciscoFlashMiscOpCommand) if such a trap
      was requested when the operation was initiated.";
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3.0.3";

    container object-1 {

      leaf ciscoFlashMiscOpSerialNumber {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashMiscOpTable/CISCO-FLASH-MIB:ciscoFlashMiscOpEntry/CISCO-FLASH-MIB:ciscoFlashMiscOpSerialNumber";
        }
      }

      leaf ciscoFlashMiscOpStatus {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashMiscOpTable/CISCO-FLASH-MIB:ciscoFlashMiscOpEntry/CISCO-FLASH-MIB:ciscoFlashMiscOpStatus";
        }
      }
    }
  }

  notification ciscoFlashDeviceChangeTrap {
    status deprecated;
    description
     "A ciscoFlashDeviceChangeTrap is sent whenever a
      removable Flash device is inserted or removed.";
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3.0.4";

    container object-1 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashDeviceMinPartitionSize {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceMinPartitionSize";
        }
      }
    }

    container object-2 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashDeviceName {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceName";
        }
        status deprecated;
      }
    }
  }

  notification ciscoFlashDeviceInsertedNotif {
    status deprecated;
    description
     "A ciscoFlashDeviceInsertedNotif notification is sent
      whenever a removable Flash device is inserted.";
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3.0.5";

    container object-1 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashDeviceMinPartitionSize {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceMinPartitionSize";
        }
      }
    }

    container object-2 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashDeviceName {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceName";
        }
        status deprecated;
      }
    }
  }

  notification ciscoFlashDeviceRemovedNotif {
    status deprecated;
    description
     "A ciscoFlashDeviceRemovedNotif notification is sent
      whenever a removable Flash device is removed.";
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3.0.6";

    container object-1 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashDeviceName {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceName";
        }
        status deprecated;
      }
    }
  }

  notification ciscoFlashDeviceInsertedNotifRev1 {
    description
     "A ciscoFlashDeviceInsertedNotif notification is sent
      whenever a removable Flash device is inserted
      
      ciscoFlashDeviceInsertedNotifRev1 depcrecates
      ciscoFlashDeviceInsertedNotif since it uses
      ciscoFlashDeviceName as a varbind which is
      deprecated";
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3.0.7";

    container object-1 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashDeviceMinPartitionSize {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceMinPartitionSize";
        }
      }
    }

    container object-2 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashDeviceNameExtended {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceNameExtended";
        }
      }
    }
  }

  notification ciscoFlashDeviceRemovedNotifRev1 {
    description
     "A ciscoFlashDeviceRemovedNotif notification is sent
      whenever a removable Flash device is removed.
      
      ciscoFlashDeviceRemovedNotifRev1 depcrecates
      ciscoFlashDeviceRemovedNotif since it uses
      ciscoFlashDeviceName as a varbind which is
      deprecated";
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3.0.8";

    container object-1 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashDeviceNameExtended {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceNameExtended";
        }
      }
    }
  }

  notification ciscoFlashPartitionLowSpaceNotif {
    description
     "A ciscoFlashPartitionLowSpaceNotif notification is sent
      when the percentage of free space in a flash partition falls
      below ciscoFlashPartitionLowSpaceNotifThreshold.This
      notification will be generated when the value of
      ciscoFlashPartitionLowSpaceNotifEnable is
      true.
      
      ciscoFlashPartitionName indicates the name of the flash
      partition for which this notification has been sent.
      
      ciscoFlashPartitionFreeSpaceExtended indicates the free space
      available with in the flash partition.
      
      ciscoFlashPartitionLowSpaceNotifThreshold indicates the minimum
      threshold value in percentage of free space for each partition.";
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3.0.9";

    container object-1 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashPartitionIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionIndex";
        }
      }

      leaf ciscoFlashPartitionName {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionName";
        }
      }
    }

    container object-2 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashPartitionIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionIndex";
        }
      }

      leaf ciscoFlashPartitionFreeSpaceExtended {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionFreeSpaceExtended";
        }
      }
    }

    container object-3 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashPartitionIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionIndex";
        }
      }

      leaf ciscoFlashPartitionLowSpaceNotifThreshold {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionLowSpaceNotifThreshold";
        }
      }
    }
  }

  notification ciscoFlashPartitionLowSpaceRecoveryNotif {
    description
     "A ciscoFlashPartitionLowSpaceRecoveryNotif notification is sent
      whenever the free space in a flash partition becomes
      normal once it has gone low. This notification will be
      generated
      when the value of ciscoFlashPartitionLowSpaceNotifEnable is
      true. This trap is generated as a recovery notification for
      ciscoFlashPartitionLowSpaceNotif.
      
      ciscoFlashPartitionName indicates the name of the flash
      partition for which this notification has been sent.
      
      ciscoFlashPartitionFreeSpaceExtended indicates the free space
      available with in the flash partition.
      
      ciscoFlashPartitionLowSpaceNotifThreshold indicates the minimum
      threshold value in percentage of free space for each partition.";
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3.0.10";

    container object-1 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashPartitionIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionIndex";
        }
      }

      leaf ciscoFlashPartitionName {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionName";
        }
      }
    }

    container object-2 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashPartitionIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionIndex";
        }
      }

      leaf ciscoFlashPartitionFreeSpaceExtended {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionFreeSpaceExtended";
        }
      }
    }

    container object-3 {

      leaf ciscoFlashDeviceIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashDeviceTable/CISCO-FLASH-MIB:ciscoFlashDeviceEntry/CISCO-FLASH-MIB:ciscoFlashDeviceIndex";
        }
      }

      leaf ciscoFlashPartitionIndex {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionIndex";
        }
      }

      leaf ciscoFlashPartitionLowSpaceNotifThreshold {
        type leafref {
          path "/CISCO-FLASH-MIB:CISCO-FLASH-MIB/CISCO-FLASH-MIB:ciscoFlashPartitionTable/CISCO-FLASH-MIB:ciscoFlashPartitionEntry/CISCO-FLASH-MIB:ciscoFlashPartitionLowSpaceNotifThreshold";
        }
      }
    }
  }

  smiv2:alias "ciscoFlashMIB" {
    smiv2:oid "1.3.6.1.4.1.9.9.10";
  }

  smiv2:alias "ciscoFlashMIBObjects" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.1";
  }

  smiv2:alias "ciscoFlashDevice" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.1";
  }

  smiv2:alias "ciscoFlashChips" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.3";
  }

  smiv2:alias "ciscoFlashPartitions" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4";
  }

  smiv2:alias "ciscoFlashFiles" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.1.4.2";
  }

  smiv2:alias "ciscoFlashOps" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.2";
  }

  smiv2:alias "ciscoFlashMIBTrapPrefix" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3";
  }

  smiv2:alias "ciscoFlashMIBTraps" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.3.0";
  }

  smiv2:alias "ciscoFlashCfg" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.1.4";
  }

  smiv2:alias "ciscoFlashMIBConformance" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.2";
  }

  smiv2:alias "ciscoFlashMIBCompliances" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.2.1";
  }

  smiv2:alias "ciscoFlashMIBGroups" {
    smiv2:oid "1.3.6.1.4.1.9.9.10.2.2";
  }

}
