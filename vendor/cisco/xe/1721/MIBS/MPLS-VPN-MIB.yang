/*
 * Generated by confdc --mib2yang-std
 * Source: mgmt/dmi/model/mib/src/patched/MPLS-VPN-MIB.mib
 */
/*
 * This YANG module has been generated by smidump 0.5.0:
 *
 *      smidump -f yang MPLS-VPN-MIB
 *
 * Do not edit. Edit the source file instead!
 */

module MPLS-VPN-MIB {

  namespace "urn:ietf:params:xml:ns:yang:smiv2:MPLS-VPN-MIB";
  prefix MPLS-VPN-MIB;

  import IF-MIB {
    prefix "if-mib";
  }

  import INET-ADDRESS-MIB {
    prefix "inet-address";
  }

  import SNMP-FRAMEWORK-MIB {
    prefix "snmp-framework";
  }

  import SNMPv2-TC {
    prefix "snmpv2-tc";
  }

  import ietf-yang-smiv2 {
    prefix "smiv2";
  }

  import ietf-yang-types {
    prefix "yang";
  }

  organization
   "Provider Provisioned Virtual Private
    Networks Working Group.";

  contact
   "        Thomas D. Nadeau
    tnadeau@cisco.com
    
    Luyuan Fang
    luyuanfang@att.com
    
    Stephen Brannon
    
    Fabio M. Chiussi
    fabio@bell-labs.com
    
    Joseph Dube
    jdube@avici.com
    
    Martin Tatham
    martin.tatham@bt.com
    
    Harmen van der Linde
    hvdl@att.com
    
    Comments and discussion to ppvpn@ietf.org";

  description
   "This MIB contains managed object definitions for the
    Multiprotocol Label Switching (MPLS)/Border Gateway
    
    
    Protocol (BGP) Virtual Private Networks (VPNs) as
    defined in : Rosen, E., Viswanathan, A., and R.
    Callon, Multiprotocol Label Switching Architecture,
    RFC3031, January 2001.";

  revision 2001-10-15 {
    description
     "Fixed compilation errors from last version. 
      
      Changed mplsVpnInterfaceVpnRouteDistProtocol to be a BITS
      structure to allow more than one to be selected.
      
      Changed mplsIfDown -> mplsVrfIfDown
      Changed mplsIfUp -> mplsVrfIfUp";
  }

  revision 2001-10-05 {
    description
     "Added integer index and removed route distinguisher index 
      from mplsVpnVrfRouteTargetTable.
      
      Removed mplsVpn ifType; simply use mpls(166) ifType for
      MPLS VPN-enabled interfaces instead.
      
      Removed interface and protocol-related objects from
      mplsVpnVrfTable.
      
      Moved mplsVpnVrfConfMaxPossibleRoutes from 
      mplsVpnVrfTable to scalar object.
      
      Removed mplsVpnActiveVrfInterfaces scalar object.
      Removed mplsVpnVrfUpTime object from mplsVpnVrfTable.
      
      Added MplsVpnVrfBgpNbrPrefixTable providing a linkage with
      the bgp4PathAttrTable of the BGPv4 MIB.";
  }

  revision 2001-07-17 {
    description
     "Removed mplsVpnVrfRouteTargetImport/Export from route target
      table, and modified indexing to better reflect N <> R
      distribution policy. Also added new object called
      mplsVpnVrfRouteTargetType which denotes import/export
      policy for the specified route target. 
      
      Added mplsVpnInterfaceConfRowStatus which allows for
      an interface to be associated with a VPN through SNMP
      configuration.
      
      
      Added VrfName to index of VrfInterfaceConfEntry which allows
      interfaces to be associated with the appropriate VRF.
      
      Modified description of mplsVpnVrfConfMaxPossibleRoutes and
      mplsVpnVrfConfMaxRoutes to allow for undetermined value.
      
      Removed 'both' enumerated value in mplsVpnVrfBgpNbrRole.
      
      Updated example to reflect these changes.";
  }

  revision 2001-07-10 {
    description
     "Renamed mplsNumVrfSecViolationThreshExceeded to 
      mplsNumVrfSecIllegalLabelThreshExceeded, and removed
      mplsVpnInterfaceConfIndex from varbind.
      
      Changed MplsVpnId TC from SnmpAdminString to OCTET STRING.
      
      Added mplsVpnVrfSecIllegalLabelRcvThresh to 
      mplsVpnVrfSecEntry.
      
      Changed duplicate mplsVpnVrfRouteTargetImport in 
      mplsVpnVrfRouteTargetEntry INDEX to 
      mplsVpnVrfRouteTargetExport.";
  }

  revision 2001-06-19 {
    description
     "Fixed several compile errors.";
  }

  revision 2001-05-30 {
    description
     "Updated most of document and MIB to reflect comments from WG.";
  }

  revision 2000-09-30 {
    description
     "Initial draft version.";
  }

  typedef MplsVpnId {
    type binary {
      length "0..31";
    }
    description
     "An identifier that is assigned to each MPLS/BGP VPN and
      is used to uniquely identify it. This is assigned by the
      system operator or NMS and SHOULD be unique throughout
      
      
      the MPLS domain. If this is the case, then this identifier
      can then be used at any LSR within a specific MPLS domain
      to identify this MPLS/BGP VPN. It may also be possible to
      preserve the uniqueness of this identifier across MPLS
      domain boundaries, in which case this identifier can then
      be used to uniquely identify MPLS/BGP VPNs on a more global
      basis.";
    reference
     "RFC 2685 [VPN-RFC2685] Fox B., et al, 'Virtual Private
      Networks Identifier', September 1999.";
  }

  typedef MplsVpnRouteDistinguisher {
    type binary {
      length "0..256";
    }
    description
     "Syntax for a route distinguisher and route target.";
  }


  container MPLS-VPN-MIB {
    config false;

    container mplsVpnScalars {
      smiv2:oid "1.3.6.1.3.118.1.1";

      leaf mplsVpnConfiguredVrfs {
        type uint32;
        description
         "The number of VRFs which are configured on this node.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.3.118.1.1.1";
      }

      leaf mplsVpnActiveVrfs {
        type uint32;
        description
         "The number of VRFs which are active on this node.
          That is, those VRFs whose corresponding mplsVpnVrfOperStatus 
          object value is equal to operational (1).";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.3.118.1.1.2";
      }

      leaf mplsVpnConnectedInterfaces {
        type uint32;
        description
         "Total number of interfaces connected to a VRF.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.3.118.1.1.3";
      }

      leaf mplsVpnNotificationEnable {
        type boolean;
        description
         "If this object is true, then it enables the
          generation of all notifications defined in 
          this MIB.";
        smiv2:defval "false";
        smiv2:max-access "read-write";
        smiv2:oid "1.3.6.1.3.118.1.1.4";
      }

      leaf mplsVpnVrfConfMaxPossibleRoutes {
        type uint32;
        description
         "Denotes maximum number of routes which the device
          will allow all VRFs jointly to hold. If this value is
          set to 0, this indicates that the device is 
          unable to determine the absolute maximum. In this
          case, the configured maximum MAY not actually
          be allowed by the device.";
        smiv2:max-access "read-only";
        smiv2:oid "1.3.6.1.3.118.1.1.5";
      }
    }

    container mplsVpnInterfaceConfTable {
      description
       "This table specifies per-interface MPLS capability
        and associated information.";
      smiv2:oid "1.3.6.1.3.118.1.2.1";

      list mplsVpnInterfaceConfEntry {
        key "mplsVpnVrfName mplsVpnInterfaceConfIndex";
        description
         "An entry in this table is created by an LSR for
          every interface capable of supporting MPLS/BGP VPN.
          
          
          Each entry in this table is meant to correspond to
          an entry in the Interfaces Table.";
        smiv2:oid "1.3.6.1.3.118.1.2.1.1";

        leaf mplsVpnVrfName {
          type leafref {
            path "/MPLS-VPN-MIB:MPLS-VPN-MIB/MPLS-VPN-MIB:mplsVpnVrfTable/MPLS-VPN-MIB:mplsVpnVrfEntry/MPLS-VPN-MIB:mplsVpnVrfName";
          }
        }

        leaf mplsVpnInterfaceConfIndex {
          type if-mib:InterfaceIndex;
          description
           "This is a unique index for an entry in the
            MplsVPNInterfaceConfTable. A non-zero index for an
            entry indicates the ifIndex for the corresponding
            interface entry in the MPLS-VPN-layer in the ifTable.
            Note that this table does not necessarily correspond
            one-to-one with all entries in the Interface MIB
            having an ifType of MPLS-layer; rather, only those
            which are enabled for MPLS/BGP VPN functionality.";
          reference
           "RFC 2233 - The Interfaces Group MIB using SMIv2,
            McCloghrie, K., and F. Kastenholtz, Nov. 1997";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.2.1.1.1";
        }

        leaf mplsVpnInterfaceLabelEdgeType {
          type enumeration {
            enum "providerEdge" {
              value "1";
            }
            enum "customerEdge" {
              value "2";
            }
          }
          description
           "Either the providerEdge(0) (PE) or customerEdge(1)
            (CE) bit MUST be set.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.1.1.2";
        }

        leaf mplsVpnInterfaceVpnClassification {
          type enumeration {
            enum "carrierOfCarrier" {
              value "1";
            }
            enum "enterprise" {
              value "2";
            }
            enum "interProvider" {
              value "3";
            }
          }
          description
           "Denotes whether this link participates in a
            carrier-of-carrier's, enterprise, or inter-provider
            scenario.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.1.1.3";
        }

        leaf mplsVpnInterfaceVpnRouteDistProtocol {
          type bits {
            bit dummy {
              position "0";
            }
            bit none {
              position "1";
            }
            bit bgp {
              position "2";
            }
            bit ospf {
              position "3";
            }
            bit rip {
              position "4";
            }
            bit isis {
              position "5";
            }
            bit other {
              position "6";
            }
          }
          description
           "Denotes the route distribution protocol across the
            PE-CE link. Note that more than one routing protocol
            may be enabled at the same time.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.1.1.4";
        }

        leaf mplsVpnInterfaceConfStorageType {
          type snmpv2-tc:StorageType;
          description
           "The storage type for this entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.1.1.5";
        }

        leaf mplsVpnInterfaceConfRowStatus {
          type snmpv2-tc:RowStatus;
          description
           "The row status for this entry. This value is
            used to create a row in this table, signifying
            that the specified interface is to be associated
            with the specified interface. If this operation
            succeeds, the interface will have been associated,
            otherwise the agent would not allow the association. 
            If the agent only allows read-only operations on
            this table, it will create entries in this table
            as they are created.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.1.1.6";
        }
      }
    }

    container mplsVpnVrfTable {
      description
       "This table specifies per-interface MPLS/BGP VPN
        VRF Table capability and associated information.
        Entries in this table define VRF routing instances
        associated with MPLS/VPN interfaces. Note that
        multiple interfaces can belong to the same VRF
        instance. The collection of all VRF instances
        comprises an actual VPN.";
      smiv2:oid "1.3.6.1.3.118.1.2.2";

      list mplsVpnVrfEntry {
        key "mplsVpnVrfName";
        description
         "An entry in this table is created by an LSR for
          every VRF capable of supporting MPLS/BGP VPN. The
          indexing provides an ordering of VRFs per-VPN
          interface.";
        smiv2:oid "1.3.6.1.3.118.1.2.2.1";

        leaf mplsVpnVrfName {
          type MPLS-VPN-MIB:MplsVpnId;
          description
           "The human-readable name of this VPN. This MAY
            be equivalent to the RFC2685 VPN-ID.";
          reference
           "RFC 2685 [VPN-RFC2685] Fox B., et al, `Virtual
            
            
            Private Networks Identifier`, September 1999.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.1";
        }

        leaf mplsVpnVrfDescription {
          type snmp-framework:SnmpAdminString;
          description
           "The human-readable description of this VRF.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.2";
        }

        leaf mplsVpnVrfRouteDistinguisher {
          type MPLS-VPN-MIB:MplsVpnRouteDistinguisher;
          description
           "The route distinguisher for this VRF.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.3";
        }

        leaf mplsVpnVrfCreationTime {
          type yang:timestamp;
          description
           "The time at which this VRF entry was created.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.4";
        }

        leaf mplsVpnVrfOperStatus {
          type enumeration {
            enum "up" {
              value "1";
            }
            enum "down" {
              value "2";
            }
          }
          description
           "Denotes whether a VRF is operational or not. A VRF is 
            up(1) when at least one interface associated with the
            VRF, which ifOperStatus is up(1). A VRF is down(2) when:
            
            a. There does not exist at least one interface whose
               ifOperStatus is up(1).
            
            b. There are no interfaces associated with the VRF.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.5";
        }

        leaf mplsVpnVrfActiveInterfaces {
          type uint32;
          description
           "Total number of interfaces connected to this VRF with 
            
            
            ifOperStatus = up(1). 
            
            This counter should be incremented when:
            
            a. When the ifOperStatus of one of the connected interfaces 
               changes from down(2) to up(1).
            
            b. When an interface with ifOperStatus = up(1) is connected
               to this VRF.
            
            This counter should be decremented when:
            
            a. When the ifOperStatus of one of the connected interfaces 
               changes from up(1) to down(2).
            
            b. When one of the connected interfaces with 
               ifOperStatus = up(1) gets disconnected from this VRF.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.6";
        }

        leaf mplsVpnVrfAssociatedInterfaces {
          type uint32;
          description
           "Total number of interfaces connected to this VRF 
            (independent of ifOperStatus type).";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.7";
        }

        leaf mplsVpnVrfConfMidRouteThreshold {
          type uint32;
          description
           "Denotes mid-level water marker for the number
            of routes which  this VRF may hold.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.8";
        }

        leaf mplsVpnVrfConfHighRouteThreshold {
          type uint32;
          description
           "Denotes high-level water marker for the number of
            routes which  this VRF may hold.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.9";
        }

        leaf mplsVpnVrfConfMaxRoutes {
          type uint32;
          description
           "Denotes maximum number of routes which this VRF is
            configured to hold. This value MUST be less than or
            equal to mplsVrfMaxPossibleRoutes unless it is set
            to 0.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.10";
        }

        leaf mplsVpnVrfConfLastChanged {
          type yang:timestamp;
          description
           "The value of sysUpTime at the time of the last
            change of this table entry, which includes changes of
            VRF parameters defined in this table or addition or
            deletion of interfaces associated with this VRF.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.11";
        }

        leaf mplsVpnVrfConfRowStatus {
          type snmpv2-tc:RowStatus;
          description
           "This variable is used to create, modify, and/or
            delete a row in this table.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.12";
        }

        leaf mplsVpnVrfConfStorageType {
          type snmpv2-tc:StorageType;
          description
           "The storage type for this entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.2.1.13";
        }
      }
    }

    container mplsVpnVrfRouteTargetTable {
      description
       "This table specifies per-VRF route target association.
        Each entry identifies a connectivity policy supported
        as part of a VPN.";
      smiv2:oid "1.3.6.1.3.118.1.2.3";

      list mplsVpnVrfRouteTargetEntry {
        key "mplsVpnVrfName mplsVpnVrfRouteTargetIndex mplsVpnVrfRouteTargetType";
        description
         " An entry in this table is created by an LSR for
          each route target configured for a VRF supporting
          a MPLS/BGP VPN instance. The indexing provides an
          ordering per-VRF instance.";
        smiv2:oid "1.3.6.1.3.118.1.2.3.1";

        leaf mplsVpnVrfName {
          type leafref {
            path "/MPLS-VPN-MIB:MPLS-VPN-MIB/MPLS-VPN-MIB:mplsVpnVrfTable/MPLS-VPN-MIB:mplsVpnVrfEntry/MPLS-VPN-MIB:mplsVpnVrfName";
          }
        }

        leaf mplsVpnVrfRouteTargetIndex {
          type uint32;
          description
           "Auxiliary index for route-targets configured for a 
            particular VRF.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.2.3.1.2";
        }

        leaf mplsVpnVrfRouteTargetType {
          type enumeration {
            enum "import" {
              value "1";
            }
            enum "export" {
              value "2";
            }
            enum "both" {
              value "3";
            }
          }
          description
           "The route target export distribution type.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.2.3.1.3";
        }

        leaf mplsVpnVrfRouteTarget {
          type MPLS-VPN-MIB:MplsVpnRouteDistinguisher;
          description
           "The route target distribution policy.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.3.1.4";
        }

        leaf mplsVpnVrfRouteTargetDescr {
          type snmpv2-tc:DisplayString;
          description
           "Description of the route target.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.3.1.5";
        }

        leaf mplsVpnVrfRouteTargetRowStatus {
          type snmpv2-tc:RowStatus;
          description
           "Row status for this entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.3.1.6";
        }
      }
    }

    container mplsVpnVrfBgpNbrAddrTable {
      description
       "Each entry in this table specifies a per-interface 
        MPLS/EBGP neighbor.";
      smiv2:oid "1.3.6.1.3.118.1.2.4";

      list mplsVpnVrfBgpNbrAddrEntry {
        key "mplsVpnVrfName mplsVpnInterfaceConfIndex mplsVpnVrfBgpNbrIndex";
        description
         "An entry in this table is created by an LSR for
          every VRF capable of supporting MPLS/BGP VPN. The
          indexing provides an ordering of VRFs per-VPN
          interface.";
        smiv2:oid "1.3.6.1.3.118.1.2.4.1";

        leaf mplsVpnVrfName {
          type leafref {
            path "/MPLS-VPN-MIB:MPLS-VPN-MIB/MPLS-VPN-MIB:mplsVpnVrfTable/MPLS-VPN-MIB:mplsVpnVrfEntry/MPLS-VPN-MIB:mplsVpnVrfName";
          }
        }

        leaf mplsVpnInterfaceConfIndex {
          type leafref {
            path "/MPLS-VPN-MIB:MPLS-VPN-MIB/MPLS-VPN-MIB:mplsVpnInterfaceConfTable/MPLS-VPN-MIB:mplsVpnInterfaceConfEntry/MPLS-VPN-MIB:mplsVpnInterfaceConfIndex";
          }
        }

        leaf mplsVpnVrfBgpNbrIndex {
          type uint32;
          description
           "This is a unique tertiary index for an entry in the
            MplsVpnVrfBgpNbrAddrEntry Table.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.2.4.1.1";
        }

        leaf mplsVpnVrfBgpNbrRole {
          type enumeration {
            enum "ce" {
              value "1";
            }
            enum "pe" {
              value "2";
            }
          }
          description
           "Denotes the role played by this EBGP neighbor
            with respect to this VRF.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.4.1.2";
        }

        leaf mplsVpnVrfBgpNbrType {
          type inet-address:InetAddressType;
          description
           "Denotes the address family of the PE address.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.4.1.3";
        }

        leaf mplsVpnVrfBgpNbrAddr {
          type inet-address:InetAddress;
          description
           "Denotes the EBGP neighbor address.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.4.1.4";
        }

        leaf mplsVpnVrfBgpNbrRowStatus {
          type snmpv2-tc:RowStatus;
          description
           "This variable is used to create, modify, and/or
            delete a row in this table.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.4.1.5";
        }

        leaf mplsVpnVrfBgpNbrStorageType {
          type snmpv2-tc:StorageType;
          description
           "The storage type for this entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.2.4.1.6";
        }
      }
    }

    container mplsVpnVrfBgpNbrPrefixTable {
      description
       "This table specifies per-VRF vpnv4 multi-protocol
        prefixes supported by BGP.";
      smiv2:oid "1.3.6.1.3.118.1.2.5";

      list mplsVpnVrfBgpNbrPrefixEntry {
        key "mplsVpnVrfName mplsVpnVrfBgpPathAttrIpAddrPrefix mplsVpnVrfBgpPathAttrIpAddrPrefixLen mplsVpnVrfBgpPathAttrPeer";
        description
         "An entry in this table is created by an LSR for
          every BGP prefix associated with a VRF supporting a 
          MPLS/BGP VPN. The indexing provides an ordering of 
          BGP prefixes per VRF.";
        smiv2:oid "1.3.6.1.3.118.1.2.5.1";

        leaf mplsVpnVrfName {
          type leafref {
            path "/MPLS-VPN-MIB:MPLS-VPN-MIB/MPLS-VPN-MIB:mplsVpnVrfTable/MPLS-VPN-MIB:mplsVpnVrfEntry/MPLS-VPN-MIB:mplsVpnVrfName";
          }
        }

        leaf mplsVpnVrfBgpPathAttrPeer {
          type inet-address:InetAddress;
          description
           "The IP address of the peer where the path
            information was learned.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.1";
        }

        leaf mplsVpnVrfBgpPathAttrIpAddrPrefixLen {
          type int32 {
            range "0..32";
          }
          description
           "Length in bits of the IP address prefix
            in the Network Layer Reachability
            Information field.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.2";
        }

        leaf mplsVpnVrfBgpPathAttrIpAddrPrefix {
          type inet-address:InetAddress;
          description
           "An IP address prefix in the Network Layer
            Reachability Information field.  This object
            is an IP address containing the prefix with
            length specified by mplsVpnVrfBgpPathAttrIpAddrPrefixLen.
            Any bits beyond the length specified by
            mplsVpnVrfBgpPathAttrIpAddrPrefixLen are zeroed.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.3";
        }

        leaf mplsVpnVrfBgpPathAttrOrigin {
          type enumeration {
            enum "igp" {
              value "1";
            }
            enum "egp" {
              value "2";
            }
            enum "incomplete" {
              value "3";
            }
          }
          description
           "The ultimate origin of the path
            information.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.4";
        }

        leaf mplsVpnVrfBgpPathAttrASPathSegment {
          type binary {
            length "2..255";
          }
          description
           "The sequence of AS path segments.  Each AS
            path segment is represented by a triple
            <type, length, value>.
            
             The type is a 1-octet field which has two
             possible values:
                 1      AS_SET: unordered set of ASs a
                        route in the UPDATE
                        message has traversed
                 2      AS_SEQUENCE: ordered set of ASs
                        a route in the UPDATE
                        message has traversed.
                        The length is a 1-octet field containing the
            
            
                        number of ASs in the value field.
            
                        The value field contains one or more AS
                        numbers, each AS is represented in the octet
                        string as a pair of octets according to the
                        following algorithm:
            
                        first-byte-of-pair = ASNumber / 256;
                        second-byte-of-pair = ASNumber & 255;";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.5";
        }

        leaf mplsVpnVrfBgpPathAttrNextHop {
          type inet-address:InetAddress;
          description
           "The address of the border router that
            should be used for the destination
            network.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.6";
        }

        leaf mplsVpnVrfBgpPathAttrMultiExitDisc {
          type int32 {
            range "-1..2147483647";
          }
          description
           "This metric is used to discriminate
            between multiple exit points to an
            adjacent autonomous system.  A value of -1
            indicates the absence of this attribute.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.7";
        }

        leaf mplsVpnVrfBgpPathAttrLocalPref {
          type int32 {
            range "-1..2147483647";
          }
          description
           "The originating BGP4 speaker's degree of
            preference for an advertised route.  A
            value of -1 indicates the absence of this
            attribute.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.8";
        }

        leaf mplsVpnVrfBgpPathAttrAtomicAggregate {
          type enumeration {
            enum "lessSpecificRrouteNotSelected" {
              value "1";
            }
            enum "lessSpecificRouteSelected" {
              value "2";
            }
          }
          description
           "Whether or not the local system has
            selected a less specific route without
            selecting a more specific route.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.9";
        }

        leaf mplsVpnVrfBgpPathAttrAggregatorAS {
          type int32 {
            range "0..65535";
          }
          description
           "The AS number of the last BGP4 speaker that
            performed route aggregation.  A value of
            zero (0) indicates the absence of this
            attribute.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.10";
        }

        leaf mplsVpnVrfBgpPathAttrAggregatorAddr {
          type inet-address:InetAddress;
          description
           "The IP address of the last BGP4 speaker
            that performed route aggregation.  A value
            of 0.0.0.0 indicates the absence of this
            attribute.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.11";
        }

        leaf mplsVpnVrfBgpPathAttrCalcLocalPref {
          type int32 {
            range "-1..2147483647";
          }
          description
           "The degree of preference calculated by the
            receiving BGP4 speaker for an advertised
            route.  A value of -1 indicates the
            absence of this attribute.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.12";
        }

        leaf mplsVpnVrfBgpPathAttrBest {
          type enumeration {
            enum "false" {
              value "1";
            }
            enum "true" {
              value "2";
            }
          }
          description
           "An indication of whether or not this route
            was chosen as the best BGP4 route.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.13";
        }

        leaf mplsVpnVrfBgpPathAttrUnknown {
          type binary {
            length "0..255";
          }
          description
           "One or more path attributes not understood
            by this BGP4 speaker.  Size zero (0)
            indicates the absence of such
            attribute(s).  Octets beyond the maximum
            size, if any, are not recorded by this
            object.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.2.5.1.14";
        }
      }
    }

    container mplsVpnVrfRouteTable {
      description
       "This table specifies per-interface MPLS/BGP VPN VRF Table
        routing information. Entries in this table define VRF routing
        entries associated with the specified MPLS/VPN interfaces. Note
        that this table contains both BGP and IGP routes, as both may
        appear in the same VRF.";
      reference
       "1.  RFC 1213 Section 6.6, The IP Group.
        2.  RFC 2096 ";
      smiv2:oid "1.3.6.1.3.118.1.4.1";

      list mplsVpnVrfRouteEntry {
        key "mplsVpnVrfName mplsVpnVrfRouteDest mplsVpnVrfRouteMask mplsVpnVrfRouteTos mplsVpnVrfRouteNextHop";
        description
         "An entry in this table is created by an LSR for every route
          present configured (either dynamically or statically) within
          the context of a specific VRF capable of supporting MPLS/BGP
          VPN. The indexing provides an ordering of VRFs per-VPN
          interface.";
        smiv2:oid "1.3.6.1.3.118.1.4.1.1";

        leaf mplsVpnVrfName {
          type leafref {
            path "/MPLS-VPN-MIB:MPLS-VPN-MIB/MPLS-VPN-MIB:mplsVpnVrfTable/MPLS-VPN-MIB:mplsVpnVrfEntry/MPLS-VPN-MIB:mplsVpnVrfName";
          }
        }

        leaf mplsVpnVrfRouteDest {
          type inet-address:InetAddress;
          description
           "The destination IP address of this route.
            This object may not take a Multicast (Class D)
            address value.
            
            Any assignment (implicit or otherwise) of an
            instance of this object to a value x must be
            rejected if the bit-wise logical-AND of x with
            the value of the corresponding instance of the
            mplsVpnVrfRouteMask object is not equal to x.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.1";
        }

        leaf mplsVpnVrfRouteDestAddrType {
          type inet-address:InetAddressType;
          description
           "The address type of the mplsVpnVrfRouteDest
            entry.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.2";
        }

        leaf mplsVpnVrfRouteMask {
          type inet-address:InetAddress;
          description
           "Indicate the mask to be logical-ANDed with the
            destination  address  before  being compared to
            the value  in  the  mplsVpnVrfRouteDest field.
            For those  systems  that  do  not support
            arbitrary subnet masks, an agent constructs the
            value of the mplsVpnVrfRouteMask by reference
            
            
            to the IP Address Class.
            
            Any assignment (implicit or otherwise) of an
            instance of this object to a value x must be
            rejected if the bit-wise logical-AND of x with
            the value of the corresponding instance of the
            mplsVpnVrfRouteDest object is not equal to
            mplsVpnVrfRouteDest.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.3";
        }

        leaf mplsVpnVrfRouteMaskAddrType {
          type inet-address:InetAddressType;
          description
           "The address type of mplsVpnVrfRouteMask.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.4";
        }

        leaf mplsVpnVrfRouteTos {
          type uint32;
          description
           "The IP TOS Field is used to specify the policy to
            be applied to this route.  The encoding of IP TOS
            is as specified  by  the  following convention.
            Zero indicates the default path if no more
            specific policy applies.
            
            +-----+-----+-----+-----+-----+-----+-----+-----+
            |                 |                       |     |
            |   PRECEDENCE    |    TYPE OF SERVICE    |  0  |
            |                 |                       |     |
            +-----+-----+-----+-----+-----+-----+-----+-----+
            
                       IP TOS                IP TOS
                  Field     Policy      Field     Policy
                  Contents    Code      Contents    Code
                  0 0 0 0  ==>   0      0 0 0 1  ==>   2
                  0 0 1 0  ==>   4      0 0 1 1  ==>   6
                  0 1 0 0  ==>   8      0 1 0 1  ==>  10
                  0 1 1 0  ==>  12      0 1 1 1  ==>  14
                  1 0 0 0  ==>  16      1 0 0 1  ==>  18
                  1 0 1 0  ==>  20      1 0 1 1  ==>  22
                  1 1 0 0  ==>  24      1 1 0 1  ==>  26
                  1 1 1 0  ==>  28      1 1 1 1  ==>  30.";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.5";
        }

        leaf mplsVpnVrfRouteNextHop {
          type inet-address:InetAddress;
          description
           "On remote routes, the address of the next
            system en route; Otherwise, 0.0.0.0. .";
          smiv2:max-access "not-accessible";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.6";
        }

        leaf mplsVpnVrfRouteNextHopAddrType {
          type inet-address:InetAddressType;
          description
           "The address type of the mplsVpnVrfRouteNextHopAddrType
            object.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.7";
        }

        leaf mplsVpnVrfRouteIfIndex {
          type if-mib:InterfaceIndexOrZero;
          description
           "The ifIndex value that identifies the local
            interface  through  which  the next hop of this
            route should be reached.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.8";
        }

        leaf mplsVpnVrfRouteType {
          type enumeration {
            enum "other" {
              value "1";
            }
            enum "reject" {
              value "2";
            }
            enum "local" {
              value "3";
            }
            enum "remote" {
              value "4";
            }
          }
          description
           "The type of route.  Note that local(3)  refers
            to a route for which the next hop is the final
            destination; remote(4) refers to a route for
            that the next  hop is not the final destination.
            Routes which do not result in traffic forwarding or
            rejection should not be displayed even if the
            implementation keeps them stored internally.
            
            reject (2) refers to a route which, if matched,
            discards the message as unreachable. This is used
            in some protocols as a means of correctly aggregating
            routes.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.9";
        }

        leaf mplsVpnVrfRouteProto {
          type enumeration {
            enum "other" {
              value "1";
            }
            enum "local" {
              value "2";
            }
            enum "netmgmt" {
              value "3";
            }
            enum "icmp" {
              value "4";
            }
            enum "egp" {
              value "5";
            }
            enum "ggp" {
              value "6";
            }
            enum "hello" {
              value "7";
            }
            enum "rip" {
              value "8";
            }
            enum "isIs" {
              value "9";
            }
            enum "esIs" {
              value "10";
            }
            enum "ciscoIgrp" {
              value "11";
            }
            enum "bbnSpfIgp" {
              value "12";
            }
            enum "ospf" {
              value "13";
            }
            enum "bgp" {
              value "14";
            }
            enum "idpr" {
              value "15";
            }
            enum "ciscoEigrp" {
              value "16";
            }
          }
          description
           "The routing mechanism via which this route was
            learned.  Inclusion of values for gateway rout-
            ing protocols is not  intended  to  imply  that
            hosts should support those protocols.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.10";
        }

        leaf mplsVpnVrfRouteAge {
          type uint32;
          description
           "The number of seconds since this route was
            last updated or otherwise determined to be
            correct. Note that no semantics of `too old'
            can be implied except through knowledge of the
            routing protocol by which the route was
            learned.";
          smiv2:max-access "read-only";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.11";
        }

        leaf mplsVpnVrfRouteInfo {
          type yang:object-identifier-128;
          description
           "A reference to MIB definitions specific to the
            particular routing protocol which is responsi-
            
            
            ble for this route, as determined by the  value
            specified  in the route's mplsVpnVrfRouteProto
            value. If this information is not present, its
            value SHOULD be set to the OBJECT IDENTIFIER
            { 0 0 }, which is a syntactically valid object
            identif-ier, and any implementation conforming
            to ASN.1 and the Basic Encoding Rules must be
            able to generate and recognize this value.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.12";
        }

        leaf mplsVpnVrfRouteNextHopAS {
          type uint32;
          description
           "The Autonomous System Number of the Next Hop.
            The semantics of this object are determined by
            the routing-protocol specified in the route's
            mplsVpnVrfRouteProto value. When this object is
            unknown or not relevant its value should be set
            to zero.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.13";
        }

        leaf mplsVpnVrfRouteMetric1 {
          type int32;
          description
           "The primary routing metric for this route.
            The semantics of this metric are determined by
            the routing-protocol specified in  the  route's
            mplsVpnVrfRouteProto value. If this metric is not
            used, its value should be set to -1.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.14";
        }

        leaf mplsVpnVrfRouteMetric2 {
          type int32;
          description
           "An alternate routing metric for this route.
            The semantics of this metric are determined by
            the routing-protocol specified in  the  route's
            mplsVpnVrfRouteProto value. If this metric is not
            used, its value should be set to -1.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.15";
        }

        leaf mplsVpnVrfRouteMetric3 {
          type int32;
          description
           "An alternate routing metric for this route.
            The semantics of this metric are determined by
            the routing-protocol specified in  the  route's
            mplsVpnVrfRouteProto value. If this metric is not
            used, its value should be set to -1.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.16";
        }

        leaf mplsVpnVrfRouteMetric4 {
          type int32;
          description
           "An alternate routing metric for this route.
            The semantics of this metric are determined by
            the routing-protocol specified in  the  route's
            mplsVpnVrfRouteProto value. If this metric is not
            used, its value should be set to -1.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.17";
        }

        leaf mplsVpnVrfRouteMetric5 {
          type int32;
          description
           "An alternate routing metric for this route.
            The semantics of this metric are determined by
            the routing-protocol specified in  the  route's
            mplsVpnVrfRouteProto value. If this metric is not
            used, its value should be set to -1.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.18";
        }

        leaf mplsVpnVrfRouteRowStatus {
          type snmpv2-tc:RowStatus;
          description
           "Row status for this table. It is used according
            to row installation and removal conventions.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.19";
        }

        leaf mplsVpnVrfRouteStorageType {
          type snmpv2-tc:StorageType;
          description
           "Storage type value.";
          smiv2:max-access "read-write";
          smiv2:oid "1.3.6.1.3.118.1.4.1.1.20";
        }
      }
    }
  }

  smiv2:alias "mplsVpnVrfSecTable" {
    description
     "This table specifies per MPLS/BGP VPN VRF Table security
      features.";
    smiv2:oid "1.3.6.1.3.118.1.2.6";
  }

  smiv2:alias "mplsVpnVrfSecEntry" {
    description
     "An entry in this table is created by an LSR for
      every VRF capable of supporting MPLS/BGP VPN. Each
      entry in this table is used to indicate security-related
      information for each VRF entry.";
    smiv2:oid "1.3.6.1.3.118.1.2.6.1";
  }

  augment "/MPLS-VPN-MIB:MPLS-VPN-MIB/MPLS-VPN-MIB:mplsVpnVrfTable/MPLS-VPN-MIB:mplsVpnVrfEntry" {
    description
     "An entry in this table is created by an LSR for
      every VRF capable of supporting MPLS/BGP VPN. Each
      entry in this table is used to indicate security-related
      information for each VRF entry.";
    smiv2:oid "1.3.6.1.3.118.1.2.6.1";

    leaf mplsVpnVrfSecIllegalLabelViolations {
      type yang:counter32;
      description
       "Indicates the number of illegally received labels on this VPN/VRF.";
      smiv2:max-access "read-only";
      smiv2:oid "1.3.6.1.3.118.1.2.6.1.1";
    }

    leaf mplsVpnVrfSecIllegalLabelRcvThresh {
      type uint32;
      description
       "The number of illegally received labels above which this 
        notification is issued.";
      smiv2:max-access "read-write";
      smiv2:oid "1.3.6.1.3.118.1.2.6.1.2";
    }
  }

  smiv2:alias "mplsVpnVrfPerfTable" {
    description
     "This table specifies per MPLS/BGP VPN VRF Table performance
      information.";
    smiv2:oid "1.3.6.1.3.118.1.3.1";
  }

  smiv2:alias "mplsVpnVrfPerfEntry" {
    description
     "An entry in this table is created by an LSR for
      every VRF capable of supporting MPLS/BGP VPN.";
    smiv2:oid "1.3.6.1.3.118.1.3.1.1";
  }

  augment "/MPLS-VPN-MIB:MPLS-VPN-MIB/MPLS-VPN-MIB:mplsVpnVrfTable/MPLS-VPN-MIB:mplsVpnVrfEntry" {
    description
     "An entry in this table is created by an LSR for
      every VRF capable of supporting MPLS/BGP VPN.";
    smiv2:oid "1.3.6.1.3.118.1.3.1.1";

    leaf mplsVpnVrfPerfRoutesAdded {
      type yang:counter32;
      description
       "Indicates the number of routes added to this VPN/VRF over the
        coarse of its lifetime.";
      smiv2:max-access "read-only";
      smiv2:oid "1.3.6.1.3.118.1.3.1.1.1";
    }

    leaf mplsVpnVrfPerfRoutesDeleted {
      type yang:counter32;
      description
       "Indicates the number of routes removed from this VPN/VRF.";
      smiv2:max-access "read-only";
      smiv2:oid "1.3.6.1.3.118.1.3.1.1.2";
    }

    leaf mplsVpnVrfPerfCurrNumRoutes {
      type uint32;
      description
       "Indicates the number of routes currently used by this VRF.";
      smiv2:max-access "read-only";
      smiv2:oid "1.3.6.1.3.118.1.3.1.1.3";
    }
  }

  notification mplsVrfIfUp {
    description
     "This notification is generated when:
      a. The ifOperStatus of an interface associated with a VRF 
         changes to the up(1) state.
      b. When an interface with ifOperStatus = up(1) is 
         associated with a VRF.";
    smiv2:oid "1.3.6.1.3.118.0.1";
  }

  notification mplsVrfIfDown {
    description
     "This notification is generated when:
      a. The ifOperStatus of an interface associated with a VRF 
         changes to the down(1) state.
      b. When an interface with ifOperStatus = up(1) state is 
         disassociated with a VRF.";
    smiv2:oid "1.3.6.1.3.118.0.2";
  }

  notification mplsNumVrfRouteMidThreshExceeded {
    description
     "This notification is generated when the number of routes
      contained by the specified VRF exceeds the value indicated by
      mplsVrfMidRouteThreshold.";
    smiv2:oid "1.3.6.1.3.118.0.3";
  }

  notification mplsNumVrfRouteMaxThreshExceeded {
    description
     "This notification is generated when the number of routes
      contained by the specified VRF reaches or attempts to exceed
      the maximum allowed value as indicated by
      mplsVrfMaxRouteThreshold.";
    smiv2:oid "1.3.6.1.3.118.0.4";
  }

  notification mplsNumVrfSecIllegalLabelThreshExceeded {
    description
     "This notification is generated when the number of illegal
      label violations on a VRF as indicated by 
      mplsVpnVrfSecIllegalLabelViolations has exceeded 
      mplsVpnVrfSecIllegalLabelRcvThresh. The threshold is not 
      included in the varbind here because the value of 
      mplsVpnVrfSecIllegalLabelViolations should be one greater than 
      the threshold at the time this notification is issued.";
    smiv2:oid "1.3.6.1.3.118.0.5";
  }

  smiv2:alias "mplsVpnMIB" {
    smiv2:oid "1.3.6.1.3.118";
  }

  smiv2:alias "mplsVpnNotifications" {
    smiv2:oid "1.3.6.1.3.118.0";
  }

  smiv2:alias "mplsVpnObjects" {
    smiv2:oid "1.3.6.1.3.118.1";
  }

  smiv2:alias "mplsVpnScalars" {
    smiv2:oid "1.3.6.1.3.118.1.1";
  }

  smiv2:alias "mplsVpnConf" {
    smiv2:oid "1.3.6.1.3.118.1.2";
  }

  smiv2:alias "mplsVpnPerf" {
    smiv2:oid "1.3.6.1.3.118.1.3";
  }

  smiv2:alias "mplsVpnRoute" {
    smiv2:oid "1.3.6.1.3.118.1.4";
  }

  smiv2:alias "mplsVpnConformance" {
    smiv2:oid "1.3.6.1.3.118.3";
  }

  smiv2:alias "mplsVpnGroups" {
    smiv2:oid "1.3.6.1.3.118.3.1";
  }

  smiv2:alias "mplsVpnCompliances" {
    smiv2:oid "1.3.6.1.3.118.3.2";
  }

}
