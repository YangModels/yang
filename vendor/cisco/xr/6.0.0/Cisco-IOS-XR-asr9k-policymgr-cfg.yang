module Cisco-IOS-XR-asr9k-policymgr-cfg {

  namespace 
    "http://cisco.com/ns/yang/Cisco-IOS-XR-asr9k-policymgr-cfg";
  
  prefix "asr9k-policymgr-cfg";
    
  import ietf-inet-types { 
    prefix inet;
  }
    
  import ietf-yang-types { 
    prefix yang;
  }
    
  organization "Cisco Systems, Inc.";

  contact
    "Cisco Systems, Inc.
     Customer Service

     Postal: 170 West Tasman Drive
     San Jose, CA 95134

     Tel: +1 800 553-NETS

     E-mail: cs-yang@cisco.com";

  description 
    "This module contains a collection of YANG definitions
     for Cisco IOS-XR ASR9k policy manager configuration.

     Copyright (c) 2013, 2015 by Cisco Systems, Inc.
     All rights reserved.";

  revision "2015-05-18" {
    description
      "IOS XR 5.3.2 revision.";
  }

  revision "2013-07-22" {
    description
      "Initial revision.";
  }

  typedef Class-map-type {
    type enumeration {
      enum qos {
        value 1;
        description "QoS Classmap.";
      }
      enum traffic {
        value 3;
        description "TRAFFIC Classmap.";
      }
      enum control {
        value 4;
        description "Control Subscriber Classmap.";
      }
    }
    description "Policy manager class-map type.";
  }

  typedef Alarm-severity {
    type string {
      pattern "(informational)|(notification)|(warning)|(error)|"+
              "(critical)|(alert)|(emergency)";
    }
    description "Alaram severity types.";
  }

  typedef Policy-map-type {
    type enumeration {
      enum qos {
        value 1;
        description "QoS Policymap";
      }
      enum pbr {
        value 2;
        description "PBR Policymap";
      }
      enum traffic {
        value 3;
        description "TRAFFIC Policymap";
      }
      enum subscriber-control {
        value 4;
        description "SUBSCRIBER-CONTROL Policymap";
      }
      enum redirect {
        value 6;
        description "REDIRECT Policy map";
      }
      enum flow-monitor {
        value 7;
        description "FLOWMONITOR Policy map";
      }
    }
    description "Policy manager policy-map type.";
  }

  typedef Service-policy-type {
    type string {
      pattern "(PBR)|(QOS)|(REDIRECT)|(TRAFFIC)
               |(pbr)|(qos)|(redirect)|(traffic)";
    }
    description "Policy manager service-policy type.";
  }

  typedef Pmap-class-map-type {
    type enumeration {
      enum qos {
        value 1;
        description "QoS Classmap.";
      }
      enum traffic {
        value 2;
        description "TRAFFIC Classmap.";
      }
      enum subscriber-control {
        value 3;
        description "Subscriber Control Classmap.";
      }
    }
    description "Policy manager class-map type.";
  }

  typedef Bandwidth-units {
    type string {
      pattern "(bps)|(kbps)|(mbps)|(gbps)|(percent)|(per-million)|"+
              "(per-thousand)";
    }
    description "Supported units for bandwidth.
                 bps          - units in Bits/Sec
                 kbps         - units in KiloBits/Sec
                 mbps         - units in MegaBits/Sec
                 gbps         - units in GigaBits/Sec
                 percent      - units in Percentage
                 per-million  - parts per-million bandwidth value
                 per-thousand - Parts per-thousand bandwidth value";
  }

  typedef Rate-units {
    type string {
      pattern "(bps)|(kbps)|(mbps)|(gbps)|(pps)|(percent)";
    }
    description "Supported units for police rate or peak-rate.
                 bps     - units in Bits/Sec
                 kbps    - units in KiloBits/Sec
                 mbps    - units in MegaBits/Sec
                 gbps    - units in GigaBits/Sec
                 pps     - units in Packets/Sec
                 percent - units in Percentage";
  }

  typedef Cac-rate-units {
    type string {
      pattern "(bps)|(kbps)|(mbps)|(gbps)|(cellsps)";
    }
    description "Supported units for CAC rate or flow-rate.
                 bps     - units in Bits/Sec
                 kbps    - units in KiloBits/Sec
                 mbps    - units in MegaBits/Sec
                 gbps    - units in GigaBits/Sec
                 cellsps - units in Cells/Sec";
  }

  typedef Queue-units {
    type string {
      pattern "(bytes)|(kbytes)|(mbytes)|(gbytes)|(us)|(ms)|"+
              "(packets)|(cells)";
    }
    description "Supported units for queue.
                 bytes   - units in Bytes
                 kbytes  - units in KiloBytes
                 mbytes  - units in MegaBytes
                 gbytes  - units in Gigabytes
                 us      - units in Microseconds
                 ms      - units in Milliseconds
                 packets - units in Packets
                 cells   - units in Cells";
  }
  
  typedef Threshold-units {
    type string {
      pattern "(bytes)|(kbytes)|(mbytes)|(gbytes)|(us)|(ms)|"+
              "(packets)|(cells)";
    }
    description "Supported units for RED threshold.
                 bytes   - units in Bytes
                 kbytes  - units in KiloBytes
                 mbytes  - units in MegaBytes
                 gbytes  - units in GigaBytes
                 us      - units in Microseconds
                 ms      - units in Milliseconds
                 packets - units in Packets
                 cells   - units in Cells";
  }

  typedef Float-str {
    type string {
      pattern "[0-9]+(\.[0-9]+)?";
    }
    description "Floating point number string representation.";
  }
  
  typedef Dscp {
    type string {
      pattern "([0-9]|[1-5][0-9]|6[0-3])|"+
              "(af11)|(af12)|(af13)|(af21)|(af22)|(af23)|(af31)|"+
              "(af32)|(af33)|(af41)|(af42)|(af43)|(ef)|(default)|"+
              "(cs1)|(cs2)|(cs3)|(cs4)|(cs5)|(cs6)|(cs7)";
    }
    description "DSCP value string representation.
                 Should be single value 0..63 or predefined string.";
  }

  typedef Dscp-range {
    type string {
      pattern "([0-9]|[1-5][0-9]|6[0-3])|"+
              "(([0-9]|[1-5][0-9]|6[0-3])-"+
              "([0-9]|[1-5][0-9]|6[0-3]))|"+
              "(af11)|(af12)|(af13)|(af21)|(af22)|(af23)|(af31)|"+
              "(af32)|(af33)|(af41)|(af42)|(af43)|(ef)|(default)|"+
              "(cs1)|(cs2)|(cs3)|(cs4)|(cs5)|(cs6)|(cs7)";
    }
    description "DSCP value or range string representation.
                 Should be single value 0..63 or predefined string 
                 or range <min>-<max>.";
  }
  
  typedef Num-range {
    type string {
      pattern "(\d+)|(\d+\-\d+)";
    }
    description "Numeric value or range string representation.
                 Should be single value or range <min>-<max>.";
  }
  
  typedef Protocol {
    type string {
      pattern 
        "([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|"+
        "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\-"+
        "([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))|"+
        "((ahp)|(dhcpv4)|(dhcpv6)|(eigrp)|(esp)|(gre)|(icmp)|"+
        "(igmp)|(igrp)|(ipinip)|(ipv4)|(ipv6)|(ipv6icmp)|(mpls)|"+
        "(nos)|(ospf)|(pcp)|(pim)|(ppp)|(sctp)|(tcp)|(udp))";
    }
    description "Numeric value or range or string representation.
                 Should be single value or range 0..255.";
  }
  
  typedef Precedence {
    type union {
      type uint8 {
        range "0..7";
      }
      type string {
        pattern "(critical)|(flash)|(flash-override)|(immediate)|"+
                "(internet)|(network)|(priority)|(routine)";
      }
    }
    description "Precedence value.
                 critical        Critical precedence (5)
                 flash           Flash precedence (3)
                 flash-override  Flash override precedence (4)
                 immediate       Immediate precedence (2)
                 internet        Internetwork control precedence (6)
                 network         Network control precedence (7)
                 priority        Priority precedence (1)
                 routine         Routine precedence (0)";
  }
  
  typedef Cos {
    type uint8 {
      range "0..7";
    }
    description "Cos value.";
  }

  typedef Idle-timeout-number {
    type uint16 {
      range "10..2550";
    }
    units "seconds";
    description "String that idle-timeout can take.";
  }
  
  typedef Idle-timeout-string {
    type string {
      pattern "None";
    }
    description "This flow does not expire.";
  }
  
  typedef Idle-timeout {
    type union {
      type Idle-timeout-number;
      type Idle-timeout-string;
    }
    description "Idle timeout.";
  }
  
  typedef Event-type {
    type enumeration {
      enum account-logoff {
        description "Account logoff event.";
      }
      enum account-logon {
        description "Account logon event.";
      }
      enum authentication-failure {
        description "Authentication failure event.";
      }
      enum authentication-no-response {
        description "Authentication no response event.";
      }
      enum authorization-failure {
        description "Authorization failure event.";
      }
      enum authorization-no-response {
        description "Authorization no response event.";
      }
      enum credit-exhausted {
        description "Credit exhaustion event.";
      }
      enum exception {
        description "Exception event.";
      }
      enum idle-timeout {
        description "Idle timeout event.";
      }
      enum quota-depleted {
        description "Quota depletion event.";
      }
      enum service-start {
        description "Service start event.";
      }
      enum service-stop {
        description "Service stop event.";
      }
      enum session-activate {
        description "Session activate event.";
      }
      enum session-start {
        description "Session start event.";
      }
      enum session-stop {
        description "Session stop event.";
      }
      enum timer-expiry {
        description "Timer expiry event.";
      }
    }
    description "Event type.";
  }
  
  typedef Execution-strategy {
    type enumeration {
      enum do-all {
        description "Do all actions.";
      }
      enum do-until-failure {
        description "Do all actions until failure.";
      }
      enum do-until-success {
        description "Do all actions until success.";
      }
    }
    description "Executuion strategy.";
  }
  
  typedef Authorize-identifier {
    type enumeration {
      enum circuit-id {
        description "Authorize circuit ID.";
      }
      enum remote-id {
        description "Authorize remote ID.";
      }
      enum source-address-ipv4 {
        description "Authorize source IPv4 address.";
      }
      enum source-address-ipv6 {
        description "Authorize source IPv6 address.";
      }
      enum source-address-mac {
        description "Authorize source MAC address.";
      }
      enum username {
        description "Authorize username.";
      }
    }
    description "Authorize identifier.";
  }
  
  grouping MATCH {
    description "Supported 'match' or 'match-not' actions.";
    leaf-list ipv4-dscp {
      type Dscp-range;
      max-elements 8;
      description "Match IPv4 DSCP.";
    }
    leaf-list ipv6-dscp {
      type Dscp-range;
      max-elements 8;
      description "Match IPv6 DSCP.";
    }
    leaf-list dscp {
      type Dscp-range;
      max-elements 8;
      description "Match DSCP.";
    }
    leaf-list ipv4-precedence {
      type Precedence;
      max-elements 8;
      description "Match IPv4 precedence.";
    }
    leaf-list ipv6-precedence {
      type Precedence;
      max-elements 8;
      description "Match IPv6 precedence.";
    }
    leaf-list precedence {
      type Precedence;
      max-elements 8;
      description "Match precedence.";
    }
    leaf-list qos-group {
      type uint16 {
        range "0..512";
      }
      max-elements 8;
      description "Match QoS group.";
    }
    leaf-list cos {
      type Cos;
      max-elements 8;
      description "Match CoS.";
    }
    leaf-list inner-cos {
      type Cos;
      max-elements 8;
      description "Match inner CoS.";
    }
    leaf-list protocol {
      type Protocol;
      max-elements 7;
      description "Match protocol.";
    }
    leaf ipv4-acl {
      type string {
        length "1..64";
      }
      description "Match IPv4 ACL.";
    }
    leaf ipv6-acl {
      type string {
        length "1..64";
      }
      description "Match IPv6 ACL.";
    }
    leaf-list mpls-experimental-topmost {
      type Cos;
      max-elements 8;
      description "Match MPLS experimental topmost label.";
    }
    leaf-list mpls-experimental-imposition {
      type Cos;
      max-elements 8;
      description "Match MPLS experimental imposition label.";
    }
    leaf-list discard-class {
      type Cos;
      max-elements 8;
      description "Match discard class.";
    }
    leaf-list ipv4-packet-length {
      type Num-range;
      max-elements 8;
      description "Match IPv4 packet length.
                   Should be value 0..65535 or range.";
    }
    leaf-list ipv6-packet-length {
      type Num-range;
      max-elements 8;
      description "Match IPv6 packet length. 
                   Should be value 0..65535 or range.";
    }
    leaf-list packet-length {
      type Num-range;
      max-elements 8;
      description "Match packet length. 
                   Should be value 0..65535 or range.";
    }
    leaf mpls-disposition-ipv4-access-list {
      type string {
        length "1..32";
      }
      description "Match MPLS Label Disposition IPv4 access list.";
    }
    leaf mpls-disposition-ipv6-access-list {
      type string {
        length "1..32";
      }
      description "Match MPLS Label Disposition IPv6 access list.";
    }
    leaf-list vlan {
      type Num-range;
      max-elements 8;
      description "Match VLAN ID.";
    }
    leaf cac-admit {
      type empty;
      description "Match CAC admitted.";
    }
    leaf cac-unadmit {
      type empty;
      description "Match CAC unadmitted.";
    }
    leaf-list flow-tag {
      type Num-range;
      max-elements 8;
      description "Match flow-tag. Should be value 1..63 or range.";
    }
    list destination-address-ipv4 {
      key "address netmask";
      max-elements 8;
      description "Match destination IPv4 address.";
      leaf address {
        type inet:ipv4-address-no-zone;
        description "IPv4 address.";
      }
      leaf netmask {
        type inet:ipv4-address-no-zone;
        description "IPv4 netmask.";
      }
    }
    list destination-address-ipv6 {
      key "address prefix-length";
      max-elements 8;
      description "Match destination IPv6 address.";
      leaf address {
        type inet:ipv6-address-no-zone;
        description "IPv6 address.";
      }
      leaf prefix-length {
        type uint8 {
          range "0..128";
        }
        description "IPv6 prefix length.";
      }
    }
    leaf-list destination-port {
      type Num-range;
      max-elements 8;
      description "Match destination port. 
                   Should be value 0..65535 or range.";
    }
    leaf-list fragment-type {
      type string {
        pattern "(first-fragment)|(is-fragment)|(last-fragment)";
      }
      max-elements 3;
      description "Match fragment type for a packet.";
    }
    leaf-list frame-relay-dlci {
      type Num-range;
      max-elements 8;
      description "Match frame-relay DLCI value. 
                   Should be value 16..1007 or range.";
    }
    leaf-list icmpv4-code {
      type Num-range;
      max-elements 8;
      description "Match IPv4 ICMP code. 
                   Should be value 0..255 or range.";
    }
    leaf-list icmpv4-type {
      type Num-range;
      max-elements 8;
      description "Match IPv4 ICMP type. 
                   Should be value 0..255 or range.";
    }
    leaf-list icmpv6-code {
      type Num-range;
      max-elements 8;
      description "Match IPv6 ICMP code. 
                   Should be value 0..255 or range.";
    }
    leaf-list icmpv6-type {
      type Num-range;
      max-elements 8;
      description "Match IPv6 ICMP type. 
                   Should be value 0..255 or range.";
    }
    list source-address-ipv4 {
      key "address netmask";
      max-elements 8;
      description "Match source IPv4 address.";
      leaf address {
        type inet:ipv4-address-no-zone;
        description "IPv4 address.";
      }
      leaf netmask {
        type inet:ipv4-address-no-zone;
        description "IPv4 netmask.";
      }
    }
    list source-address-ipv6 {
      key "address prefix-length";
      max-elements 8;
      description "Match source IPv6 address.";
      leaf address {
        type inet:ipv6-address-no-zone;
        description "IPv6 address.";
      }
      leaf prefix-length {
        type uint8 {
          range "0..128";
        }
        description "IPv6 prefix length.";
      }
    }
    leaf-list source-port {
      type Num-range;
      max-elements 8;
      description "Match source port. 
                   Should be value 0..65535 or range.";
    }
    leaf tcp-flag {
      type uint16 {
        range "1..4095";
      }
      description "Match TCP flag.";
    }
    leaf authen-status {
      type string {
        pattern "(authenticated)|(unauthenticated)";
      }
      description "Match authentication status.";
    }
    list domain-name {
      key "name format";
      max-elements 8;
      description "Match domain name.";
      leaf name {
        type string {
          length "1..32";
        }
        description "Domain name or regular expression.";
      }
      leaf format {
        type string {
          length "1..32";
        }
        description "Domain-format name.";
      }
    }
    leaf-list service-name {
      type string {
        length "1..32";
      }
      max-elements 8;
      description "Match servicve name.";
    }
    leaf-list service-name-regex {
      type string {
        length "1..32";
      }
      max-elements 8;
      description "Match servicve name regular expression.";
    }
    leaf-list timer {
      type string {
        length "1..32";
      }
      max-elements 8;
      description "Match timer.";
    }
    leaf-list timer-regex {
      type string {
        length "1..32";
      }
      max-elements 8;
      description "Match timer regular expression.";
    }
    leaf-list user-name {
      type string {
        length "1..32";
      }
      max-elements 8;
      description "Match user name.";
    }
    leaf-list user-name-regex {
      type string {
        length "1..32";
      }
      max-elements 8;
      description "Match user name regular expression.";
    }
  }
  
  grouping MATCH-MATCHNOT {
    description "match or match-not containers.";
    container match {
      description "Match rules.";
      uses MATCH;
      leaf source-mac {
        type yang:mac-address;
        description "Match source MAC address.";
      }
      leaf destination-mac {
        type yang:mac-address;
        description "Match destination MAC address.";
      }
      leaf-list inner-vlan {
        type Num-range;
        max-elements 8;
        description "Match inner VLAN ID.";
      }
      leaf atm-clp {
        type uint8 {
          range "0..1";
        }
       description "Match ATM CLP bit.";
      }
      leaf atm-oam {
        type empty;
        description "Match ATM OAM.";
      }
      container flow {
        description "Match flow.";
        leaf-list flow-key {
          type string {
            pattern "(SourceIP)|(DestinationIP)|(5Tuple)";
          }
          max-elements 2;
          description "Configure the flow-key parameters.";
        }
        container flow-cache {
          description "Configure the flow-cache parameters";
          leaf idle-timeout {
            type uint16 {
              range "1..65534";
            }
            description "Maximum time of inactivity for a flow.";
          }
        }
      }
      leaf fr-de {
        type uint8 {
          range "0..1";
        }
        description "Match FrameRelay DE bit.";
      }
    }
    container match-not {
      description "Match not rules.";
      uses MATCH;
    }  
  }
  grouping CLASS-MAP-RULE {
    description "Class-map rule";
    leaf class-map-mode-match-any {
      when "count(../class-map-mode-match-all) = 0" {
          description "Class MUST have only one mode.";
      }
      type empty;
      description "Match all match criteria";
    }
    leaf class-map-mode-match-all {
      when "count(../class-map-mode-match-any) = 0" {
          description "Class MUST have only one mode.";
      }
      type empty;
      description "Match any match criteria.";
    }
    uses MATCH-MATCHNOT;
    leaf description {
      type string;
      description "Description for this policy-map.";
    }
  }
  
  grouping POLICY-MARK {
    description "Policy packet marking actions.";
    leaf dscp {
      type Dscp;
      description 
        "Marks a packet by setting the DSCP in the ToS byte.";
    }
    leaf qos-group {
      type uint16 {
        range "0..512";
      }
      description
        "Sets the QoS group identifiers on IPv4 or MPLS packets.
         The set qos-group is supported only on an ingress policy.";
    }
    leaf discard-class {
      type uint8 {
        range "0..7";
      }
      description
        "Sets the discard class on IPv4 or MPLS packets.
         The discard-class can be used only in service policies 
         that are attached in the ingress policy.";
    }
    leaf forward-class {
      type uint8 {
        range "0..7";
      }
      description 
        "Sets the discard class.";
    }
    leaf df {
      type uint8 {
        range "0..1";
      }
      description "Set DF bit.";
    }
    leaf cos {
      type uint8 {
        range "0..7";
      }
      description 
        "Sets the specific IEEE 802.1Q Layer 2 CoS value of an
         outgoing packet.
         This command should be used by a router if a user wants
         to mark a packet that is being sent to a switch. 
         Switches can leverage Layer 2 header information, 
         including a CoS value marking. Packets entering an 
         interface cannot be set with a CoS value.";
    }
    leaf precedence {
      type uint8 {
        range "0..7";
      }
      description "Sets the precedence value in the IP header.";
    }
    leaf mpls-experimental-top-most {
      type uint8 {
        range "0..7";
      }
      description 
        "Sets the experimental value of the MPLS packet top-most
         labels.";
    }
    leaf mpls-experimental-imposition {
      type uint8 {
         range "0..7";
      }
      description
        "Sets the experimental value of the MPLS packet 
         imposition labels.
         Imposition can be used only in service policies that 
         are attached in the ingress policy";
    }
    leaf srp-priority {
      type uint8 {
        range "0..7";
      }
      description 
        "Sets the spatial reuse protocol priority value of an 
         outgoing packet.";
    }
    leaf fr-de {
        type uint8 {
          range "0..1";
        }
        description "Set FrameRelay DE bit.";
    }
  }
  
  grouping CAC-RATE-VALUE {
    description "CAC rate value.";
    leaf value {
      type uint32 {
        range "1..4294967295";
      }
      must "../units" {
        description "units must be set.";
      }
      description "Rate value.";
    }
    leaf units {
      type Cac-rate-units;
      description "Rate units.";
    }
  }
  
  grouping POLICE-ACTION {
    description "Police action.";
    leaf Transmit {
      type empty;
      description "Police action transmit.";
    }
    leaf drop {
      type empty;
      description "Police action drop.";
    }
    container set {
      description "Police action packet marking.";
      uses POLICY-MARK;
    }
  }
  
  grouping POLICY-MAP-RULE {
    description "Class-map rule.";
    list event {
      key "event-type";
      description "Policy event.";
      leaf event-type {
        type Event-type;
        description "Event type.";
      }
      leaf event-mode-match-all {
        when "count(../event-modematch-first) = 0" {
          description "Event MUST have only one mode.";
        }
        type empty;
        description "Execute all the matched classes.";
      }
      leaf event-modematch-first {
        when "count(../event-modematch-all) = 0" {
          description "Event MUST have only one mode.";
        }
        type empty;
        description "Execute only the first matched class.";
      }
      list class {
        key "class-name class-type";
        description "Class-map rule.";
        leaf class-name {
          type string {
            pattern "[a-zA-Z0-9][a-zA-Z0-9\._@$%+#:=<>\-]{0,62}";
          }
          description "Name of class.";
        }
        leaf class-type {
          type Pmap-class-map-type;
          description "Type of class.";
        }
        leaf class-execution-strategy {
          type Execution-strategy;
          description "Class execution strategy.";
        }
        list action-rule {
          key "action-sequence-number";
          description "Action rule.";
          leaf action-sequence-number {
            type uint16 {
              range "1..65535";
            }
            description "Sequence number for this action.";
          }
          container activate-dynamic-template {
            presence "This container is present only if actions is
                      related to dynamic templates.";
            description "Activate dynamic templates.";
            leaf name {
              type string;
              mandatory true;
              description "Dynamic template name.";
            }
            leaf aaa-list {
              type string;
              description "Name of the AAA method list.";
            }
          }
          container authenticate {
            description "Authentication related configuration.";
            leaf aaa-list {
              type string;
              description "Name of the AAA method list.";
            }
          }
          container authorize {
            must "format or identifier" {
              description "format or identifier must be set.";
            }
            presence "This container is present only if actions is
                      related to authorization.";
            description "Authorize.";
            leaf aaa-list {
              type string;
              mandatory true;
              description "Name of the AAA method list.";
            }
            leaf format {
              type string;
              description "Specify an Authorize format name.";
            }
            leaf identifier {
              type Authorize-identifier;
              description "Specify an Authorize format name.";
            }
            leaf password {
              type string;
              mandatory true;
              description "Specify a password to be used for AAA
                           request.";
            }
          }
          container deactivate-dynamic-template {
            presence "This container is present only if actions is
                      related to dynamic templates.";
            description "Deactivate dynamic templates.";
            leaf name {
              type string;
              mandatory true;
              description "Dynamic template name.";
            }
            leaf aaa-list {
              type string;
              description "Name of the AAA method list.";
            }
          }
          leaf disconnect {
            type empty;
            description "Disconnect session.";
          }
          leaf monitor {
            type empty;
            description "Monitor session.";
          }
          container set-timer {
            presence "This container is present only if actions is
                      related to timer.";
            description "Set a timer to execute a rule on its 
                         expiry";
            leaf timer-name {
              type string;
              mandatory true;
              description "Name of the timer.";
            }
            leaf timer-value {
              type uint32;
              units "minutes";
              mandatory true;
              description "Timer value in minutes.";
            }
          }
          container stop-timer {
            description "Disable timer before it expires.";
            leaf timer-name {
              type string;
              description "Name of the timer.";
            }
          }
        }
      }
    }
    list policy-map-rule {
      key "class-name class-type";
      description "Class-map rule.";
      leaf class-name {
        type string {
          pattern "[a-zA-Z0-9][a-zA-Z0-9\._@$%+#:=<>\-]{0,62}";
        }
        description "Name of class-map.";
      }
      leaf class-type {
        type Pmap-class-map-type;
        description "Type of class-map.";
      }
      container shape {
        description "Policy action shape.";
        leaf value {
          type uint32;
          must "../unit" {
            description "unit must be set.";
          }
          description "Shape bandwidth value.";
        }
        leaf unit {
          type Bandwidth-units;
          description "Shape bandwidth units.";
        }
      }
      container min-bandwidth {
        description "Policy action minimum bandwidth queue.";
        leaf value {
          type uint32;
          must "../unit" {
            description "unit must be set.";
          }
          description "Minimum bandwidth value.";
        }
        leaf unit {
          type Bandwidth-units;
          description "Minimum bandwidth units.";
        }
      }
      container bandwidth-remaining {
        description "Policy action bandwidth remaining queue.";
        leaf value {
          type uint32;
          must "../unit" {
            description "unit must be set.";
          }
          description "Remaining bandwidth value.";
        }
        leaf unit {
          type Bandwidth-units;
          description "Remaining bandwidth units.";
        }
      }
      container queue-limit {
        description "Policy action queue limit.";
        leaf value {
          type uint32;
          must "../unit" {
            description "unit must be set.";
          }
          description "Remaining bandwidth value.";
        }
        leaf unit {
          type Queue-units;
          description "Remaining bandwidth units.";
        }
      }
      leaf priority-level {
        type uint8 {
          range "1..7";
        }
        description "Priority level.";
      }
      leaf default-red {
        type empty;
        description "Default random early detection";
      }
      list random-detect {
        key "threshold-min-value threshold-min-units "+
            "threshold-max-value threshold-max-units";
        description "Random early detection.
                     All RED profiles in a class must be based
                     on the same field.";
        leaf threshold-min-value {
          type uint32;
          description "Minimum RED threshold value.";
        }
        leaf threshold-min-units {
          type Threshold-units;
          description "Minimum RED threshold units.";
        }
        leaf threshold-max-value {
          type uint32;
          description "Maximum RED threshold value.";
        }
        leaf threshold-max-units {
          type Threshold-units;
          description "Maximum RED threshold units.";
        }
        leaf-list cos {
          type Dscp-range;
          max-elements 8;
          description "WRED based on CoS.";
        }
        leaf-list discard-class {
          type Cos;
          max-elements 8;
          description "WRED based on discard class.";
        }
        leaf-list dscp {
          type Dscp-range;
          max-elements 8;
          description "WRED based on DSCP.";
        }
        leaf-list mpls-exp {
          type Cos;
          max-elements 8;
          description "MPLS Experimental value based WRED.";
        }
        leaf-list precedence {
          type Precedence;
          max-elements 8;
          description "WRED based on precedence.";
        }
        leaf dei {
          type uint8 {
            range "0..1";
          }
          description "DEI based WRED.";
        }
        leaf ecn {
          type empty;
          description "ECN based WRED.";
        }
      }
      container set {
        description "Policy action packet marking.";
        uses POLICY-MARK;
      }
      container police {
        must "rate" {
          description "rate container must be present.";
        }
        description "Configures traffic policing action.";
        container rate {
          description "Rate configuration.";
          leaf value {
            type uint32;
            must "../units" {
              description "units must be set.";
            }
            description "Rate value.";
          }
          leaf units {
            type Rate-units;
            description "Rate units.";
          }
        }
        container peak-rate {
          description "Peak rate configuration.";
          leaf value {
            type uint32;
            must "../units" {
              description "units must be set.";
            }
            description "Peak rate value.";
          }
          leaf units {
            type Rate-units;
            description "Peak rate units.";
          }
        }
        container burst {
          description "Burst configuration.";
          leaf value {
            type uint32;
            must "../units" {
              description "units must be set.";
            }
            description "Burst value.";
          }
          leaf units {
            type Threshold-units;
            description "Burst units.";
          }
        }
        container peak-burst {
          description "Peak burst configuration.";
          leaf value {
            type uint32;
            must "../units" {
              description "units must be set.";
            }
            description "Peak burst value.";
          }
          leaf units {
            type Threshold-units;
            description "Peak burst units.";
          }
        }
        container conform-action {
          description 
            "Configures the action to take on packets that conform 
             to the rate limit.";
          uses POLICE-ACTION;
        }
        container exceed-action {
          description 
            "Configures the action to take on packets that exceed 
             the rate limit.";
          uses POLICE-ACTION;
        }
        container violate-action {
          description
            "Configures the action to take on packets that violate
             the rate limit.";
          uses POLICE-ACTION;
        }
      }
      container service-policy {
        description 
          "Configure a child service policy.";
        leaf policy-name {
          type string {
            pattern "[a-zA-Z0-9][a-zA-Z0-9\._@$%+#:=<>\-]{0,62}";
          }
          description "Name of service-policy.";
        }
        leaf type {
          type Service-policy-type;
          description "Type of service-policy.";
        }
      }
      container cac-local {
        description "Policy action CAC.";
        container rate {
          description "The rate allocated for all flows.";
          uses CAC-RATE-VALUE;
        }
        container flow-rate {
          description "The rate allocated per flow.";
          uses CAC-RATE-VALUE;
        }
        leaf flow-idle-timeout {
          type Idle-timeout;
          description "The interval after which a flow is removed, 
                       if there is no activity.
                       If timeout is 0 this flow does not expire.";
        }
      }
      container flow-params {
        description "Policy flow monitoring action.";
        leaf max-flow {
          type uint16 {
            range "0..4096";
          }
          description 
            "Max simultaneous flows monitored per policy class";
        }
        leaf interval-duration {
          type uint32;
          units "seconds";
          description "Monitored interval duration.";
        }
        leaf history {
          type uint32;
          description 
            "Keep stats/metrics on box for so many intervals.";
        }
        leaf timeout {
          type uint32;
          units "seconds";
          description "Declare a flow dead if no packets received in
                       so much time";
        }
      }
      container metrics-ipcbr {
        description "Policy IP-CBR metric action.";
        container rate {
          description "Nominal per-flow data rate.";
          leaf layer3 {
            type uint32;
            units "bps";
            description "Nominal rate specified at the L3 (IP).";
          }
          leaf packet {
            type uint32;
            units "pps";
            description "Nominal IP layer packet rate (in pps).";
          }
          leaf media {
            type uint32 {
              range "1..3000000000";
            }
            units "bps";
            description 
              "Nominal data rate of the media flow (ip payload).";
          }
        }
        container media-packet {
          description "Media-packet structure.";
          leaf size {
            type uint16;
            units "bytes";
            description "Nominal size of the media-packet.";
          }
          leaf count-in-layer3 {
            type uint8 {
              range "1..64";
            }
            units "packets";
            description 
              "Nominal number of media packets in an IP payload.";
          }
        }
      }
      container react {
        description "Policy action react.";
        leaf descrition {
          type string;
          description "String describing the react statement.";
        }
        container action {
          description "Action on alert.";
          leaf syslog {
            type empty;
            description "Syslog.";
          }
          leaf snmp {
            type empty;
            description "SNMP.";
          }
        }
        container alarm {
          description "Alaram settings.";
          container type {
            description "Alarm type.";
            leaf discrete {
              type empty;
              description "Discrete alarm type.";
            }
            leaf group-count {
              type uint16;
              units "number of flows";
              description "Number of flows to reach before 
                           triggering alarm";
            }
            leaf group-percent {
              type uint16;
              units "percentage";
              description "Percent to reach before triggering alarm";
            }
          }
          leaf severity {
            type Alarm-severity;
            description "Severity of the alarm.";
          }
        }
        container treshold {
          description "Alarm threshold settings.";
          container trigger-value {
            description "Alarm trigger value settings.";
            leaf greater-than {
              type string;
              description "Greater than";
            }
            leaf greater-than-equal {
              type string;
              description "Greater than equal";
            }
            leaf less-than {
              type string;
              description "Less than";
            }
            leaf less-than-equal {
              type string;
              description "Less than equal";
            }
            leaf range {
              type string;
              description "Range";
            }
          }
          container trigger-type {
            description "Alarm trigger type settings.";
            leaf immediate {
              type empty;
              description "Immediate trigger.";
            }
            leaf average {
              type uint32;
              description "Trigger averaged over N intervals.";
            }
          }
        }
        leaf criterion-delay-factor {
          type empty;
          description "React criterion delay factor.";
        }
        leaf criterion-media-stop {
          type empty;
          description "React criterion media stop.";
        }
        leaf criterion-mrv {
          type empty;
          description "React criterion mrv.";
        }
        leaf criterion-flow-count {
          type empty;
          description "React criterion flow count.";
        }
        leaf criterion-packet-rate {
          type empty;
          description "React criterion packet rate.";
        }
      }
      container pbr {
        description "Policy action PBR.";
        leaf http-redirect {
          type string;
          description "Policy action http redirect.
                       Redirect to this url.";
        }
        leaf pbr-transmit {
          type empty;
          description "Policy action PBR transmit.";
        }
        leaf pbr-drop {
          type empty;
          description "Policy action PBR drop.";
        }
        container pbr-forward {
          description "Policy action PBR forward.";
          leaf default {
            type empty;
            description "Use system default routing table.";
          }
          container next-hop {
            description "Use specific next-hop.
                         Here we present 5 different combination 
                         for the pbf next-hop.
                          1. vrf with v6 address
                          2. vrf with v4 address
                          3. vrf 
                          4. v4 address
                          5. v6 address";
            leaf vrf {
              type string;
              description "VRF name.";
            }
            leaf ipv4-address {
              type inet:ipv4-address;
              description "IPv4 address.";
            }
            leaf ipv6-address {
              type inet:ipv6-address;
              description "IPv6 address.";
            }
          }
        }
        container set {
          description "PBR action packet marking.";
          uses POLICY-MARK;
        }
      }
      leaf service-fragment {
        type string;
        description "Policy action service fragment. 
                     Service fragment name";
      }
      leaf fragment {
        type string;
        description "Policy action fragment. Fragment name";
      }
    }
    leaf description {
      type string;
      description "Description for this policy-map.";
    }
  }
  
  container policy-manager {
    description "Global Policy Manager configuration.";
    
    container class-maps {
      description "Class-maps configuration.";
      list class-map {
        key "type name";
        description "Class-map configuration.";
        leaf type {
          type Class-map-type;
          description "Type of class-map.";  
        }
        leaf name {
          type string {
            pattern "[a-zA-Z0-9][a-zA-Z0-9\._@$%+#:=<>\-]{0,62}";
          }
          description "Name of class-map.";
        }
        
        uses CLASS-MAP-RULE;
      }
    }
    
    container policy-maps {
      description "Policy-maps configuration.";
      list policy-map {
        key "type name";
        description "Policy-map configuration.";
        leaf type {
          type Policy-map-type;
          description "Type of policy-map.";
        }
        leaf name {
          type string {
            pattern "[a-zA-Z0-9][a-zA-Z0-9\._@$%+#:=<>\-]{0,62}";
          }
          description "Name of policy-map.";
        }
        
        uses POLICY-MAP-RULE;
      }
    }
  }
}
