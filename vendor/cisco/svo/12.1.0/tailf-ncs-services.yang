submodule tailf-ncs-services {
  yang-version 1.1;
  belongs-to tailf-ncs {
    prefix ncs;
  }

  import tailf-common {
    prefix tailf;
  }

  import ietf-yang-types {
    prefix yang;
  }

  include tailf-ncs-common;
  include tailf-ncs-customers;
  include tailf-ncs-devices;
  include tailf-ncs-log;

  organization "Tail-f Systems";

  description
    "This submodule contains a collection of YANG definitions for
     configuring and monitoring services in NCS.

     Copyright 2019 Cisco Systems, Inc.
     All rights reserved.
     Permission is hereby granted to redistribute this file without
     modification.";

  revision 2020-02-04 {
    description
      "Released as a part of NCS-5.2.2.

       Changed the type of transaction-hook ncs-rfs-service-hook from
       subtree to node.";
  }

  revision 2019-04-09 {
    description
      "Released as part of NCS-5.1.

       Added ned-id-list in the service's private data.";
  }

  revision 2018-06-21 {
    description
      "Released as part of NCS-4.7.

       Added 'sync' empty leaf to 'reactive-re-deploy' input.

       Added 'ncs-commit-result' grouping to 'reactive-re-deploy' output.";
  }

  revision 2018-03-01 {
    description
      "Released as part of NCS-4.6.

       Renamed all 'dryrun' groupings to 'dry-run'.";
  }

  revision 2017-11-30 {
    description
      "Released as part of NCS-4.5.2.

       Added new option 'reverse' to 'commit-dry-run' action.";
  }

  revision 2017-09-28 {
    description
      "Released as part of NCS-4.5.

       Removed 'ncs-commit-result' grouping from 'reactive-re-deploy'
       output.";
  }

  revision 2017-03-16 {
    description
      "Released as part of NCS-4.4.

       Corrected description for
       commit-queue/queue-item/failed-device/config-data in grouping
       service-commit-queue.";
  }

  revision 2016-11-24 {
    description
      "Released as part of NCS-4.3.

       Added additional dry-run parameter to un-deploy action.

       Added grouping service-get-modifications to share the
       get-modifications action between services and nano-services.

       Added lsa-service-list in the service's private data to
       keep track of services on a remote NCS node in LSA architecture
       this service has touched.

       Changed output format for the following actions: re-deploy,
       un-deploy, check-sync, deep-check-sync, get-modifications and
       commit-dry-run in order to be able to present changes associated
       with remote LSA nodes and services residing at these nodes.

       Added 'lsa-services' leaf-list under 'modified' and 'directly-modified'
       that shows references to LSA services this service has touched.

       Removed leaf 'device-modifications' that was deprecated in NCS-3.0.

       Changed model of commit-queue for a service to be a list
       of queue-items. Replaced action 'clear' by action 'admin-clear' and
       and action 'purge' by action 'delete'. Added an action 'clear'
       which deletes the whole list of queue-items.";
  }

  revision 2016-05-26 {
    description
      "Released as part of NCS-4.2.

       Added service action 'touch'.

       Renamed input parameter from supress-positive-result to
       suppress-positive-result for the /services/check-sync action

       Added parameter 'reconcile' to service action 're-deploy'.

       Added suppress-positive-result input parameter to check-sync and
       deep-check-sync actions under service-data grouping

       Changed the output format for 'check-sync', 'deep-check-sync',
       're-deploy' and 'commit-dry-run' to be consistent.";
  }

  revision 2015-11-24 {
    description
      "Released as part of NCS-4.1.

       Added service private data:
       'private/device-list' and 'private/service-list'.

       Added parameters, 'shallow' and 'deep'  to service action
       'check-sync'.

       Added parameters, 'shallow' and 'deep'  to service action
       're-deploy'.

       Added parameters, 'shallow' and 'deep'  to service action
       'get-modifications'.

       Added service 'modified' and 'directly-modified'.

       Deprecated service leaf-list 'device-list', use service
       'modified' and 'directly-modified' instead.

       Added grouping service-reactive-re-deploy and the use hereof.";
  }

  revision 2015-03-19 {
    description
      "Released as part of NCS-3.4.

       Minor description enhancements.";
  }

  revision 2014-12-10 {
    description
      "Released as part of NCS-3.3.1.

       Changed the service's commit-queue status 'failed-admin-cleared'
       to 'admin-cleared' and added new state 'commit-queue-failed'.";
  }

  revision 2014-11-19 {
    description
      "Released as part of NCS-3.3.

       Changed data type of 'commit-queue/queue-item' from int64
       to uint64.";
  }

  revision 2014-06-30 {
    description
      "Released as part of NCS-3.2.

       Use ncs-commit-* groupings in re-deploy and un-deploy.

       Changed a service's commit-queue/status enumeration to match
         the enumeration in /devices/device/commit-queue/status.

       Changed a service's commit-queue/failed-devices from a leaf-list
         to a list, and added some info.";
  }

  revision 2014-05-20 {
    description
      "Released as part of NCS-3.1.1.1.

       Added no-overwrite to un-deploy and re-deploy.

       Changed the names of the status leaf in the commit-queue stats
         container, in order to align with the status in
         /devices/commit-queues/queue-item/status.";
  }

  revision 2014-05-08 {
    description
      "Released as part of NCS-3.1.1.

       Added addtional fields in the commit-queue stats container with
       information about the error returned by the device, including
       the entire configuration data which was rejected";
  }

  revision 2014-04-02 {
    description
      "Released as part of NCS-3.1.";
  }

  revision 2013-11-12 {
    description
      "Released as part of NCS-3.0.

       Removed use of grouping service-data-no-hook in list /services/service.

       Removed callpoint ncs-rfs-service-case-hook in list /services/service.

       Removed action self-test in list /services/service.

       Removed leaf action-opaque from grouping service-data-no-hook/private.

       Removed leaf data-opaque from grouping service-data-no-hook/private.

       Removed grouping service-data-no-hook and introduced parts in grouping
         service-data.

       Removed YANG extension service-template-name and grouping
         service-template-data.

       Renamed the output container 'xml' in 'check-sync' and 're-deploy'
         to 'result-xml'.  The name 'xml' is illegal in YANG.  Also, changed
         the resulting leaf 'data' to anyxml 'data'.

       Added an action 'get-modifications' that returns the modifications
         a service introduced, in CLI and XML format.

       Added leaf /services/global-settings/collect-forward-diff.";
  }

  revision 2013-06-18 {
    description
      "Released as part of NCS-2.3.

       Added YANG extensions servicepoint and grouping service-data, to be
         used by service data models.

       Removed fastmap and extended support for customer facing services.

       Deprecated the action /services/commit-dry-run.  Use
         commit dry-run in the CLI instead.

       Removed the actions /services/fastmap/disable and enable.  Use
         commit no-fastmap in the CLI instead.

       Removed /services/status-summary operational data container.

       Removed /services/service/uses-service.

       Removed /services/services/used-by-cust-service operational data
       Removed /services/services/service-status operational data
       Since these only could hold information for a subset of services.";
  }

  revision 2013-03-12 {
    description
      "Released as part of NCS-2.2.

       Added native format to /services/commit-dry-run.
       Added YANG extension service-template-name and grouping
         service-template-data.";
  }

  revision 2012-08-30 {
    description
      "Released as part of NCS-2.0.";
  }

  /*
   * Services implemented as callbacks.
   */

  extension servicepoint {
    argument id {
      tailf:arg-type {
        type tailf:identifier;
      }
    }
    tailf:use-in "list";
    tailf:use-in "container";
    tailf:use-in "grouping";
    tailf:substatement "description";
    tailf:substatement "tailf:opaque";
    tailf:substatement "tailf:internal";
    description
      "This statement marks the list or container in which it appears
       to be used as service parameters for a service implemented
       by a callback in a data provider.";
  }

  extension lsa-service {
    tailf:use-in "list";
    tailf:use-in "container";
    tailf:substatement "description";
    description
      "This extension indicates that the node it appears on is
       the top node of an NCS service on a remote NCS node in
       LSA architecture.";
  }

  grouping service-data {
    description
      "Use this grouping together with ncs:servicepoint
       in order to get the common definitions for a service
       implemented by a callback function.";

    tailf:callpoint ncs-rfs-service-hook {
      tailf:transaction-hook node {
        tailf:invocation-mode per-transaction;
      }
    }

    uses service-check-sync;
    uses service-deep-check-sync;
    uses service-re-deploy;
    uses service-reactive-re-deploy;
    uses service-touch;
    uses service-impacted-devices;
    uses service-un-deploy;
    uses service-customer-service;
    uses service-commit-queue;
    uses service-private-data;
    uses log-data;
  }

  grouping service-commit-queue {
    container commit-queue {
      config false;
      tailf:cdb-oper {
        tailf:persistent true;
      }
      tailf:action clear {
        description
          "Clear the service commit queue of all queue items.
           If this action is invoked for an queue-items which has other states
           than 'failed' those items migth later reappear since this service
           is then still affected by active commit queue transactions";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
      }

      list queue-item {
        key id;
        leaf id {
          type uint64;
          description
            "If the queue item in the commit queue refers to this service
             this is the queue number.";
        }
        description
          "When a service is committed through the commit queue, these
           fields act as references regarding the state of this service
           instance. In the worst case scenario, a service instance is
           in the 'failed' state. This means that parts of the queued
           commit failed.

           If a service gets committed through the commit queue and the
           commit fails, the backpointers in the service data are
           followed and the affected service instances are updated and
           set to the 'failed' state.

           Depending on the nature of the failure, different techniques
           to reconcile the service can be used.

           - Make sure the commit queue is blocked to not interfere
             with the error recovery procedure.
             Do a sync-from on the non-completed device(s) and then
             re-deploy the failed service(s) with the
             'reconcile' option to reconcile original data,
             i.e., take control of that data. This option
             acknowledges other services controlling the same data.
             The reference count will indicate how many services control
             the data. Release any queue lock that was created.

           - Make sure the commit queue is blocked to not interfere
             with the error recovery procedure.
             Use un-deploy with the no-networking option on the
             service and then do sync-from on the non-completed
             device(s). Make sure the error is fixed and then
             re-deploy the failed service(s) with the
             'reconcile' option. Release any queue lock
             that was created.

           In the 'failed' state, these fields are reset if a new
           commit queue transaction is affecting this service, or
           the service is re-deployed, or these fields are deleted
           using the specific purge action.
           In other cases the 'failed' state will remain.";
        leaf status {
          tailf:callpoint ncs {
            tailf:internal;
          }
          type enumeration {
            enum waiting {
              description
                "This service was committed through the commit queue
                 and the data is in the queue, waiting to run.";
            }
            enum executing {
              description
                "The data for this service is currently executing at the
               head of the commit queue.";
            }
            enum blocking {
              description
                "One or more of the devices for the transaction
               of which this service instance is a part, exposes a
               transient error.  The queue item in the commit queue
               remains there until the device becomes operational
               or the queue is pruned.

               Examples of transient errors are connection failures
               and that if thre changes are rejected due to the device
               being locked.

               The status for the queue item, in
               /devices/commit-queue/queue-item, contains details
               about this state.";
            }
            enum blocked {
              description
                "The data for this service is waiting in the queue, and some
               other queue item ahead of this item is in state 'blocking'.";
            }
            enum failed {
              description
                "The data for the transaction was not successfully
               deployed on all devices.  This service is is not
               operational.

               Details about the error can be found in the
               'failed-device' list.

               The queue item itself is removed from the
               /devices/commit-queue/queue-item list when it fails.";
              tailf:code-name "service_failed";
            }
            enum admin-cleared {
              description
                "The queue item affecting this service has been administratively
               cleared. Either directly by a clear action on this service
               commit queue data, or indirectly because of a delete/prune
               action directly on the commit queue queue-item.

               In either case, device data for this service may or may not
               have been deployed in the network.";
            }
            enum commit-queue-failed {
              description
                "The data for the transaction was not successfully
               deployed on all devices. Since serveral services where modified
               by this transaction, whether this service is operational or
               not is indecisive.

               Details about the error can be found in the
               'failed-device' list.

               The queue item itself is removed from the
               /devices/commit-queue/queue-item list when it fails.";
            }
          }
        }

        leaf cleared-by-admin {
          type empty;
          tailf:hidden full;
        }

        leaf no-of-impacted-services {
          tailf:hidden full;
          type uint32;
        }

        list failed-device {
          description
            "If the 'status' leaf is 'failed', this list contains detailed
           information on the devices that were responsible for the
           error of the commit queue item.";
          key name;
          leaf name {
            type leafref {
              path '/ncs:devices/ncs:device/ncs:name';
            }
          }
          leaf time {
            type yang:date-and-time;
            description
              "Time when the failure occured.";
          }
          leaf config-data {
            description
              "The configuration data that was rejected by the device
               in XML format.";
            tailf:cli-preformatted;
            type string;
          }
          leaf error {
            description
              "The error returned by the device.";
            type string;
          }
        }

        tailf:action admin-clear {
          description
            "Administratively clear this item.
             Information about failed devices will remain for this service.";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
        }

        tailf:action delete {
          description
            "Delete this item.
             If this action is invoked for an item which is in other states
             than 'failed' this data migth later reappear since this service
             is then still affected by an active commit queue transaction";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
        }

      }
    }
  }

  grouping service-un-deploy {
    tailf:action un-deploy {
      description
        "Undo the effects of the service instance but keep the
         service itself. The service can later be re-deployed. This is
         a means to deactivate a service, but keeping it in the system.";
      tailf:info "Undo the effects of the service";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        container dry-run {
          presence "";
          leaf outformat {
            type outformat3;
          }
        }
        uses ncs-commit-params;
        leaf ignore-refcount {
          type empty;
          description
            "Unconditionally delete the device data created by the
             service, regardless of the refcount.";
        }
      }
      output {
        choice outformat {
          case case-xml {
            uses dry-run-xml;
          }
          case case-cli {
            uses dry-run-cli;
          }
          case case-native {
            uses dry-run-native;
          }
        }
        uses ncs-commit-result;
      }
    }
  }

  grouping service-private-data {
    container private {
      description
        "NCS service related internal data stored here.";
      tailf:hidden fastmap-private;
      leaf diff-set {
        description
          "Internal node use by NCS service manager to remember
           the reverse diff for a service instance. This is the
           data that is used by FastMap";
        tailf:hidden full;
        type binary;
      }
      leaf forward-diff-set {
        description
          "Internal node use by NCS service manager to remember
           the forwards diff for a service instance. This data is
           is used to produce the proper 'get-modifications' output";
        tailf:hidden full;
        type binary;
      }
      leaf-list device-list {
        description
          "A list of managed devices this service instance has manipulated.";
        tailf:hidden full;
        type string;
      }
      leaf-list ned-id-list {
        description
          "A list of NED identities this service instance has manipulated.";
        tailf:hidden full;
        type string;
      }
      leaf-list service-list {
        description
          "A list of services this service instance has manipulated.";
        tailf:hidden full;
        type instance-identifier {
          require-instance false;
        }
      }
      leaf-list lsa-service-list {
        description
          "A list of LSA services this service instance has manipulated.";
        tailf:hidden full;
        type instance-identifier {
          require-instance false;
        }
      }
      container property-list {
        description
          "FASTMAP service instance data used by the service implementation.";
        list property {
          key name;
          leaf name {
            type string;
          }
          leaf value {
            type string;
          }
        }
      }
      leaf re-deploy-counter {
        type int32;
        default 0;
      }
      leaf latest-commit-params {
        tailf:hidden full;
        type binary;
        description
          "Latest transactions commit parameters are stored there, these are
           used in reactive-re-deploy actions that must have the same
           parameters as the original service commit.";
      }
      leaf latest-u-info {
        tailf:hidden full;
        type binary;
        description
          "Latest transactions user info is stored there, these are
           used in reactive-re-deploy actions that must be performed by
           a user with the same user info.";
      }
    }
  }

  /*
   * Common service groupings.
   */

  grouping service-check-sync {
    tailf:action check-sync {
      tailf:info "Check if device config is according to the service";
      description
        "Check if the service has been undermined, i.e., if the service
         was to be re-deployed, would it do anything. This action will
         invoke the FASTMAP code to create the change set that is compared
         to the existing data in CDB locally.

         If outformat is boolean, 'true' is returned if the service is
         in sync, i.e., a re-deploy would do nothing. If outformat is
         cli or xml, the changes that the service would do to the
         network if re-deployed are returned.";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }

      input {
        leaf outformat {
          type outformat4;
          default boolean;
        }
        uses service-depth {
          refine "depth/deep" {
            description "Recursively 'check-sync' stacked services";
          }
          refine "depth/shallow" {
            description "Only 'check-sync' the topmost service";
          }
        }
        leaf suppress-positive-result {
          type empty;
          tailf:info "Return list only contains negatives";
          description
            "Use this additional parameter to only return services that
             failed to sync.";
        }
        uses choice-lsa-grouping;
      }
      output {
        choice outformat {
          leaf 'in-sync' {
            type boolean;
          }
          case case-xml {
            uses dry-run-xml;
          }
          case case-cli {
            uses dry-run-cli;
          }
          case case-native {
            uses dry-run-native;
          }
        }
      }
    }
  }

  grouping service-deep-check-sync {
    tailf:action deep-check-sync {
      tailf:info "Check if device config is according to the service";
      description
        "Check if the service has been undermined on the device itself.
         The action 'check-sync' compares the output of the service
         code to what is stored in CDB locally. This action retrieves the
         configuration from the devices touched by the service and compares
         the forward diff set of the service to the retrieved data. This
         is thus a fairly heavy weight operation. As opposed to the check-sync
         action that invokes the FASTMAP code, this action re-applies the
         forward diff-set. This is the same output you see when inspecting
         the 'get-modifications' operational field in the service instance.

         If the device is in sync with CDB, the output of this action
         is identical to the output of the cheaper check-sync action";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf outformat {
          type outformat-deep-check-sync;
          default boolean;
        }
        leaf suppress-positive-result {
          type empty;
          tailf:info "Return list only contains negatives";
          description
            "Use this additional parameter to only return services that
             failed to sync.";
        }
        uses choice-lsa-grouping;
      }
      output {
        choice outformat {
          case case-xml {
            uses service-modifications-xml;
          }
          case case-cli {
            uses service-modifications-cli;
          }
          case case-sync {
            uses service-sync;
          }
        }
      }
    }
  }

  grouping service-re-deploy {
    tailf:action re-deploy {
      tailf:info "Run/Dry-run the service logic again";
      description
        "Run the service code again, possibly writing the changes of
         the service to the network once again.

         If the dry-run option is used,
         the action simply reports (in different formats) what it would do.

         Use the option 'reconcile' if the service should reconcile
         original data, i.e., take control of that data. This option
         acknowledges other services controlling the same data.";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        container dry-run {
          presence "";
          leaf outformat {
            type outformat3;
          }
        }
        uses ncs-commit-params;
        uses service-depth {
          refine "depth/deep" {
            description "Recursively 're-deploy' stacked services";
          }
          refine "depth/shallow" {
            description "Only 're-deploy' the topmost service";
          }
        }
        container reconcile {
          description
            "Reconcile the service data. All data which existed before
             the service was created will now be owned by the service.
             The reference count will indicate how many services control
             the data. When the service is removed that data will also be
             removed. In technical terms the reference count will be
             decreased by one for everything which existed prior to the
             service.

             If manually configured data exists below in the configuration
             tree that data is kept unless the option
             'discard-non-service-config' is used.";
          presence "";
          choice c-non-service-config {
            leaf keep-non-service-config {
              type empty;
            }
            leaf discard-non-service-config {
              type empty;
            }
            default keep-non-service-config;
          }
        }
      }
      output {
        choice outformat {
          case case-xml {
            uses dry-run-xml;
          }
          case case-cli {
            uses dry-run-cli;
          }
          case case-native {
            uses dry-run-native;
          }
        }
        uses ncs-commit-result;
      }
    }
  }

  grouping service-reactive-re-deploy {
    tailf:action reactive-re-deploy {
      tailf:info "Reactive re-deploy of service logic";
      description
        "This is a tailored re-deploy intended to be used in the reactive
         FASTMAP scenario. It differs from the ordinary re-deploy in that
         this action does not take any commit parameters.

         This action will re-deploy the services as an
         'shallow' depth re-deploy. It will be performed with the same
         user as the original commit. Also, the commit parameters will be
         identical to the latest commit involving this service.

         By default this action is asynchronous and returns nothing.";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf sync {
          description
            "By default the action is asynchronous, i.e. it does not wait for
             the service to be re-deployed. Use this leaf to get synchronous
             behaviour and block until the service re-deploy transaction is
             committed. It also means that the action will possibly return
             a commit result, such as commit queue id if any, or an
             error if the transaction failed.";
          type empty;
        }
      }
      output {
        uses ncs-commit-result;
      }
    }
  }

  grouping service-touch {
    tailf:action touch {
      tailf:info "Mark the service as changed";
      tailf:cli-configure-mode;
      description
        "This action marks the service as changed.

         Executing the action touch followed by a commit is the same as
         executing the action 're-deploy shallow'.

         By using the action 'touch' several re-deploys can be performed
         in the same transaction.";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
      }
      output {
      }
    }
  }

  grouping service-impacted-devices {
    container modified {
      config false;
      tailf:callpoint ncs {
        tailf:internal;
      }
      description
        "Devices and other services this service has modified directly or
         indirectly (through another service).";
      tailf:info
        "Devices and other services this service modified directly or
         indirectly.";
      leaf-list devices {
        tailf:info
          "Devices this service modified directly or indirectly";
        type leafref {
          path "/ncs:devices/ncs:device/ncs:name";
        }
      }
      leaf-list services {
        tailf:info
          "Services this service modified directly or indirectly";
        type instance-identifier {
          require-instance false;
        }
      }
      leaf-list lsa-services {
        tailf:info
          "Services residing on remote LSA nodes this service
           has modified directly or indirectly.";
         type instance-identifier {
           require-instance false;
         }
      }
    }

    container directly-modified {
      config false;
      tailf:callpoint ncs {
        tailf:internal;
      }
      description
        "Devices and other services this service has explicitly
         modified.";
      tailf:info
        "Devices and other services this service has explicitly
         modified.";
      leaf-list devices {
        tailf:info
          "Devices this service has explicitly modified.";
        type leafref {
          path "/ncs:devices/ncs:device/ncs:name";
        }
      }
      leaf-list services {
        tailf:info
          "Services this service has explicitly modified.";
        type instance-identifier {
          require-instance false;
        }
      }
      leaf-list lsa-services {
        tailf:info
          "Services residing on remote LSA nodes this service
           has explicitly modified.";
         type instance-identifier {
           require-instance false;
         }
      }
    }

    uses service-get-modifications;

    leaf-list device-list {
      tailf:info "A list of devices this service instance has manipulated";
      type string;
      config false;
      status deprecated;
      description
        "A list of managed devices this service instance has manipulated.

         This leaf is deprecated. Use 'modified' instead.";
      tailf:callpoint ncs {
        tailf:internal;
      }
    }
  }

  grouping service-get-modifications {
    tailf:action get-modifications {
      tailf:info "Get the data this service created";
      description
        "Returns the data the service modified, either
         in CLI curly bracket format, or NETCONF XML edit-config format.
         This data is only available if the parameter
         '/services/global-settings/collect-forward-diff' is set to true.

         If the parameter 'reverse' is given the modifications needed
         to 'reverse' the effect of the service is shown. This will
         be applied if the service is deleted. This data is always
         available.

         The parameter deep/shallow controls if the modifications shown
         are for this service only or for all modiefied services as well.";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf outformat {
          type outformat2;
        }
        leaf reverse {
          description
            "Show the modifications needed to 'reverse' the effect of
             the service.";
          type empty;
        }
        uses service-depth {
          refine "depth/deep" {
            description
              "Recursively 'get-modifications' for stacked services";
          }
          refine "depth/shallow" {
            description "Only 'get-modifications' for the topmost service";
          }
        }
        uses choice-lsa-grouping;
      }
      output {
        choice outformat {
          case case-xml {
            uses service-modifications-xml;
          }
          case case-cli {
            uses service-modifications-cli;
          }
        }
      }
    }
  }

  grouping service-customer-service {
    leaf-list used-by-customer-service {
      tailf:info "Customer facing services using this service";
      type leafref {
        path "/ncs:services/ncs:customer-service/ncs:object-id";
      }
      config false;
      tailf:callpoint ncs {
        tailf:internal;
      }
    }
  }

  grouping service-depth {
    choice depth {
      leaf deep {
        type empty;
      }
      leaf shallow {
        type empty;
      }
      default deep;
    }
  }

  grouping service-modifications-xml {
    container result-xml {
      container local-node {
        anyxml data;
      }
      list lsa-service {
        key service-id;
        leaf service-id {
          type instance-identifier;
        }
        anyxml data;
      }
    }
  }

  grouping service-modifications-cli {
    container cli {
      container local-node {
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
      list lsa-service {
        key service-id;
        leaf service-id {
          type instance-identifier;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping service-sync {
    container sync-result {
      container local-node {
        leaf in-sync {
          type boolean;
        }
      }
      list lsa-service {
        key service-id;
        leaf service-id {
          type instance-identifier;
        }
        leaf in-sync {
          type boolean;
        }
      }
    }
  }

  grouping choice-lsa-grouping {
    choice choice-lsa {
      leaf use-lsa {
        type empty;
        description
          "Force handling LSA nodes as such.";
      }
      leaf no-lsa {
        type empty;
        description
          "Do not handle any of the LSA nodes as such. These nodes
           will be handled as any other device.";
      }
    }
  }

  /*
   * Data tree.
   */

  container services {
    tailf:info "The services managed by NCS";

    description
      "The services managed by NCS.";


    container global-settings {

      leaf collect-forward-diff {
        tailf:info "Toggle the collection of service data";
        description
          "When creating a service instance we can choose to also
           collect the forward diff.  I.e., remember what the service
           did.  This drives the formatting of the runtime statistics
           'get-modifications' for a service.  We always collect the
           reverse for a service instance, that is the basis for the
           FASTMAP algoritm.  This consumes quite a bit of extra
           memory per service instance, so if we have huge amounts of
           services it may be worthwhile to turn this off.";
        type boolean;
        default false;
      }
    }

    tailf:action check-sync {
      tailf:info "Check if device configuration is according to the services";
      description
        "Check if any service has been undermined, i.e., if a service was
         to be re-deployed, would it do anything.";

      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          type empty;
          tailf:info "Return list only contains negatives";
          description
            "Use this additional parameter to only return services that
             failed to sync.";
        }
        uses choice-lsa-grouping;
      }
      output {
        list sync-result {
          leaf service-id {
            type string;
          }
          leaf in-sync {
            type boolean;
          }
        }
      }
    }

    tailf:action commit-dry-run {
      status deprecated;
      tailf:info "DEPRECATED - use commit dry-run instead";
      description
        "Commit without actually committing to see what modifications
         will be done towards the managed devices.  Thus if we want
         to know what effects on the network the made changes will
         have, this action can be used.

         This action is deprecated.  Use 'commit dry-run' instead.";
      tailf:cli-configure-mode;
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf outformat {
          type outformat3;
        }
        leaf reverse {
          when "../outformat = 'native'";
          type empty;
        }
        uses choice-lsa-grouping;
      }
      output {
        choice outformat {
          case case-xml {
            uses dry-run-xml;
          }
          case case-cli {
            uses dry-run-cli;
          }
          case case-native {
            uses dry-run-native;
          }
        }
      }
    }

    container properties {
      tailf:info "Properties used when creating services";
      description
        "This is a placeholder for where additional service properties
         can be augmented.";
    }

    list customer-service {
      tailf:info "Service that can be linked to customer";

      key object-id;
      reference "TMForumPhaseVIII::SID Phase VIII::Service Domain::Service
                   ABE::Customer Facing Service";

      leaf object-id {
        tailf:info "Customer facing service";
        type string;
        reference "Service ABE::objectId";
      }
      leaf reference {
        type string;
        reference "Service ABE::description";
      }
      leaf customer {
        tailf:info "The customer";
        type leafref {
          path "/ncs:customers/ncs:customer/ncs:id";
        }
        description
          "Customer for this service.";
      }
      list service {
        tailf:info "List of resource facing services";
        key service-id;
        description
          "Resource facing services for this service.";

        leaf service-id {
          tailf:info "The resource facing service";
          type instance-identifier;
          description
            "Must refer to a resource facing service instance.";
        }
      }

      container properties {
        tailf:info "Augmented properties for customer services";
        description
          "This container can be used whenever you want to extend the
           customer service properties with additional proprietary
           information.";
      }
    }

    list service {
      tailf:info "List of resource facing services";
      key object-id;

      reference "TMForumPhaseVIII::SID Phase VIII::Service
                   Domain::Service ABE::Resource Facing Service";

      leaf object-id {
        tailf:info "Unique service id";
        tailf:cli-allow-range;
        type string;
        reference "Service ABE::objectId";
      }

      leaf reference {
        type string;
        reference "Service ABE::description";
      }

      container properties {
        tailf:info "Additional service properties";
        description
          "This container can be used whenever you want to extend the
           resource service properties with additional proprietary
           information.";
      }
      container type {
        tailf:info "The service types";
        choice service-type-choice {
          description
            "This choice is augmented by service instances such
             as MPLS VPN.";
        }
      }
    }

    container logging {
      tailf:info "Configure service logging";

      leaf max-size {
        type union {
          type enumeration {
            enum unlimited;
          }
          type uint32 {
            range "1 .. max";
          }
        }
        default 50;
        description
          "Max size of the list of log entries. When the maximum size
           is reached, the oldest log entry is purged.";
      }

      list logger {
        key name;
        unique "service-type log-entry-level";
        description
          "NCS or user specific code may choose to populate a log entry
           to indicate important events associated with it.

           Each entry in this list holds one representation of a
           service logger. Log entries matching the given service type,
           log entry type and log entry level will be logged in the log
           container under the service type instance.";
        leaf name {
          type string;
          description
            "A unique identifier for this logger.";
        }
        leaf service-type {
          type tailf:node-instance-identifier;
          tailf:cli-completion-actionpoint "servicepoints";
          description
            "The type of service. If not set, all service types are
             logged.";
        }
        leaf-list log-entry-type {
          description
            "The types of log entry to be logged. If not set, all
             log entry types are logged.";
          type log-entry-t;
        }
        leaf log-entry-level {
          description
            "Log level for this log entry type. Configuring this level
             will cause log entries of that level and those that are
             more specific to be logged.";
          type log-entry-level-t;
          mandatory true;
        }
        leaf max-size {
          type union {
            type enumeration {
              enum unlimited;
            }
            type uint32 {
              range "1 .. max";
            }
          }
          description
            "Max size of the list of log entries. When the maximum size
             is reached, the oldest log entry is purged. If not set it
             defaults to /services/logging/max-size";
        }
      }
    }
  }
}
