submodule tailf-ncs-devices {
  yang-version 1.1;
  belongs-to tailf-ncs {
    prefix ncs;
  }

  import ietf-inet-types {
    prefix inet;
  }
  import ietf-yang-types {
    prefix yang;
  }
  import ietf-yang-schema-mount {
    prefix yangmnt;
  }
  import tailf-common {
    prefix tailf;
  }
  import tailf-ncs-ned {
    prefix ned;
  }

  include tailf-ncs-common;
  include tailf-ncs-cluster;
  include tailf-ncs-ssh;

  organization "Tail-f Systems";

  description
    "This submodule contains a collection of YANG definitions for
     configuring and monitoring managed devices in NCS.

     Copyright 2019 Cisco Systems, Inc.
     All rights reserved.
     Permission is hereby granted to redistribute this file without
     modification.";

  revision 2020-02-04 {
    description
      "Released as part of NCS-5.2.2.

       Added enum 'read-only' to
       /devices/device/netconf-notifications/subscription/failure-reason.

       Obsoleted enum 'not-master' in
       /devices/device/netconf-notifications/subscription/failure-reason.

       Removed default values for connect-retries settings under
       'device-profile-parameters' grouping.

       Added default value for
       /devices/global-settings/connect-retries/attempts and
       /devices/global-settings/connect-retries/timeout.";
  }

  revision 2019-10-17 {
    description
      "Released as part of NCS-5.2.1.

       Added 'ned-id' parameter to /devices/device/delete-config action.

       Added 'lsa-additional-ned-id' parameter to /devices/device/migrate
       action.";
  }

  revision 2019-06-27 {
    description
      "Released as part of NCS-5.2.

       Added container 'commit-queue/unlock' to grouping ncs-commit-params.";
  }

  revision 2019-05-16 {
    description
      "Released as part of NCS-5.1.1.

       Updated the description for the sync-from 'verbose' parameter.";
  }

  revision 2019-04-09 {
    description
      "Released as part of NCS-5.1.

       Changed grouping wait-for-lock:
        Added new top level choice wait-for-lock-choice with choices of
        no-wait-for-lock and wait-for-lock. The
        wait-for-lock choice remains the same.

       Added 'wait-for-lock' choice under
       'device-profile-parameters'
       grouping.

       Added /devices/device/device-type/snmp/ned-id.

       Made /devices/device/device-type/netconf/ned-id mandatory and
       removed the default value.

       Made the choice for /devices/device/device-type mandatory.

       Made the container for all device-types non-presence:
         /devices/device/device-type/netconf
         /devices/device/device-type/generic
         /devices/device/device-type/cli
         /devices/device/device-type/snmp

       Changed grouping remote-user-remote-auth:
         Added choice login-credentials with two cases as:
           stored: that containes ald structure.
           callback: that introduces new mechanism to define an action
             to retrieve remote authentication credentials.
         Added leaf callback-node
         Added leaf action-name

       Added groupings authgroup-callback-input-params,
                       authgroup-callback-output-params
       to enforce structure of a callback action's input and output.

       Added enum 'config-locked' to /devices/device/state/admin-state.

       Added groupings connect-grouping-extended,
                       sync-to-grouping-extended,
                       sync-from-grouping-extended,
                       disconnect-grouping-extended,
                       check-sync-grouping-extended,
                       check-yang-modules-grouping-extended,
                       fetch-ssh-host-keys-grouping-extended,
                       disconnect-grouping-specific
       to be able to device compile the tailf-ncs module.

       Changed /devices/device/address-choice case lsa-device/lsa-remote-node
       must expression to use derived-from-or-self function.

       Added leaf /devices/global-settings/commit-queue/async and
       container /devices/global-settings/commit-queue/sync.

       Added 'ned-keep-alive' settings under 'device-profile-parameters'
       grouping.

       Added /devices/commit-queue/queue-item/services.

       Changed /devices/device/address-choice case lsa-device/lsa-remote-node
       must expression to use derived-from-or-self function.

       Added list /devices/device/device-type/lsa-additional-ned-id for
       lsa devices that have service packages compiled with other ned-ids.

       Moved /devices/device-group/rpc to /devices/device-group/ned-id/rpc.

       Added action /devices/migrate and /devices/device/migrate.

       Replaced /devices/device-module with /devices/ned-ids/ned-id.

       Updated 'add-capability' with 'ned-id' parameter, and refer to
       the /devices/ned-ids/ned-id list to find modules.

       Removed /devices/commit-queue/qitem/cq-invalid.

       Added action /devices/device/load-native-config.

       Added additional 'verbose' parameter to sync-from action.

       Removed leaf /devices/device/state/last-module-id, refer to
         /devices/device/state/last-modules-state/ncsyanglib:module-set-id
         to find the same information.";
  }

  revision 2019-03-07 {
    description
      "Released as part of NCS-4.7.3.

       Added enum 'call-home' to /devices/device/state/admin-state.

       Added enum 'call-home' to
       /devices/device/netconf-notifications/subscription/failure-reason.

       Added leaf /devices/device/local-user.";
  }

  revision 2018-06-21 {
    description
      "Released as part of NCS-4.7.

       Changed type of /devices/device-group/device-name leaf-list from
       type leafref to type string.

       Added leaf 'commit-queue/error-option' to grouping ncs-commit-params.

       Added leaf /devices/global-settings/commit-queue/error-option.

       Added leaf /devices/global-settings/commit-queue/check-integrity.

       Removed /devices/global-settings/commit-queue/error-recovery.

       Added container 'commit-queue' and leaf 'no-out-of-sync-check' to
       /devices/commit-queue/completed/queue-item/rollback/input/.

       Added /devices/device/lsa-remote-node.";
  }

  revision 2018-04-19 {
    description
      "Released as part of NCS-4.6.1.

       Added force parameter to prune and delete actions under
       /devices/commit-queue and /devices/commit-queue/queue-item.

       Renamed leaf num-affected-queue-items to num-matched-queue-items
       in /devices/commit-queue/prune action.

       Removed leaf /devices/commit-queue/queue-item/kilo-bytes-size.";
  }

  revision 2018-03-01 {
    description
      "Released as part of NCS-4.6.

       Added connect-retries settings under
       'device-profile-parameters' grouping.

       Renamed leaf connection-failure-reconnect-timer to retry-timeout
       and connection-failure-reconnect-retries to retry-attempts under
       /devices/global-settings/commit-queue.

       Added additional preserve parameter to scp-from/scp-to action.

       Added use-junos-rollback parameter to ned-settings container.

       Added an enum 'same-pass' to
       /devices/device/netconf-notifications/subscription/failure-reason.

       Changed the default value for
       /devices/global-settings/ssh-keep-alive/count to 3.

       Added enum 'completed' and enum 'failed' to commit-queue/status leaf
       in ncs-commit-result grouping.

       Added list /commit-queue/failed-device in ncs-commit-result grouping.

       Added enum 'completed' and enum 'failed' to
       /devices/commit-queue/queue-item/wait-until-completed/output/result.

       Removed leaf /devices/commit-queue/completed/queue-item/succeeded
       and /devices/commit-queue/completed/purge/input/succeeded.

       Added leaf /devices/commit-queue/completed/queue-item/status
       and /devices/commit-queue/completed/purge/input/status.";
  }

  revision 2017-09-28 {
    description
      "Released as part of NCS-4.5.

       Changed /devices/device/netconf-notifications/subscription/status from
       internal callpoint to actual cdb operational data and made status default
       to 'connecting'.

       Added /devices/commit-queue/queue-item/failed.

       Removed deprecated status on
       /devices/global-settings/commit-queue/error-recovery/mode.";
  }

  revision 2017-08-31 {
    description
      "Released as part of NCS-4.4.3.

       Made /devices/device/platform operational data persistent.

       Added serial-number to /devices/device/platform container.";
  }

  revision 2017-06-14 {
    description
      "Released as part of NCS-4.4.2.

       Added action 'wait-until-completed' to
       /devices/commit-queue/queue-item.

       Added /devices/commit-queue/completed.

       Added 'wait-for-lock' container under 'check-sync' and
       'sync-from' actions.";
  }

  revision 2017-04-27 {
    description
      "Released as part of NCS-4.4.1.

       Added 'partial-sync-from' action under /devices.";
  }

  revision 2017-03-16 {
    description
      "Released as part of NCS-4.4.

       Added /devices/device-group/rpc.

       Added 'copy-capabilities', 'find-capabilities' and 'add-capability'
       actions under /devices/device. Added 'remove' action under
       /devices/device/capability.

       Added list 'capabilities-profile' under /devices/profiles.

       Added /devices/device/no-overwrite.

       Added range to all config leafs specifying time.

       Added default values to pool-max-sessions and idle-time
       under /devices/global-settings/session-pool.

       Removed identity 'netconf' and changed default ned-id for
       netconf devices from 'netconf' to 'ned:netconf'.

       Made leafs no-overwrite and no-out-of-sync-check in
       grouping ncs-commit-params cases in a choice.

       Added /devices/device/last-changed,
       /devices/commit-queue/device-chgset, and
       /devices/commit-queue/qitem/cq-invalid.

       The type of /devices/commit-queue/qitem/cq-data leaf changed from
       type string to type binary.";
  }

  revision 2016-11-24 {
    description
      "Released as part of NCS-4.3.

       Added /devices/device/active-settings.

       Removed the three different deprecated 'sync' actions
       all/group/device.

       Added additional dry-run parameter to sync-from action.
       Added additional output formats to sync-to dry-run
       parameter.

       Added actions 'scp-to' and 'scp-from' to /devices/device.

       Added ned-id to NETCONF device
       /devices/device/device-type/netconf/ned-id.

       Added use-lsa and no-lsa commit parameters.

       Added use-lsa and no-lsa settings under
       'device-profile-parameters' grouping.";
  }

  revision 2016-11-17 {
    description
      "Released as part of NCS-4.2.2.

       Added leaf connection-failure-reconnect-retries to container
       /devices/global-settings/commit-queue";
  }

  revision 2016-05-26 {
    description
      "Released as part of NCS-4.2.

       Added /devices/device/netconf-notifications/subscription/store-in-cdb.

       Renamed input parameter from supress-positive-result to
       suppress-positive-result for the following actions:

         /devices/check-sync
         /devices/device-group/check-sync
         /devices/check-yang-modules
         /devices/device-group/check-yang-modules
         /devices/connect
         /devices/device-group/connect
         /devices/sync
         /devices/device-group/sync
         /devices/sync-from
         /devices/device-group/sync-from
         /devices/sync-to
         /devices/device-group/sync-to

       Renamed leaf-list /devices/device/module/features to feature
       Renamed leaf-list /devices/device/module/deviations to deviation

       Added container 'commit-queue' to
       device-profile-parameters grouping.

       Added container 'commit-queue' to devices.";
  }

  revision 2016-01-21 {
    description
      "Released as part of NCS-4.1.1.

       Removed default for /devices/device/ssh-keep-alive/interval.
       Added default for /devices/global-settings/ssh-keep-alive/interval.

       Removed default for /devices/device/ssh-keep-alive/count.
       Added default for /devices/global-settings/ssh-keep-alive/count.";
  }

  revision 2015-11-24 {
    description
      "Released as part of NCS-4.1.

       Added 'candidate-startup' as device transaction mode.

       Added 'session-pool' configuration to
       device-profile-parameters grouping.

       Added 'session-pool' operational data container to devices.

       Moved /devices/global-settings/out-of-sync-commit-behaviour leaf
       to device-profile-parameters grouping.";
  }

  revision 2015-10-02 {
    description
      "Released as part of NCS-4.0.2.

       Added /devices/device/ssh-keep-alive/interval.

       Added /devices/device/ssh-keep-alive/count.";
  }

  revision 2015-06-16 {
    description
      "Released as part of NCS-4.0.

       Added /devices/device/platform container for vendor specific
       operational data like operating system, version etc.

       Added /devices/global-settings/atomic.

       Added action 'set-atomic-behaviour' to /devices/commit-queue.

       Added action 'set-atomic-behaviour' to
       /devices/commit-queue/queue-item.";
  }

  revision 2015-03-19 {
    description
      "Released as part of NCS-3.4.

       Changed /devices/device/netconf-notifications/subscription/local-user
         from config:false to config:true and made it mandatory.";
  }

  revision 2014-11-19 {
    description
      "Released as part of NCS-3.3.

       Changed input and output of /devices/device/apply-template and
         /devices/device-group/apply-template. New optional input
         parameters are: 'suppress-positive-result' and
         'accept-empty-capabilities'. The output is now structured
         with separate result for each affected device.

       Added grouping commit-queue-options.

       Changed the grouping ncs-commit-params.
         Added container commit-queue which uses commit-queue-options.
         'async-commit-queue' has changed to 'commit-queue/async',
         'sync-commit-queue' has changed to 'commit-queue/sync' and
         'bypass-commit-queue' has changed to 'commit-queue/bypass'.
         Added the leaf 'commit-queue/tag'. Added the container
         'commit-queue/lock'.

       Changed the grouping ncs-commit-result.
         Added the leaf 'commit-queue/tag'.

       Changed the name of
         /devices/commit-queues to /devices/commit-queue.

       Changed names of actions in /devices/commit-queue. The action
         'clear-queue' has changed to 'clear'.
         The action 'prune-queue' has changed to 'prune'. The input
         parameter has changed from 'devices' to 'device'.

         The action 'wait-queue-empty' has changed
         to 'wait-until-empty'. The default for 'wait-queue-empty' has
         changed and is now 'infinity'.

       Added action 'add-lock' to /devices/commit-queue.

       Changes in list /devices/commit-queue/queue-item/:
         Changed data type of leaf 'id' from int64 to uint64.
         Added leaf 'tag'.
         Change name of leaf-list 'done' to 'completed'
         Added list 'remote-queue-item' for remote queue items.
         Removed action 'run'.
         Added actions 'lock' and 'unlock'.
         Added action 'prune'.

       Added ncs-commit-queue-progress-event notification.";
  }

  revision 2014-06-30 {
    description
      "Released as part of NCS-3.2.

       Added grouping ncs-commit-params.

       Added use of grouping ssh-host-keys from submodule tailf-ncs-ssh,
         creating /devices/device/ssh.

       Added /devices/device/fetch-ssh-host-keys
         and /devices/device-group/fetch-ssh-host-keys actions.

       Replaced leaf public-key in grouping remote-user-remote-auth with use
         of grouping public-key-auth from submodule tailf-ncs-ssh,
         affecting /devices/authgroups/group/default-map/public-key
         and /devices/authgroups/group/umap/public-key.

       Added use of grouping ssh-host-keys from submodule tailf-ncs-ssh,
         creating /devices/device/ssh.

       Added /devices/device/disconnect.

       Changed the /device/commit-queue/wating-for to a list, in order to
         handle remote nodes.

       Added an enum 'locked' to
         /devices/device/netconf-notifications/subscription/failure-reason.

       Changed the name of
         /devices/commit-queues/queue-item/connection-failures to
         transient-errors.";
  }

  revision 2014-05-20 {
    description
      "Released as part of NCS-3.1.1.1.

       Changed the names of some /devices/commit-queues/queue-item/status
         enumeration.";
  }

  revision 2014-04-02 {
    description
      "Released as part of NCS-3.1.

       Added /devices/global-settings/commit-retries.
       Added /devices/global-settings/ned-settings.
       Added /devices/profiles.
       Added /devices/device/device-profile.
       Added /devices/device/ned-settings.";
  }

  revision 2013-11-12 {
    description
      "Released as part of NCS-3.0.

       Added grouping check-yang-modules-grouping and its use
       in devices and device-groups.

       Added grouping check-yang-modules-result and its use
       in devices and device-groups.

       Added action check-yang-modules to device.";
  }

  revision 2013-06-18 {
    description
      "Released as part of NCS-2.3.

       Added /device/device/location and
        /device/device-group/location.

       Deprecated the 3 different sync actions all/group/device and
         replaced them with two new actions sync-to and sync-from.
         The sync-to action has an additional dry-run parameter.";
  }

  revision 2013-03-12 {
    description
      "Released as part of NCS-2.2.

       Made /devices/device/device-type mandatory.
       Added /devices/commit-queues.
       Added /devices/global-settings/out-of-sync-commit-behaviour.";
  }

  revision 2012-11-13 {
    description
      "Released as part of NCS-2.1.

       Removed /devices/device/connection.";
  }

  revision 2012-08-30 {
    description
      "Released as part of NCS-2.0.

       Added /devices/device-group/member.

       Added /devices/device/live-status-protocol.
       Added /devices/device/connect-timeout.
       Added /devices/device/read-timeout.
       Added /devices/device/write-timeout.";
  }

  typedef oper-state {
    type enumeration {
      enum enabled {
        tailf:code-name 'oper_enabled';
        description
          "The device is operational.";
      }
      enum disabled {
        tailf:code-name 'oper_disabled';
        description
          "The device is not operational.";
      }
      enum unknown {
        tailf:code-name 'oper_unknown';
        description
          "The state of the device is unknown.";
      }
    }
  }

  typedef oper-state-error-tag {
    type enumeration {
      enum noconnection {
        description
          "Cannot connect to the configured ip and port.";
      }
      enum locked {
        description
          "Administratively locked.";
      }
      enum revision-error {
        description
          "The device has a newer revision of a model than NCS can handle.";
      }
      enum badconfig {
        description
          "The device is misconfigured in some way";
      }
    }
  }

  grouping oper-state {
    leaf oper-state {
      type oper-state;
      default unknown;
      config false;
      tailf:info "The actual operational state of the device.";
      tailf:cdb-oper  {
        tailf:persistent false;
      }
    }
    leaf oper-state-error-tag {
      type oper-state-error-tag;
      config false;
      tailf:info "Additional error information if the device is disabled.";
      tailf:cdb-oper {
        tailf:persistent false;
      }
    }
    leaf oper-state-hash {
      type uint32;
      config false;
      description
        "Used internally.";
      // Hidden hash to prevent multiple cdb oper writes of
      // the same thing. Optimization.
      tailf:hidden full;
      tailf:cdb-oper {
        tailf:persistent false;
      }
    }
  }

  typedef admin-state {
    type enumeration {
      enum locked {
        description
          "When a device is administratively locked, it is not possible
           to modify its configuration, and no changes are ever
           pushed to the device.";
        tailf:code-name 'adm_locked';
        tailf:info "Device is locked for config and southbound traffic";
      }
      enum unlocked {
        description
          "Device is assumed to be operational.
           All changes are attempted to be sent southbound.";
        tailf:code-name 'adm_unlocked';
        tailf:info "Device is open for config and southbound traffic";
      }
      enum southbound-locked {
        description
          "It is possible to configure the device, but
           no changes are sent to the device. Useful admin mode
           when pre provisioning devices. This is the default
           when a new device is created.";
        tailf:info "Device is locked for southbound traffic";
      }
      enum config-locked {
        description
          "It is possible to send live-status commands or RPCs
           but it is not possible to modify the configuration
           of the device.";
        tailf:info "Device is locked for config";
      }
      enum call-home {
        description
          "It is only possible to modify the configuration of the
           device when a TCP connection is initiated from the device
           (a call home).";
        tailf:info "Southbound traffic can only be initiated when the
                    device calls home";
      }
    }
  }

  typedef snmp-security-level {
    type enumeration {
      enum no-auth-no-priv { value 1; }
      enum auth-no-priv    { value 2; }
      enum auth-priv       { value 3; }
    }
    reference
      "RFC3411: An Architecture for Describing SNMP Management
                Frameworks";
  }

  typedef snmp-version {
    type enumeration {
      enum v1;
      enum v2c;
      enum v3;
    }
  }

  typedef partial-sync-from-path {
    type yang:xpath1.0;
    tailf:info "Path to pull from the network";
    description
      "Path expression used to represent a special
       data node instance identifier string.

       A partial-sync-from-path value is an unrestricted
       YANG instance-identifier expression. All the same rules as
       an instance-identifier apply except if the last component
       of the path represents a YANG list then predicates for
       this list's keys are optional. It is still mandatory to specify
       predicates for keys for the intermediate lists.

       Namespace prefixes used in this path expression must match
       prefixes specified in the corresponding YANG modules.";
  }

  grouping ncs-commit-params {
    leaf no-revision-drop {
      type empty;
      description
        "This flags means that NCS will not run its data model revision
         algorithm, which requires all participating managed devices
         to have all parts of the data models for all data contained
         in this transaction. Thus, this flag forces NCS to never
         silently drop any data set operations towards a device.";
    }
    leaf no-networking {
      type empty;
      description
        "Do not send any data to the devices. Even if the transaction
         manipulates data below /devices/device/config, nothing will
         be sent to the managed devices. This is a way to manipulate
         CDB in NCS without generating any southbound traffic.";
    }
    choice choice-sync-check {
      leaf no-overwrite {
        type empty;
        description
          "This flags means that NCS will check that the data that
           should be modified has not changed on the device compared
           to NCS's view of the data. This is a fine-granular sync check;
           NCS verifies that NCS and the device is in sync regarding
           the data that will be modified. If they are not in sync,
           the transaction is aborted.";
      }
      leaf no-out-of-sync-check {
        type empty;
        description
          "Continue with the transaction even if NCS detects that a device's
           configuration is out of sync. The device's sync state is assumed
           to be unknown after such commit and the stored transaction id
           value is cleared";
      }
    }
    container commit-queue {
      presence "Commit through the commit queue";
      leaf tag {
        type string;
        description
          "User defined opaque tag.
           The tag is present in all notifications and events
           sent referencing the specific queue item.";
      }
      uses commit-queue-options;
      leaf error-option {
        type enumeration {
          enum continue-on-error {
            description
              "The commit queue will continue on errors. No rollback data
               will be created. This is the preferred choice when
               re-deploying a service as a re-deploy doesn't have a
               transaction intent.";
          }
          enum rollback-on-error {
            description
              "The commit queue item will roll back on errors. The commit
               queue will place a lock with 'block-others' on the devices and
               services in the failed queue item. The rollback action will then
               automatically be invoked when the queue item has finished
               its execution. The lock is removed as part of the rollback.";
          }
          enum stop-on-error {
            description
              "The commit queue will place a lock with 'block-others'
               on the devices and services in the failed queue item. The
               lock must then either manually be released when the error
               is fixed or the rollback action under
               /devices/commit-queue/completed be invoked.";
          }
        }
        description
          "The error option to use. Depending on the selected error option
           NCS will store the reverse of the original transaction intent
           to be able to undo the transaction changes and get back to the
           previous state. This data is stored in the
           /devices/commit-queue/completed tree from where it can
           be viewed and invoked with the rollback action. When invoked
           the data will be removed.";
      }
      container unlock {
        presence "Unlock queue item";
        choice choice-unlock-id {
          leaf id {
            type uint64;
            description
              "Unique id identifying a queue item. If locked, this
               item will be unlocked in the commit phase.";
          }
          leaf tag {
            type string;
            description
              "User defined opaque tag. If locked, this
               item will be unlocked in the commit phase.";
          }
        }
      }
    }
    choice choice-lsa {
      leaf use-lsa {
        type empty;
        description
          "Force handling of the LSA nodes as such. This flag tells
           NCS to propagate applicable commit flags and actions
           to the LSA nodes without applying them on the upper
           NCS node itself. The commit flags affected are
           'dry-run', 'no-networking', 'no-out-of-sync-check',
           'no-overwrite' and 'no-revision-drop'.";
      }
      leaf no-lsa {
        type empty;
        description
          "Do not handle any of the LSA nodes as such. These nodes
           will be handled as any other device.";
      }
    }
    leaf-list wait-device {
      type leafref {
        path "/ncs:devices/ncs:device/ncs:name";
      }
      description
        "Take device locks before entering transaction critical section. The
         device locks here should be understood to be internal locks in NSO, so
         the device itself is not locked. If the device locks are held by
         someone else, wait for them to become available. The timeout applied
         in this case is the same as used to wait for the transaction lock.

         Normally the device locks are taken automatically inside the
         transaction critical section, because in a typical service transaction
         we do not know the affected devices before the service code is
         executed. When taking the device locks inside transaction critical
         section, it is not possible to wait for lock, so in case the lock is
         not available the transaction is aborted.

         This parameter allows to specify the devices expected to be
         affected by the transaction so they can be pre-locked before entering
         the transaction critical section. This allows to wait for device
         locks. This is useful in cases when other actions holding the device
         lock may be on-going at the same time and the desired behaviour is
         to wait for these actions to complete rather than abort the
         transaction. Examples of such actions are: sync-from,
         partial-sync-from, check-sync, sync-to, compare-config.

         Similarly, when used with a commit through commit queue, this
         parameter allows to wait for queue items with block-others flag. For
         example, a queue item with block-others flag is created by actions
         such as sync-from and partial-sync-from, and when a commit queue item
         fails with error-option being rollback-on-error or stop-on-error.

         If the transaction involves other devices than specified by this
         parameter, then the lock still needs to be taken on these additional
         devices, which is done inside transaction critical section and may
         fail if the device lock for the additional devices is already held
         by someone else.";
    }
  }

  grouping ncs-commit-result {
    container commit-queue {
      leaf id {
        type leafref {
          path "/ncs:devices/ncs:commit-queue/ncs:queue-item/ncs:id";
        }
        description
          "This leaf is returned if 'commit-queue/async' or
           'commit-queue/sync' was given in the input parameters.";
      }
      leaf status {
        type enumeration {
          enum async {
            description
              "The queue item was successfully created.";
            tailf:code-name "commit_cq_async";
          }
          enum completed {
            description
              "The queue item was successfully completed.";
            tailf:code-name "commit_cq_completed";
          }
          enum timeout {
            description
              "The timer expired before the queue item was completed.";
            tailf:code-name "commit_cq_timeout";
          }
          enum deleted {
            description
              "The queue item was deleted from the queue.";
            tailf:code-name "commit_cq_deleted";
          }
          enum failed {
            description
              "The queue item failed.";
            tailf:code-name "commit_cq_failed";
          }
        }
      }
      list failed-device {
        key "name";
        leaf name {
          type leafref {
            path "/ncs:devices/ncs:device/ncs:name";
          }
        }
        leaf reason {
          type string;
          description
            "The error for this failing device.";
        }
        description
          "The devices which failed for this queue item.";
      }
    }
  }

  grouping dry-run-xml {
    container result-xml {
      description
        "Display all changes in the whole data model. The
         changes will be displayed in NETCONF XML edit-config format,
         i.e., the edit-config that would be applied locally (at NCS)
         to get a config that is equal to that of the managed device.";
      container local-node {
        anyxml data;
      }
      list lsa-node {
        leaf name {
          type string;
        }
        anyxml data;
      }
    }
  }

  grouping dry-run-cli {
    container cli {
      description
        "Display all changes in the whole data model. The
         changes will be displayed in CLI curly bracket format.";
      container local-node {
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
      list lsa-node {
        leaf name {
          type string;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping dry-run-native {
    container native {
      description
        "Display only changes under /devices/device/config. The
         changes will be displayed in native device format.";
      list device {
        key name;
        leaf name {
          type string;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping commit-queue-item-status {
    leaf status {
      type enumeration {
        enum completed {
          description
            "The queue item was successfully completed.";
          tailf:code-name "cq_item_completed";
        }
        enum deleted {
          description
            "The queue item was deleted from the queue.";
          tailf:code-name "cq_item_deleted";
        }
        enum failed {
          description
            "The queue item failed.";
          tailf:code-name "cq_item_failed";
        }
      }
    }
  }

  grouping connect-grouping {
    tailf:action connect {
      description
        "Set up sessions to all unlocked devices.";
      tailf:info "Set up sessions to all unlocked devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to connect.";
        }
        leaf override-southbound-locked {
          type empty;
          description
            "When a device is southbound locked, all southbound communication
             is turned off. This flag overrides this for connection
             attempts. Thus, this is a way to update the capabilities
             including revision information for a managed device although
             the device is southbound locked";
        }
      }
      output {
        list connect-result {
          key device;
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
          }
          uses connect-result;
        }
      }
    }
  }

  grouping connect-grouping-extended {
    tailf:action connect {
      description
        "Set up sessions to all unlocked devices.";
      tailf:info "Set up sessions to all unlocked devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to connect.";
        }
        leaf override-southbound-locked {
          type empty;
          description
            "When a device is southbound locked, all southbound communication
             is turned off. This flag overrides this for connection
             attempts. Thus, this is a way to update the capabilities
             including revision information for a managed device although
             the device is southbound locked";
        }
        leaf-list device {
          tailf:info "Only connect to these devices.";
          type leafref {
            path "/devices/device/name";
          }
        }
      }
      output {
        list connect-result {
          key device;
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
          }
          uses connect-result;
        }
      }
    }
  }

  grouping connect-result {
    description
      "Common result data from a 'connect' action.";

    leaf result {
      type boolean;
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping check-sync-grouping {
    tailf:action check-sync {
      description
        "Check if the NCS copy of the device configurations is in sync
         with the actual device configurations, using device-specific
         mechanisms. This operation is usually cheap as it only
         compares a signature of the configuration from the
         device rather than comparing the entire configuration.

         Depending on the device the signature is implemented as a
         transaction-id, timestamp, hash-sum or not at all.
         The capability must be supported by the corresponding
         NED. The output might say unsupported, and then the only way
         to perform this would be to do a full 'compare-config' command.

         As some NEDs implements the signature as an hash-sum
         of the entire configuration, this operation might for
         some devices be just as expensive as performing a full
         compare-config command.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info "Check if the NCS config is in sync with the device";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices not in sync.";
        }
        uses wait-for-lock;
      }
      output {
        list sync-result {
          key device;
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
          }
          uses check-sync-result;
        }
      }
    }
  }

  grouping check-sync-grouping-extended {
    tailf:action check-sync {
      description
        "Check if the NCS copy of the device configurations is in sync
         with the actual device configurations, using device-specific
         mechanisms. This operation is usually cheap as it only
         compares a signature of the configuration from the
         device rather than comparing the entire configuration.

         Depending on the device the signature is implemented as a
         transaction-id, timestamp, hash-sum or not at all.
         The capability must be supported by the corresponding
         NED. The output might say unsupported, and then the only way
         to perform this would be to do a full 'compare-config' command.

         As some NEDs implements the signature as an hash-sum
         of the entire configuration, this operation might for
         some devices be just as expensive as performing a full
         compare-config command.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info "Check if the NCS config is in sync with the device";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices not in sync.";
        }
        uses wait-for-lock;
        leaf-list device {
          tailf:info "Only check-sync these devices.";
          type leafref {
            path "/devices/device/name";
          }
        }
      }
      output {
        list sync-result {
          key device;
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
          }
          uses check-sync-result;
        }
      }
    }
  }

  grouping check-sync-result {
    description
      "Common result data from a 'check-sync' action.";

    leaf result {
      type enumeration {
        enum unknown {
          description
            "NCS has no record, probably because no
             sync actions has been executed towards the device
             or it was cleared after a no-out-of-sync-check commit.
             This is also the initial state for a device.";
        }
        enum locked {
          tailf:code-name 'sync_locked';
          description
            "The device is administratively locked, meaning that NCS
             cannot talk to it.";
        }
        enum in-sync {
          tailf:code-name 'in-sync-result';
          description
            "The configuration on the device is in sync with NCS.";
        }
        enum out-of-sync {
          description
            "The device configuration is known to be out of sync, i.e.,
             it has been reconfigured out of band.";
        }
        enum unsupported {
          description
            "The device doesn't have any mechanism to do a cheap
             check-sync, or this mechanism has been disabled.";
        }
        enum error {
          description
            "An error occurred when NCS tried to check the sync status.
             The leaf 'info' contains additional information.";
        }
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping sync-to-grouping {
    tailf:action sync-to {
      description
        "Synchronize the configuration by pushing to all unlocked devices.

         By default, NCS pushes a minimal diff to the devices.  The
         diff is calculated by reading the configuration from the
         devices and comparing with the configuration in NCS.

         For NETCONF devices, NCS can optionally replace the
         configuration on the devices by sending its own configuration
         without calculating the diff.  Note that NCS will send an
         <edit-config> with the 'replace' option in this case.  This
         means that configuration subtrees that NCS does not know
         about are not replaced.

         If the dry-run option is used, NCS will just report what it
         will do do instead of doing it.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info "Synchronize the config by pushing to the devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        leaf mode {
          type enumeration {
            enum replace;
          }
          description
            "For NETCONF devices, replace the device configurations
             with the NCS configurations, instead of sending the diff.

             Cannot be used with non-NETCONF devices.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type outformat3;
              description
                "Report what would be done towards the device, without
                 actually doing anything.";
          }
        }
        uses wait-for-lock;
      }
      output {
        list sync-result {
          key device;
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
          }
          uses sync-to-result;
        }
      }
    }
  }

  grouping sync-to-grouping-extended {
    tailf:action sync-to {
      description
        "Synchronize the configuration by pushing to all unlocked devices.

         By default, NCS pushes a minimal diff to the devices.  The
         diff is calculated by reading the configuration from the
         devices and comparing with the configuration in NCS.

         For NETCONF devices, NCS can optionally replace the
         configuration on the devices by sending its own configuration
         without calculating the diff.  Note that NCS will send an
         <edit-config> with the 'replace' option in this case.  This
         means that configuration subtrees that NCS does not know
         about are not replaced.

         If the dry-run option is used, NCS will just report what it
         will do do instead of doing it.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info "Synchronize the config by pushing to the devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        leaf mode {
          type enumeration {
            enum replace;
          }
          description
            "For NETCONF devices, replace the device configurations
             with the NCS configurations, instead of sending the diff.

             Cannot be used with non-NETCONF devices.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type outformat3;
              description
                "Report what would be done towards the device, without
                 actually doing anything.";
          }
        }
        uses wait-for-lock;
        leaf-list device {
          tailf:info "Only sync to these devices.";
          type leafref {
            path "/devices/device/name";
          }
        }
      }
      output {
        list sync-result {
          key device;
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
          }
          uses sync-to-result;
        }
      }
    }
  }

  grouping sync-to-result {
    description
      "Common result data from a 'sync-to' action.";

    choice outformat {
      leaf result {
        type boolean;
      }
      anyxml result-xml;
      leaf cli {
        tailf:cli-preformatted;
        type string;
      }
      leaf native {
        tailf:cli-preformatted;
        type string;
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping sync-from-grouping {
    tailf:action sync-from {
      description
        "Synchronize the configuration by pulling from all unlocked
         devices.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info "Synchronize the config by pulling from the devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type outformat2;
            description
              "Report what would be done towards CDB, without
               actually doing anything.";
          }
        }
        leaf verbose {
          type empty;
          description
            "Use this to show additional parse information if supported
             by the NED.";
        }
        uses wait-for-lock;
      }
      output {
        uses sync-from-output;
      }
    }
  }

  grouping sync-from-grouping-extended {
    tailf:action sync-from {
      description
        "Synchronize the configuration by pulling from all unlocked
         devices.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info "Synchronize the config by pulling from the devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type outformat2;
            description
              "Report what would be done towards CDB, without
               actually doing anything.";
          }
        }
        leaf verbose {
          type empty;
          description
            "Use this to show additional parse information if supported
             by the NED.";
        }
        uses wait-for-lock;
        leaf-list device {
          tailf:info "Only sync from these devices.";
          type leafref {
            path "/devices/device/name";
          }
        }
      }
      output {
        uses sync-from-output;
      }
    }
  }

  grouping sync-from-output {
    list sync-result {
      key device;
      leaf device {
        type leafref {
          path "/devices/device/name";
        }
      }
      uses sync-result;
    }
  }

  grouping sync-result {
    description
      "Common result data from a 'sync' action.";

    choice outformat {
      leaf result {
        type boolean;
      }
      anyxml result-xml;
      leaf cli {
        tailf:cli-preformatted;
        type string;
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping wait-for-lock {
    choice wait-for-lock-choice {
      description "Wait for device lock setting.";
      leaf no-wait-for-lock {
        type empty;
        description
          "The action can't be performed while the device is being
           committed to (or waiting in the commit queue). This is to avoid
           getting inconsistent data when reading the configuration.
           This specifies that the action should not wait for device lock,
           instead, it should immediately fail if the device is being locked.";
      }
      container wait-for-lock {
        presence "Wait for device lock.";
        description
          "The action can't be performed while the device is being
           committed to (or waiting in the commit queue). This is to avoid
           getting inconsistent data when reading the configuration.
           This specifies a timeout to wait for a device lock to be placed
           in the commit queue. The lock will be automatically released once
           the action has been executed.";
        choice timeout-choice {
          default "infinity";
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Specifies a maximum number of seconds to wait for the
              device to be locked.";
          }
          leaf infinity {
            description
              "Wait infinitely for the lock, this is the default.";
            type empty;
          }
        }
      }
    }
  }

  grouping disconnect-grouping {
    tailf:action disconnect {
      description
        "Close all sessions to all devices.";
      tailf:info "Close all sessions to all devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input;
    }
  }

  grouping disconnect-grouping-specific {
    tailf:action disconnect {
      description
        "Close all sessions to the device.";
      tailf:info "Close all sessions to the device";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input;
    }
  }

  grouping disconnect-grouping-extended {
    tailf:action disconnect {
      description
        "Close all sessions to all devices.";
      tailf:info "Close all sessions to all devices";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf no-remote {
          tailf:display-when "/cluster/remote-node/name";
          type empty;
          description "Do not perform this action on remote cluster node";
          tailf:info "Do not perform this action on remote cluster node";
        }
      }
    }
  }

  grouping check-yang-modules-grouping {
    tailf:action check-yang-modules {
      description
        "Check if the device YANG modules loaded by NCS
         have revisions that are compatible with the ones reported
         by the devices.";
      tailf:info "Check if NCS and the devices have compatible YANG modules";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf verbose {
          type empty;
          description
            "Use this to show additional compatibility info.";
        }
        leaf suppress-positive-result {
          type empty;
          description
            "Use this to only return devices that have incompatible
             modules.";
        }
      }
      output {
        list device {
          key name;
          leaf name {
            type leafref {
              path "/devices/device/name";
            }
            description
              "Device for which a revision compatibility
               check has been performed.";
          }
          uses check-yang-modules-result;
        }
      }
    }
  }

  grouping check-yang-modules-grouping-extended {
    tailf:action check-yang-modules {
      description
        "Check if the device YANG modules loaded by NCS
         have revisions that are compatible with the ones reported
         by the devices.";
      tailf:info "Check if NCS and the devices have compatible YANG modules";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf verbose {
          type empty;
          description
            "Use this to show additional compatibility info.";
        }
        leaf suppress-positive-result {
          type empty;
          description
            "Use this to only return devices that have incompatible
             modules.";
        }
        leaf-list device {
          tailf:info "Specification of devices for which a module revision
                      compatibility check should be performed.";
          type leafref {
            path "/devices/device/name";
          }
        }
      }
      output {
        list device {
          key name;
          leaf name {
            type leafref {
              path "/devices/device/name";
            }
            description
              "Device for which a revision compatibility
               check has been performed.";
          }
          uses check-yang-modules-result;
        }
      }
    }
  }

  grouping check-yang-modules-result {
    description
      "Common result data from a 'check-yang-modules' action.";

    choice compat-res {
      case silent {
        description
          "Present in non-verbose mode.";
        leaf compatible {
          type boolean;
          description
            "Reporting if a device is revision compatible true/false
             in non-verbose mode.";
        }
      }
      case verbose {
        list module {
          description
            "In verbose mode, this is the list of the supported modules for
             a device which are reported as capabilities.";
          key name;
          leaf name {
            type string;
            description "YANG module";
          }
          leaf status {
            description
              "Compatibility status for the YANG module.";
            type enumeration {
              enum supported {
                tailf:code-name module-supported;
                description
                  "Implies that NCS has loaded the yang module with
                   the same revision or a revision of newer date.";
              }
              enum unsupported {
                tailf:code-name module-unsupported;
                description
                  "Implies that NCS has loaded the yang module but the
                   revision is to old.";
              }
              enum not-loaded  {
                tailf:code-name module-not-loaded;
                description
                  "Implies that NCS has not loaded the yang module.";
              }
              enum unknown  {
                tailf:code-name module-unknown;
                description
                  "that NCS has loaded the module but the revision
                   information was not available for comparison.";
              }
            }
          }
          leaf device-revision {
            type string;
            description "Live device reported revision for the module";
          }
          leaf ncs-revision {
            type string;
            description "NCS loaded YANG module revision";
          }
        }
      }
    }
  }

  grouping fetch-ssh-host-keys-grouping {
    tailf:action fetch-ssh-host-keys {
      tailf:info "Retrieve SSH host keys from all devices";
      description
        "Retrieve the SSH host keys from all devices, or all devices in the
         given device group, and store them in each device's ssh/host-key
         list. Successfully retrieved new or updated keys are always
         committed by the action.";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          tailf:info "Only return result if key retrieval failed";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where key retrieval failed.";
        }
        leaf suppress-unchanged-result {
          tailf:info "Do not return result if keys are unchanged";
          type empty;
          description
            "If this optional parameter is included, no results are returned
             for devices which have the same keys as those already known.";
        }
        leaf suppress-fingerprints {
          tailf:info "Do not return key fingerprints";
          type empty;
          description
            "If this optional parameter is included, key fingerprints are
             not included in the results.";
        }
      }
      output {
        list fetch-result {
          description
            "This is a list of key retrieval results, each entry pertains
             to one device.";
          key device;
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
            description
              "The name of the device.";
          }
          uses fetch-ssh-host-keys-result;
        }
      }
    }
  }

  grouping fetch-ssh-host-keys-grouping-extended {
    tailf:action fetch-ssh-host-keys {
      tailf:info "Retrieve SSH host keys from all devices";
      description
        "Retrieve the SSH host keys from all devices, or all devices in the
         given device group, and store them in each device's ssh/host-key
         list. Successfully retrieved new or updated keys are always
         committed by the action.";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf suppress-positive-result {
          tailf:info "Only return result if key retrieval failed";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where key retrieval failed.";
        }
        leaf suppress-unchanged-result {
          tailf:info "Do not return result if keys are unchanged";
          type empty;
          description
            "If this optional parameter is included, no results are returned
             for devices which have the same keys as those already known.";
        }
        leaf suppress-fingerprints {
          tailf:info "Do not return key fingerprints";
          type empty;
          description
            "If this optional parameter is included, key fingerprints are
             not included in the results.";
        }
        leaf-list device {
          tailf:info "Only fetch host keys from these devices.";
          type leafref {
            path "/devices/device/name";
          }
        }
      }
      output {
        list fetch-result {
          description
            "This is a list of key retrieval results, each entry pertains
             to one device.";
          key device;
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
            description
              "The name of the device.";
          }
          uses fetch-ssh-host-keys-result;
        }
      }
    }
  }

  grouping apply-template-grouping {
    tailf:action apply-template {
      description
        "Apply a template configuration. That is, take the named
         template and copy it here.

         This grouping is used inside managed devices, and in
         device groups.";
      tailf:info "Take a named template and copy it here";
      tailf:cli-configure-mode;
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf template-name {
          type leafref {
            path "/devices/template/name";
          }
          mandatory "true";
        }
        list variable {
          key name;
          leaf name {
            tailf:cli-completion-actionpoint "template-variable";
            type string {
              tailf:info
                "The name of the XPath variable as used in the template";
            }
            mandatory "true";
          }
          leaf value {
            type union {
              type string {
                tailf:info
                  "quoted;;some text enclosed in single quotes. This
                   is an XPath string.";
              }
              type string {
                tailf:info
                  "number;;some integer or float number. This is an XPath
                   number.";
              }
              type yang:xpath1.0 {
                tailf:info
                  "node set;;an XPath expression resulting in a node set";
              }
            }
            mandatory "true";
          }
        }
        leaf suppress-positive-result {
          tailf:info "Only return result if some error occurred";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where some error occurred.";
        }
        leaf accept-empty-capabilities {
          tailf:info "Apply template to devices with no capabilities known ";
          type empty;
          description
            "If this optional parameter is included, the template is applied to
             devices even if the capability of the device is unknown.";
        }
      }
      output {
        list apply-template-result {
          key device;
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
          }
          leaf result {
            type enumeration {
              enum ok {
                tailf:code-name 'apply_template_ok';
                description
                  "The template was applied with success";
              }
              enum no-capabilities {
                tailf:code-name 'apply_template_no_capabilities';
                description
                  "One or more of the affected devices has no known
                   capabilities. This occures when NCS has not synced
                   from the device";
              }
              enum no-namespace {
                tailf:code-name 'apply_template_no_namespace';
                description
                  "One or more of the affected devices has no matching
                   namespace in the template.";
              }
            }
          }
          leaf info {
            type string;
            description
              "If present, contains additional information about the result.";
          }
        }
      }
    }
  }

  grouping migrate-grouping {
    tailf:action migrate {
      description
        "Change the NED identity and migrate all data. As a side-effect reads
         and commits the actual device configuration.

         The action reports what paths have been modified and the services
         affected by those changes.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info "Migrate the devices to a new NED type";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf new-ned-id {
          tailf:info "The new NED Identity";
          type identityref {
            base ned:ned-id;
          }
          mandatory true;
        }
        leaf dry-run {
          type empty;
        }
        leaf no-networking {
          type empty;
          description
            "Do not generate any southbound traffic towards the
             devices. Use the device configuration in CDB.";
         }
        leaf verbose {
          tailf:info "Report all service instances";
          description
            "Report all service instances instead of just the
             service points.";
          type empty;
        }
        uses wait-for-lock;
      }
      output {
        list migrate-result {
          key device;
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
          }
          leaf result {
            type boolean;
          }
          leaf info {
            type string;
            description
              "If present, contains additional information about the result.";
          }
          uses migrate-result;
        }
      }
    }
  }

  grouping migrate-grouping-extended {
    tailf:action migrate {
      description
        "Change the NED identity and migrate all data. As a side-effect reads
         and commits the actual device configuration.

         The action reports what paths have been modified and the services
         affected by those changes.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";

      tailf:info "Migrate the matching devices to a new NED type";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf new-ned-id {
          tailf:info "The new NED identity";
          type identityref {
            base ned:ned-id;
          }
          mandatory true;
        }
        leaf old-ned-id {
          tailf:info "Only migrate devices with this NED identity";
          description
            "Only migrate devices with this NED identity. If neither
             this leaf or the device leaf-list is present, all devices
             will be migrated.";
          type identityref {
            base ned:ned-id;
          }
        }
        leaf-list device {
          tailf:info "Only migrate these devices.";
          description
            "Only migrate these devices. If neither this leaf-list
             or the old-ned-id leaf is present, all devices will be
             migrated.";
          type leafref {
            path "/devices/device/name";
          }
        }
        leaf dry-run {
          type empty;
        }
        leaf no-networking {
          type empty;
          description
            "Do not generate any southbound traffic towards the
             devices. Use the device configuration in CDB.";
        }
        leaf verbose {
          tailf:info "Report all service instances";
          description
            "Report all service instances instead of just the
             service points.";
          type empty;
        }
        uses wait-for-lock;
      }
      output {
        list migrate-result {
          key device;
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
          }
          leaf result {
            type boolean;
          }
          leaf info {
            type string;
            description
              "If present, contains additional information about the result.";
          }
          uses migrate-result;
        }
      }
    }
  }

  grouping migrate-result {
    list modified-path {
      leaf path {
        description
          "The path that has been modified.";
        type yang:xpath1.0;
      }
      leaf info {
        description
          "Description of what has changed on the path.";
        type string;
      }
    }
    leaf-list affected-services-with-changes {
      description
        "The service instances/points that are affected by the data
         model changes on the migrated device.";
      type string;
    }
    leaf-list affected-services {
      description
        "The service instances/points that touches the migrated device.";
      type string;
    }
  }

  grouping location {
    container location {
      description "Physical location of devices in the group";
      leaf name {
        type string;
        description
          "An arbitrary name of the location.";
      }
      leaf latitude {
        type decimal64 {
          range "-90..90";
          fraction-digits 6;
        }
        units "decimal degrees";
        description
          "The latitude according to WGS-84, in decimal degrees.";
      }
      leaf longitude {
        type decimal64 {
          range "-180..180";
          fraction-digits 6;
        }
        units "decimal degrees";
        description
          "The longitude according to WGS-84, in decimal degrees.";
      }
      leaf altitude {
        type int32;
        units "meters";
        description
          "The altitude according to WGS-84, in meters.";
      }
    }
  }

  grouping queue-item-status {
    leaf status {
      tailf:display-groups "none details summary";
      type enumeration {
        enum waiting {
          description
            "The queue item is waiting to run.  This state means
             that there is some other item in the queue, ahead of this item.";
        }
        enum executing {
          description
            "The queue item is currently executing.

             Transient errors might be present. These errors occur when NCS
             fails to communicate with some of the devices. The errors are
             shown in the 'transient-errors' leaf-list.

             Retries will take place at intervals a specified in
             /devices/global-settings/commit-queue/
               connection-failure-reconnect-timer.

             Examples of transient errors are connection failures
             and that the changes are rejected due to the device
             being locked.

             Transient errors are potentially bad, since the queue might
             grow if new items are added, waiting for the same device.";
        }
        enum locked {
          description
            "This queue item is locked and will not be processed until it has
             been unlocked, see the action
             '/devices/commit-queue/queue-item/unlock'.

             A locked queue-item will block all subsequent queue-items
             which are using any device in the locked queue item.";
          tailf:code-name qi_locked;
        }
        enum blocked {
          description
            "The queue item is waiting in the queue, and some other
             queue item ahead of this item is in state 'locked' or 'executing'
             with transient errors.";
        }
        enum waiting-not-master {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
        enum locked-not-master {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
        enum blocked-not-master {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
      }
      description
        "What is NCS currently doing with this queue item.
         If the status is idle, it means that the item is waiting
         for another queue item where one of the devices is
         not running, i.e., it's not possible to connect to that
         device.";
    }
  }

  grouping commit-queue-basic-options {
    choice operation-mode {
      leaf async {
        type empty;
        description
          "Commit the transaction data asynchronously to the commit queue.
           This flag is useful when some device is non-operational or
           has data waiting in the commit queue.

           The operation returns successfully if the transaction data has
           been successfully placed in the queue. The leaf
           'commit-queue/id' is set as the queue identifier and the
           leaf 'commit-queue/status' is set to 'async' in the result.";
      }
      container sync {
        presence "Commit through the commit queue and wait for completion";
        description
          "Commit the transaction data synchronously to the commit queue.

           The operation does not return until the transaction data has
           been sent to all devices, or a timeout occurs. The leaf
           'commit-queue/id' is set as the queue identifier and the
           leaf 'commit-queue/status' is set to 'completed', 'failed',
           'deleted' or 'timeout' dependent of the outcome.

           If no device is involved in the transaction, the operation
           returns directly.";
        choice timeout-choice {
          default "infinity";
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Specifies a maximum number of seconds to wait for the
               transaction to be committed. If the timer expires, the
               transaction is kept in the commit-queue, and the operation
               returns successfully. The leaf 'commit-queue/status'
               is set to 'timeout', and the leaf 'commit-queue/id' is
               set to the queue identifier in the result.

               If the timeout is not set, the operation waits until the
               transaction is committed.";
          }
          leaf infinity {
            description
              "Wait infinitely for the transaction to be committed.
               This is the default";
            type empty;
          }
        }
      }
      default async;
    }
  }

  grouping commit-queue-options {
    uses commit-queue-basic-options {
      augment operation-mode {
        leaf bypass {
          type empty;
          description
            "This flag means that if
             /devices/commit-queue/enabled-by-default is 'true' the
             data in this transaction will bypass the commit queue.
             The data will be written directly to the devices.";
        }
      }
    }
    leaf block-others {
      type empty;
      description
        "The resulting queue item will block subsequent queue items,
         which use any of the devices in this queue item, from
         being queued.";
    }
    leaf lock {
      type empty;
      description
        "Place a lock on the resulting queue item. The queue
         item will not be processed until it has been unlocked,
         see the actions 'unlock' and 'lock' in
         /devices/commit-queue/queue-item'.

         No following queue items, using the same devices, will be
         allowed to execute as long as the lock is in place.";
    }
    leaf atomic {
      type boolean;
      description
        "Sets the atomic behaviour of the resulting queue item.
         If this is set to false, the devices contained in the
         resulting queue item can start executing if the same devices
         in other non-atomic queue items ahead of it in the queue are
         completed. If set to true, the atomic integrity of the
         queue item is preserved.";
    }
  }

  grouping authgroup-callback-input-params {
    description
      "When /devices/authgroups/group/[name]/umap/[local-user]/callback-node
       and /devices/authgroups/group/[name]/umap/[local-user]/action-name
       is set, the action that is defined by action-name in the specified
       callback-node must use this grouping as input parameters.";
    leaf local-user {
      type string;
    }
    leaf authgroup {
      type string;
    }
    leaf device {
      type string;
    }
  }

  grouping authgroup-callback-output-params {
    description
      "When /devices/authgroups/group/[name]/umap/[local-user]/callback-node
       and /devices/authgroups/group/[name]/umap/[local-user]/action-name
       is set, the action that is defined by action-name in the specified
       callback-node must use this grouping as output parameters.";
    leaf remote-user {
      type string;
    }
    leaf remote-password {
      type string;
    }
    leaf remote-secondary-password {
      type string;
    }
  }

  container devices {
    tailf:info "The managed devices and device communication settings";

    uses connect-grouping-extended;
    uses sync-to-grouping-extended;
    uses sync-from-grouping-extended;
    uses disconnect-grouping-extended;
    uses check-sync-grouping-extended;
    uses check-yang-modules-grouping-extended;
    uses fetch-ssh-host-keys-grouping-extended;
    uses migrate-grouping-extended;

    tailf:action clear-trace {
      description
        "Clear all trace files for all active traces for all managed
         devices.";
      tailf:info "Clear all trace files";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf no-remote {
          tailf:display-when "/cluster/remote-node/name";
          type empty;
          description "Do not perform this action on remote cluster node";
          tailf:info "Do not perform this action on remote cluster node";
        }
      }
    }

    tailf:action partial-sync-from {
      description
        "Synchronize parts of the devices' configuration by pulling from
         the network.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";

      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf-list path {
          type partial-sync-from-path;
          description
            "A list of paths to fetch. Any path pointing to a subtree outside
             /devices/device/config will be ignored.";
        }
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        uses wait-for-lock;
      }
      output {
        uses sync-from-output;
      }
    }

    grouping timeouts {
      description
        "Timeouts used when communicating with a managed device.";

      leaf connect-timeout {
        tailf:info "Timeout in seconds for new connections";
        type uint32 {
          range "1..4294967";
        }
        units "seconds";
        description
          "The timeout in seconds for new connections to managed
           devices.";
      }
      leaf read-timeout {
        tailf:info "Timeout in seconds used when reading data";
        type uint32 {
          range "1..4294967";
        }
        units "seconds";
        description
          "The timeout in seconds used when reading data from a
           managed device.";
      }
      leaf write-timeout {
        tailf:info "Timeout in seconds used when writing data";
        type uint32 {
          range "1..4294967";
        }
        units "seconds";
        description
          "The timeout in seconds used when writing data to a
           managed device.";
      }
    }

    grouping device-profile-parameters {
      description
        "A set of parameters to use when communicating with a device.

         These parameters can be set on:

           o  global-settings
           o  device-profile
           o  device

         If a parameter is set on the device, its value is used.
         Otherwise, if the paramater is set in the device's
         device-profile, its value is used.  Otherwise, the global
         setting is used, if set.  Otherwise, the value used depends on
         the NED type.";

      uses timeouts;

      uses wait-for-lock{
          refine wait-for-lock-choice{
            description
              "When an action accepting the wait-for-lock parameter is
               called without providing the wait-for-lock parameter, the
               wait-for-lock-choice device setting is going to be used.";
          }
      }

      container ssh-keep-alive {
        description
          "Controls SSH keep alive settings when communicating from this
           node to devices.";
        tailf:info "Controls SSH keep alive settings";
        leaf interval {
          type uint32 {
            range "0..4294967";
          }
          units "seconds";
          description
            "Seconds between SSH keep alive activity.";
        }
        leaf count {
          type uint8;
          description
            "Number of intervals to fail before failing the connection.";
        }
      }

      container ned-keep-alive {
        description
          "Controls NED keep alive settings when communicating from this
           node to devices. The keep alive settings can be configured for
           NSO to periodically perform activity to keep the session open.
           This is useful when for example CLI sessions have low idle timeouts.
           These settings only take effect if the NED actually implements
           this callback.";
        tailf:info "Controls NED keep alive settings";
        leaf interval {
          type uint32 {
            range "0..4294967";
          }
          units "seconds";
          description
            "Seconds between NED keep alive activity.";
        }
        leaf count {
          type uint8;
          description
            "Number of intervals to fail before failing the connection.";
        }
      }

      container connect-retries {
        tailf:info "Retry connect on transient errors";
        description
          "Settings for how to retry connecting if the device returns
           a transient failure.";
        leaf attempts {
          type uint8;
          tailf:info "Number of retries before giving up";
          description
            "Number of attempts to retry the connect before giving up.

             Setting this to 0 means that the connect fails
             immediately if the device returns a failure.";
        }
        leaf timeout {
          type uint32 {
            range "0..4294967";
          }
          units "seconds";
          tailf:info "Wait time in seconds between retries";
          description
            "Specifies the timeout in seconds between retries.";
        }
      }

      leaf trace {
        tailf:info "Trace the southbound communication to devices";
        type trace-flag;
        description
          "Controls southbound traffic trace to managed devices.";
      }

      container ned-settings {
        tailf:info "Control which device capabilities NCS uses";
        description
          "When communicating with a device, NCS adapts its behavior
           to the capabilities of the device.  When writing to the device,
           NCS uses the capabilities that give most control, and minimal
           risk of network inconsistencies.  The parameters in this
           container can be used to tweak NCS's behavior.  These parameters
           must be used with care.";

        leaf use-confirmed-commit {
          tailf:info "Control usage of confirmed commit";
          type boolean;
          description
            "Controls if NCS should use confirmed commit towards the
             device.  This setting has no effect if the device does
             not advertise support for confirmed-commit.

             If no value is configured, the default depends on the NED
             type.  The NETCONF NED by default uses confirmed commit if
             it is advertised.";

        }
        leaf use-validate {
          tailf:info "Control usage of validate";
          type boolean;
          description
            "Controls if NCS should use explicit validation towards the
             device.  This setting has no effect if the device does
             not advertise support for validate.

             It can be useful to disable validate in order to increase
             performance, since when validate is used, the device must
             validate the changes twice; at validate, and at commit.

             The advantage of using validate is that if the changes are
             sent to N devices, and validated on all of them, if one
             device fails the validation step, nothing has been committed
             to any device, and the transaction can easily be aborted.

             Without validate, NCS will commit on all N devices, and if
             one fails the commit due to a validation error, NCS has
             to undo the changes on the other devices.

             If no value is configured, the default depends on the NED
             type.  The NETCONF NED by default uses validate if
             it is advertised.";
        }
        leaf use-startup {
          tailf:info "Control usage of the startup datastore";
          type boolean;
          description
            "Controls if NCS should invoke the copy-running-to-startup
             operation towards the device.  This setting has no effect
             if the device does not advertise support for startup.

             It can be useful to disable this operation in order to
             increase performance, in the case that this is an
             expensive operation on the device.  It should be noted
             that in this case, the device will not have all changes
             persistently stored.  This can be combined with a job
             that performs this operation periodically, e.g., once an
             hour.

             If no value is configured, the default depends on the NED
             type.  The NETCONF NED by default uses startup if
             it is advertised.";
        }
        leaf use-transaction-id {
          tailf:info "Control usage of fetching the transaction id";
          type boolean;
          description
            "For some devices, getting the transaction id can be a costly
             operation.  If it is disabled, NCS will not be able to
             detect situations where NCS and the device are out of
             sync.

             If no value is configured, the default depends on the NED
             type.  The NETCONF NED by default reads the transaction id,
             if it knows how to get it from the device.";
        }
        leaf use-private-candidate {
          tailf:info "Control usage of the private candidate";
          type boolean;
          description
            "If the device supports the concept of a private
             candidate, NCS can use it instead of the normal, shared
             candidate.

             This option can be useful if there are other management
             applications other than NCS configuring the devices, and
             these other applications also use private candidates.

             If no value is configured, the default depends on the NED
             type.  The NETCONF NED by default does not use a private
             candidate.  For NETCONF, this option currently has effect
             only for Juniper devices running Junos.";
        }
        leaf use-junos-rollback {
          tailf:info "If set to true use device rollback as a revert strategy.";
          type boolean;
          description
            "Use the latest rollback instead of computing and sending a reverse
             diff when other device in the transaction has failed in commit and
             the configuration on successful devices needs to be reverted.

             Using rollback involves less communication overhead with the
             device but the rollback functionality might not be supported by
             all device software versions.

             This option has effect only for Juniper devices running Junos.";
        }
        // NEDs can augment NED-specific parameters here.
      }

      container commit-queue {
        tailf:info "Control settings for the commit queue";
        leaf enabled-by-default {
          type boolean;
          description
            "If this leaf is set, all commits for this device will by
             default go through the commit queue.";
        }
      }

      container session-pool {
        tailf:info "Control how sessions to related devices can be pooled.";
        description
          "NCS uses NED sessions when performing transactions, actions
           etc towards a device. When such a task is completed the NED
           session can either be closed or pooled.

           Pooling a NED session means that the session to the
           device is kept open for a configurable amount of
           time. During this time the session can be re-used for a new
           task. Thus the pooling concept exists to reduce the number
           of new connections needed towards a device that is often
           used.

           By default NCS uses pooling for all device types except
           snmp. Normally there is no need to change the default
           values.";

        leaf max-sessions {
          type union {
            type enumeration {
              enum unlimited;
            }
            type uint32;
          }
          description
            "Controls the maximum number of open sessions in the pool for
             a specific device. When this threshold is exceeded the oldest
             session in the pool will be closed.
             A Zero value will imply that pooling is disabled for
             this specific device. The label 'unlimited' implies that no
             upper limit exists for this specific device";
        }

        leaf idle-time {
          tailf:info
            "The maximum time that a session is kept open in the pool";
          type uint32 {
            range "1..4294967";
          }
          units "seconds";
          description
            "The maximum time that a session is kept open in the pool.
             If the session is not requested and used before the
             idle-time has expired, the session is closed.
             If no idle-time is set the default is 30 seconds.";
        }
      }

      container no-overwrite {
        tailf:info "Control settings for no-overwrite sync check";
        leaf enabled-by-default {
          type boolean;
          description
            "If this leaf is set, all commits for this device will by
             default make a no-overwrite sync check.";
        }
      }

      leaf out-of-sync-commit-behaviour {
        type enumeration {
          enum reject;
          enum accept;
        }
        description
          "Specifies the behaviour of a commit operation involving a
           device that is out of sync with NCS. Value accept assumes that
           the device's sync state is unknown and it is cleared on commit.
           The default behaviour is to reject such commits.";
      }

      choice choice-lsa {
        leaf use-lsa {
          type empty;
          description
            "Handle the LSA nodes as such. This is the default.";
        }
        leaf no-lsa {
          type empty;
          description
            "Do not handle any of the LSA nodes as such. These nodes
             will be handled as any other device. This has the same
             result as adding the commit flag 'no-lsa' to every commit.";
        }
        default use-lsa;
      }
    }

    grouping capability-module-grouping {
      list capability {
        key uri;
        leaf uri {
          tailf:cli-allow-range;
          type string;
        }
        leaf revision {
          type string;
        }
        leaf module {
          type string;
        }
        leaf-list feature {
          type string;
        }
        leaf-list deviation {
          type string;
        }
      }

      list module {
        key name;
        leaf name {
          type string;
        }
        leaf revision {
          type string;
        }
        leaf-list feature {
          type string;
        }
        leaf-list deviation {
          type string;
        }
      }

      tailf:action copy-capabilities {
        description
          "Note: this action overwrites existing list of capabilities.

           This action copies the list of capabilities and the list of modules
           from another device or profile. When used on a device, this action
           is only intended to be used for pre-provisioning: it is not possible
           to override capabilities and modules provided by the
           NED implementation using this action.";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          choice from-where {
            leaf from-device {
              type leafref {
                path "/devices/device/name";
              }
            }
            leaf from-profile {
              type leafref {
                path
                  "/devices/profiles/capabilities-profile/name";
              }
            }
            mandatory true;
          }
        }
      }
    }

    container global-settings {
      tailf:info "Global settings for all managed devices.";
      description
        "Global settings for all managed devices.  Some of these
         settings can be overridden per managed device.";

      uses device-profile-parameters {
        refine wait-for-lock-choice{
          description
            "By default all actions accepting the wait-for-lock parameter will
             not wait for lock if the wait-for-lock parameter was not given.";
          default "no-wait-for-lock";
        }
        refine connect-timeout {
          default 20;
        }
        refine read-timeout {
          default 20;
        }
        refine write-timeout {
          default 20;
        }
        refine ssh-keep-alive/interval {
          default 20;
        }
        refine ssh-keep-alive/count {
          default 3;
        }
        refine ned-keep-alive/count {
          default 3;
        }
        refine connect-retries/attempts {
          default 0;
        }
        refine connect-retries/timeout {
          default 3;
        }
        refine trace {
          default false;
        }
        refine ned-settings/use-junos-rollback {
          default false;
        }
        refine no-overwrite/enabled-by-default {
          default false;
        }
        refine out-of-sync-commit-behaviour {
          default reject;
        }
        refine session-pool/idle-time {
          default 30;
        }
        augment session-pool {
          leaf pool-max-sessions {
            type union {
              type enumeration {
                enum unlimited;
              }
              type uint32;
            }
            default 200;
            description
              "Controls the grand total session count in the pool.
               Independently on how different devices are pooled the grand
               total session count can never exceed this value.
               A zero value will imply that pooling is disabled for all devices.
               The value 'unlimited' implies that no upper limit exists for
               the number open sessions in the pool";
          }
        }
        refine commit-queue/enabled-by-default {
          default false;
        }
        augment commit-queue {
          uses commit-queue-basic-options;
          leaf atomic {
            type boolean;
            default true;
            description
              "This leaf sets the atomic behaviour of all new queue items
               in the commit queue. If these are set to false, the devices
               contained in these queue items can start executing if the
               same devices in other non-atomic queue items ahead of it
               in the queue are completed. If set to true, the atomic
               integrity of these queue items are preserved.";
          }
          leaf retry-attempts {
            type union {
              type uint32 {
                range "0..max";
              }
              type enumeration {
                enum unlimited;
              }
            }
            default "unlimited";
            tailf:info "Number of retries before giving up";
            description
              "Number of attempts to process the device in
               the queue item if it returns a transient error.
               For example, if NCS fails to connect to the device
               or take a lock on it.

               Setting this to 0 means that the queue item fails
               immediately even on transient errors.";
          }
          leaf retry-timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            default 30;
            tailf:info "Wait time in seconds between retries";
            description
              "Specifies the timeout in seconds between retries.
               This is not applicable for devices where
               /devices/device/state/admin-state = 'call-home'.
               These devices will wait until a TCP connection
               is established from the NETCONF server.";
          }
          leaf check-integrity {
            tailf:info "Safeguard device and service integrity";
            type boolean;
            default true;
            description
              "To guarantee service integrity NCS checks for
               overlapping service or device modifications when committing
               with the commit queue. These checks can be bypassed by
               setting the leaf to false. This could potentially
               commit changes that are not deployed to the network if a
               queue item with overlapping data failed ahead in the
               queue. The benefit of doing so is increased throughput.";
          }
          leaf error-option {
            type enumeration {
              enum continue-on-error {
                description
                  "The commit queue will continue on errors. No rollback data
                   will be created. This is the preferred choice when
                   re-deploying a service as a re-deploy doesn't have a
                   transaction intent.";
              }
              enum rollback-on-error {
                description
                  "The commit queue items will roll back on errors. The commit
                   queue will place a lock with 'block-others' on the devices
                   and services in a failed queue item. The rollback action
                   will then automatically be invoked when the failed queue
                   item has finished its execution. The lock is removed as
                   part of the rollback.";
              }
              enum stop-on-error {
                description
                  "The commit queue will place a lock with 'block-others'
                   on the devices and services in a failed queue item. The
                   lock must then either manually be released or the rollback
                   action under /devices/commit-queue/completed be invoked.";
              }
            }
            default "continue-on-error";
            description
              "The error option to use. Depending on the selected error option
               NCS will store the reverse of the original transaction intent
               to be able to undo the transaction changes and get back to the
               previous state. This data is stored in the
               /devices/device/commit-queue/completed tree from where it can
               be viewed and invoked with the rollback action. When invoked
               the data will be removed.";
          }
        }
      }

      container commit-retries {
        tailf:info "Retry commits on transient errors";
        description
          "Settings for how to retry commits if some device returns
           a transient error. For example, if NCS fails to take a
           lock on a device, it can retry after a short time.";
        leaf attempts {
          type uint8;
          default 5;
          tailf:info "Number of retries before giving up";
          description
            "Number of attempts to retry the commit before giving up.

             Setting this to 0 means that the transaction fails
             immediately even on transient errors.";
        }
        leaf timeout {
          type uint32 {
            range "0..4294967";
          }
          units "seconds";
          default 3;
          tailf:info "Wait time in seconds between retries";
          description
            "Specifies the timeout in seconds between retries.";
        }
      }

      leaf trace-dir {
        tailf:info "The directory where trace files are stored";
        type string;
        default ".";
        description
          "Specifies the directory where southbound traffic trace log files
           to managed devices are stored.

           The trace files are called <type>-<device-name>.trace
           where <type> is one of 'netconf', 'snmp', or 'ned', depending on
           the type of the managed device.";
      }

      leaf report-multiple-errors {
        type boolean;
        default false;
        description
          "By default, when the NCS device manager commits data
           southbound and when there are errors, we only report
           the first error to the operator, this flag makes NCS
           report all errors reported by managed devices";
      }

    }

    container profiles {
      tailf:info "Device profile parameters";
      list profile {
        tailf:info "Parameters for a device profile";
        key name;
        leaf name {
          tailf:info "The name of the device profile";
          type string;
        }
        uses device-profile-parameters;
      }
      list capabilities-profile {
        key name;
        leaf name {
          tailf:info "The name of the device profile";
          type string;
        }
        uses capability-module-grouping;
      }
    }

    container authgroups {
      tailf:info "Authentication for managed devices";
      description
        "Named authgroups are used to decide how to map a local NCS user to
         remote authentication credentials on a managed device.

         The list 'group' is used for NETCONF and CLI managed devices.

         The list 'snmp-group' is used for SNMP managed devices.";

      list group {
        tailf:info "Authentication settings for a group of devices";
        key name;

        description
          "When NCS connects to a managed device, it locates the
           authgroup configured for that device.  Then NCS looks up
           the local NCS user name in the 'umap' list.  If an entry is
           found, the credentials configured is used when
           authenticating to the managed device.

           If no entry is found in the 'umap' list, the credentials
           configured in 'default-map' are used.

           If no 'default-map' has been configured, and the local NCS
           user name is not found in the 'umap' list, the connection
           to the managed device fails.";
        grouping remote-user-remote-auth {
          description
            "Remote authentication credentials.";

          choice login-credentials {
            mandatory true;
            case stored {
              choice remote-user {
                mandatory true;
                leaf same-user {
                  tailf:info "Use the local NCS user name as the remote user
                              name";
                  type empty;
                  description
                  "If this leaf exists, the name of the local NCS user is used
                   as the remote user name.";
                }
                leaf remote-name {
                  tailf:info "Specify device user name";
                  type string;
                  description
                    "Remote user name.";
                }
              }

              choice remote-auth {
                mandatory true;
                leaf same-pass {
                  tailf:info "Use the local NCS password as the remote
                              password";
                  type empty;
                  description
                    "If this leaf exists, the password used by the local user
                     when logging in to NCS is used as the remote password.";
                }
                leaf remote-password {
                  tailf:info "Specify the remote password";
                  tailf:suppress-echo "true";
                  type tailf:aes-cfb-128-encrypted-string;
                  description
                    "Remote password.";
                }
                case public-key {
                  uses public-key-auth;
                }
              }
              leaf remote-secondary-password {
                 tailf:info "Second password for configuration";
                tailf:suppress-echo "true";
                type tailf:aes-cfb-128-encrypted-string;
                description
                  "Some CLI based devices require a second
                   additional password to enter config mode";
              }
            }
            case callback {
              leaf callback-node {
                description
                  "Invoke a standalone action to retrieve login credentials for
                   managed devices on the 'callback-node' instance.

                   The 'action-name' action is invoked on the callback node that
                   is specified by an instance identifer.";
                mandatory true;
                type instance-identifier;
              }
              leaf action-name {
                description
                  "The action to call when a notification is received.

                   The action must use 'authgroup-callback-input-params'
                   grouping for input and 'authgroup-callback-output-params'
                   grouping for output from tailf-ncs-devices.yang.";
                type yang:yang-identifier;
                mandatory true;
                tailf:validate ncs {
                  tailf:internal;
                  tailf:dependency "../callback-node";
                }
              }
            }
          }
        }
        leaf name {
          tailf:info "The name of the authgroup";
          type string;
          description
            "The name of the authgroup.";
        }

        container default-map {
          presence "Map unknown users";
          description
            "If an authgroup has a default-map, it is used if a local
             NCS user is not found in the umap list.";
          tailf:info "Remote authentication parameters for users not in umap";
          uses remote-user-remote-auth;
        }

        list umap {
          key local-user;
          description
            "The umap is a list with the local NCS user name as key.
             It maps the local NCS user name to remote authentication
             credentials.";
          tailf:info "Map NCS users to remote authentication parameters";
          leaf local-user {
            type string;
            description
              "The local NCS user name.";
          }
          uses remote-user-remote-auth;
        }
      }
      list snmp-group {
        tailf:info "SNMP authentication groups";
        key name;

        description
          "When NCS connects to a managed device over SNMP, it locates
           the snmp-group configured for that device.  Then NCS looks
           up the local NCS user name in the 'umap' list.  If an entry
           is found, the credentials configured is used when
           authenticating to the managed device.

           If no entry is found in the 'umap' list, or credentials for
           the requested SNMP version has not been configured, the
           credentials configured in 'default-map' are used.

           If no 'default-map' has been configured, and the local NCS
           user name is not found in the 'umap' list, the connection
           to the managed device fails.";

        grouping key {
          choice key-type {
            leaf same-password {
              tailf:info "Use the local NCS password to create a localized key";
              type empty;
              description
                "Use the local NCS password as the password
                 used by NCS to create a localized key, as described
                 in RFC 3414.";
            }
            leaf remote-password {
              tailf:suppress-echo "true";
              type tailf:aes-cfb-128-encrypted-string;
              description
                "If this leaf is set, NCS uses its value to create
                 a localized key, as described in RFC 3414.";
              tailf:info "Explicit password";
            }
            leaf key {
              type tailf:hex-list;
              description
                "Non-localized key specified as a list of
                 colon-separated hexa-decimal octets.  NCS localizes
                 this key for a device before it is used, as described
                 in RFC 3414.";
              tailf:info "Explicit non-localized key";
            }
          }
        }

        grouping remote-snmp-credentials {
          description
            "Remote SNMP credentials.";

          choice community {
            leaf community-name {
              type string;
              description
                "A community name that can be represented as a
                 YANG string.";
              tailf:info "Community name as a string";
            }
            leaf community-binary-name {
              type binary;
              description
                "A community name represented as a binary value.";
              tailf:info "Community name as a binary value";
            }
          }

          container usm {
            presence "enables usm";
            tailf:info "USM parameters";
            choice remote-user {
              mandatory true;
              leaf same-user {
                type empty;
                description
                  "Use the local NCS user name as the remote USM user name.";
                tailf:info "Use current user's local name as USM user name";
              }
              leaf remote-name {
                type string {
                  length "1..32";
                }
                description
                  "Remote USM user name.";
                reference "SNMP-USER-BASED-SM-MIB.usmUserName";
                tailf:info "Explicit USM user name";
              }
            }
            leaf security-level {
              type snmp-security-level;
              mandatory true;
              must ". = 'no-auth-no-priv' or ../auth" {
                error-message
                  "when security-level indicates authentication,"
                + " the auth parameters must be set.";
                tailf:dependency "../auth";
              }
              must "(. = 'auth-priv' and ../priv)"
                 + " or (. != 'auth-priv')" {
                error-message
                  "when security-level indicates privacy,"
                + " the priv parameters must be set.";
                tailf:dependency "../priv";
              }
              tailf:info "SNMP security level";
            }
            container auth {
              presence "enables authentication";
              tailf:info "SNMP authentication parameters";
              choice protocol {
                mandatory true;
                reference "SNMP-USER-BASED-SM-MIB.usmUserAuthProtocol";
                container md5 {
                  uses key;
                  reference "SNMP-USER-BASED-SM-MIB.usmHMACMD5AuthProtocol";
                }
                container sha {
                  uses key;
                  reference "SNMP-USER-BASED-SM-MIB.usmHMACSHAAuthProtocol";
                }
              }
            }
            container priv {
              presence "enables privacy";
              tailf:info "SNMP privacy parameters";
              must "../auth" {
                error-message
                  "when privacy is used, authentication must also be used";
              }
              choice protocol {
                mandatory true;
                reference "SNMP-USER-BASED-SM-MIB.usmUserPrivProtocol";
                container des {
                  uses key;
                  reference "SNMP-USER-BASED-SM-MIB.usmDESPrivProtocol";
                }
                container aes {
                  uses key;
                  reference "SNMP-USM-AES-MIB.usmAesCfb128Protocol";
                }
              }
            }
          }
        }

        leaf name {
          tailf:info "The name of the snmp authgroup";
          type string;
          description
            "The name of the snmp authgroup.";
        }
        container default-map {
          presence "Map unknown users";
          description
            "If an snmp auth group has a default-map, it is used if a
             local NCS user is not found in the umap list.";
          tailf:info "Remote authentication parameters for users not in umap";
          uses remote-snmp-credentials;
        }
        list umap {
          key local-user;
          description
            "The umap is a list with the local NCS user name as key.
             It maps the local NCS user name to remote authentication
             credentials.";
          tailf:info "Map NCS users to remote authentication parameters";
          leaf local-user {
            type string;
            description
              "The local NCS user name.";
          }
          uses remote-snmp-credentials;
        }
      }
    }

    list template {
      tailf:info "Named configuration templates for devices";
      key name;
      description
        "This list is used to define named template configurations that
         can be used to either instantiate the configuration for new
         devices, or to apply snippets of configurations to existing
         devices.

         A template is applied by invoking the 'apply-template' action
         in a device-group or in a device.

         When template is applied, the nodes in the template are by
         default merged with the nodes in the target device.  This
         behaviour can be changed by using tags:

         If a list or container node in the template contains a tag
         with the value 'replace', the template application will
         change from merge to replace for this node.

         Otherwise, if a list or container node in the template
         contains a tag with the value 'nocreate', the template
         application will never create this node or anything below it;
         it will only modify existing containers and list entries.

         Otherwise, if a node in the template contains a tag with the
         value 'delete', the template application will delete this
         node from the device, if it exists.";
      leaf name {
        type string;
        description
          "The name of a specific template configuration.";
      }
      list ned-id {
        key id;
        leaf id {
          type identityref {
            base ned:ned-id;
          }
        }
        container config {
          tailf:mount-point ncs-template-config;
          tailf:cli-add-mode;
          tailf:cli-expose-ns-prefix;
          description
            "This container is augmented with data models from the devices.";
        }
      }
      container config {
        tailf:cli-add-mode;
        tailf:cli-expose-ns-prefix;
        description
          "Just to support releases prior to 4.5. Will be deprecated";
      }
    }

    list device-group {
      tailf:info "Groups of devices";
      key name;
      leaf name {
        type string;
      }
      description
        "A named group of devices, some actions can be
         applied to an entire  group of devices, for example
         apply-template, and the sync actions.";
      tailf:validate ncs {
        tailf:internal;
        tailf:call-once true;
        tailf:dependency "device-group";
      }

      uses location {
        description
          "Location of the device group.  These nodes are expected to be
           configured by the operator, typically by using a map application
           in e.g., the Web UI.";
      }

      leaf-list device-name {
        tailf:info "Device within group";
        tailf:non-strict-leafref {
          path "/devices/device/name";
        }
        type string;
        tailf:validate ncs {
          tailf:internal;
          tailf:call-once true;
          tailf:dependency "/devices/device/name";
        }
      }
      leaf-list device-group {
        tailf:info "Group within group";
        type leafref {
          path "/devices/device-group/name";
        }
        description
          "A list of device groups contained in this device group.

           Recursive definitions are not valid.";
      }
      leaf-list member {
        tailf:info "Flattened list of all members";
        type leafref {
          path "/devices/device/name";
        }
        config false;
        description
          "The current members of the device-group. This is a flat list
           of all the devices in the group.";
        tailf:callpoint ncs {
          tailf:internal;
        }
      }

      list ned-id {
        key id;
        leaf id {
          type identityref {
            base ned:ned-id;
          }
        }
        container rpc {
          tailf:mount-point ncs-device-group-rpc;
          tailf:info "RPCs from the device's";
          description
           "This container is augmented with top-level rpcs
            from the device's data models.

            The rpcs are augments as tailf:actions. This makes it possible
            to invoke rpcs on the devices through the NCS data model.";
        }
        config false;
        description
          "This list contains the ned-ids set on the devices included in
           this device group.";
        tailf:callpoint ncs {
          tailf:internal;
        }
        uses migrate-grouping;
      }
      uses connect-grouping;
      uses sync-to-grouping;
      uses sync-from-grouping;
      uses check-sync-grouping;
      uses check-yang-modules-grouping;
      uses fetch-ssh-host-keys-grouping;
      uses apply-template-grouping;
    }

    list mib-group {
      tailf:info "A list of named groups of MIBs";
      key name;
      description
        "A list of named groups of MIBs.

         This list is used so that SNMP devices can refer to collections
         of MIBs, instead of having to refer to individual MIBs.

         For example, an operator can configure one MIB group per
         device model.";
      tailf:validate ncs {
        tailf:internal;
        tailf:call-once true;
        tailf:dependency "mib-group";
      }
      leaf name {
        type string;
        description
          "An arbitrary name of the MIB group.";
      }
      leaf-list mib-module {
        tailf:info "MIB module names or name prefixes";
        type string;
        description
          "A list of MIB module names or MIB module name prefixes in
           this MIB group.

           The string is either exactly matches a MIB module, e.g.,
           'SNMPv2-MIB', or a prefix followed by a wildcard, e.g.,
           'SNMP-*'.  Such a prefix matches all MIB modules with names
           starting by 'SNMP-'.";
      }
      leaf-list mib-group {
        tailf:info "A list of MIB groups contained in this MIB group";
        type leafref {
          path "/devices/mib-group/name";
        }
        description
          "A list of MIB groups contained in this MIB group.

           Recursive definitions are not valid.";
      }
    }

    list device {
      tailf:info "The list of managed devices";
      key name;

      description
        "This list contains all devices managed by NCS.";

      leaf name {
        tailf:info "A string uniquely identifying the managed device";
        tailf:cli-allow-range;
        type string;
        description
          "A string uniquely identifying the managed device.";
      }

      must "remote-node or address or lsa-remote-node or "
         + "./state/admin-state = 'call-home'" {
        error-message
          "Either address, remote-node or lsa-remote-node must "
        + "be configured or the admin-state indicate call-home.";
        tailf:dependency "ncs:address";
        tailf:dependency "ncs:remote-node";
        tailf:dependency "ncs:lsa-remote-node";
        tailf:dependency "ncs:state/admin-state";
      }

      leaf last-changed {
        tailf:hidden full;
        config false;
        tailf:cdb-oper {
          tailf:persistent true;
        }
        type yang:date-and-time;
        description
          "When the device was last changed.";
      }

      choice address-choice {
        case device {
          leaf address {
            tailf:info "IP address or host name for the management interface";
            type inet:host;
            description
              "IP address or host name for the management interface on
               the device.";
          }
          leaf port {
            tailf:info "Port for the management interface";
            type inet:port-number;
            description
              "Port for the management interface on the device. If this leaf
               is not configured, NCS will use a default value based on the
               type of device. For example, a NETCONF device uses port 830,
               a CLI device over SSH uses port 22, and a SNMP device uses
               port 161.";
          }
          leaf remote-node {
            tailf:info "Name of remote node which connects to device";
            type leafref {
              path "/cluster/remote-node/name";
            }
            description
              "Setting remote-node indicates that this device is managed by
               another cluster node. When set, all other device settings are
               read and write through to the remote node, i.e. nothing is
               locally stored about this device.";
          }
        }
        case lsa-device {
          leaf lsa-remote-node {
            when "derived-from-or-self(../device-type/netconf/ned-id, "
              + "'ned:lsa-netconf')";
            type leafref {
              path "/cluster/remote-node/name";
            }
            description
              "Setting lsa-remote-node indicates that this device is the same
               as the cluster node. When set the address and port of the
               cluster node is used for this device.";
          }
        }
      }

      leaf local-user {
        type string;
        description
          "The local user is used when setting up a device
           connection for call home connections.";
      }

      uses ssh-connection-config;

      leaf description {
        tailf:info "Free form textual description";
        type string;
        description
          "Free form text describing the device.";
      }
      uses location {
        description
          "Location of the device.  These nodes are expected to be
           configured by the operator, typically by using a map application
           in e.g., the Web UI.";
      }

      grouping ne-type {

        leaf authgroup {
          tailf:info "Authentication credentials for the device";
          type leafref {
            path "/devices/authgroups/group/name";
          }
          description
            "The authentication credentials used when connecting
             to this managed device.

             This leaf must be set for NETCONF and CLI devices, and
             may be used by generic NEDs, if applicable.";
        }

        container device-type {
          tailf:info "Management protocol for the device";
          choice ne-type {
            case netconf {
              container netconf {
                must "../../authgroup" {
                  error-message
                    "A NETCONF device must have a authgroup.";
                  tailf:dependency "../../authgroup";
                }
                leaf ned-id {
                  tailf:info "The NED Identity";
                  type identityref {
                    base ned:ned-id;
                  }
                  tailf:callpoint ncs {
                    tailf:internal;
                    tailf:set-hook node;
                  }
                  tailf:validate ncs {
                    tailf:internal;
                    tailf:dependency ".";
                  }
                  mandatory true;
                }
              }
            }
            case generic {
              container generic {
                tailf:info "Use a generic NED to talk to the device";
                leaf ned-id {
                  tailf:info "The NED Identity";
                  type identityref {
                    base ned:ned-id;
                  }
                  tailf:callpoint ncs {
                    tailf:internal;
                    tailf:set-hook node;
                  }
                  tailf:validate ncs {
                    tailf:internal;
                    tailf:dependency ".";
                  }
                  mandatory true;
                }
              }
            }
            case cli {
              container cli {
                tailf:info "Use CLI to communicate with the device";
                must "../../authgroup" {
                  error-message
                    "A CLI device must have a authgroup.";
                  tailf:dependency "../../authgroup";
                }
                leaf ned-id {
                  tailf:info "The NED Identity";
                  type identityref {
                    base ned:ned-id;
                  }
                  tailf:callpoint ncs {
                    tailf:internal;
                    tailf:set-hook node;
                  }
                  tailf:validate ncs {
                    tailf:internal;
                    tailf:dependency ".";
                  }
                  mandatory true;
                }
                leaf protocol {
                  tailf:info "The CLI protocol";
                  type enumeration {
                    enum telnet;
                    enum ssh;
                  }
                  default ssh;
                }
              }
            }
            case snmp {
              container snmp {
                leaf version {
                  type snmp-version;
                  mandatory true;
                  tailf:info "SNMP version to use";
                }
                leaf context-name {
                  when "../version = 'v3'";
                  type string;
                  default "";
                  description
                    "The SNMP context name to use when communicating
                     with the device.  If an SNMP engine supports multiple
                     contexts, each context must be handled as a separate
                     managed-device in NCS.";
                  reference
                    "RFC 3411: Architecture for SNMP Management Frameworks";
                  tailf:info "SNMP context to use";
                }
                leaf ned-id {
                  tailf:info "The NED Identity";
                  type identityref {
                    base ned:snmp-ned-id;
                  }
                  mandatory true;
                }
                leaf snmp-authgroup {
                  type leafref {
                    path "/devices/authgroups/snmp-group/name";
                  }
                  mandatory true;
                  tailf:info "Name of an SNMP authgroup";
                }
                leaf retries {
                  type uint8;
                  default 3;
                  description
                    "Specifies the number of retries to be used when sending
                     a request.";
                  tailf:info "Number of times a request is resent";
                }
                leaf timeout {
                  type uint32 {
                    range "0..4294967";
                  }
                  units "seconds";
                  default 1;
                  description
                    "Specifies the timeout in seconds between retries.";
                  tailf:info "Wait time in seconds between retries";
                }
                leaf-list mib-group {
                  tailf:info "A list of MIB groups implemented by the device";
                  type leafref {
                    path "/devices/mib-group/name";
                  }
                  description
                    "A list of MIB groups implemented by the device.

                     In SNMP, there is no generic, automatic way to
                     figure out which MIBs an agent implements.  Thus,
                     this list can be used to inform NCS which MIBs the
                     device implements.

                     If this list is empty, NCS assumes that the device
                     implements all MIBs known to NCS.

                     The MIBs NCS thinks the device implements are
                     listed in /devices/module.  These
                     modules are used by NCS to control what data can
                     be configured under /devices/device/config,
                     and what data is shown in
                     /devices/device/live-status.";
                }
              }
            }
          }
          list lsa-additional-ned-id {
            when "derived-from-or-self(../netconf/ned-id, 'ned:lsa-netconf')";
            key ned-id;
            tailf:callpoint ncs {
              tailf:internal;
              tailf:transaction-hook node;
            }
            tailf:validate ncs {
              tailf:internal;
              tailf:call-once true;
              tailf:dependency "ned-id";
            }
            leaf ned-id {
              tailf:info "The NED Identity";
              type identityref {
                base ned:netconf-ned-id;
              }
            }
            tailf:info "Additional lsa ned-id for service packages.";
            description
              "The underlaying lsa-node can have services packages that are
               device compiled using other ned-ids than the primary ned-id
               for the lsa-node itself.
               To be able to include such service these ned-ids must be included
               in this list.";
          }
        }
      }

      uses ne-type {
        refine device-type {
          must "not(boolean(../remote-node) and boolean(./*/ned-id))" {
            error-message
              "A device-type should not be configured for a remote-node.";
            tailf:dependency "../remote-node";
            tailf:dependency "ncs:netconf/ned-id";
            tailf:dependency "ncs:generic/ned-id";
            tailf:dependency "ncs:cli/ned-id";
            tailf:dependency "ncs:snmp/ned-id";
          }
          must "../remote-node or netconf or generic or cli or snmp" {
            // Same error message as when the choice is mandatory
            error-message "must configure one of: snmp, cli, generic, netconf";
            tailf:dependency "../remote-node";
            tailf:dependency "ncs:netconf";
            tailf:dependency "ncs:generic";
            tailf:dependency "ncs:cli";
            tailf:dependency "ncs:snmp";
          }
        }
      }

      tailf:action migrate {
        description
          "Change the NED identity and migrate all data. As a side-effect reads
           and commits the actual device configuration.

           The action reports what paths have been modified and the services
           affected by those changes.

           If the wait-for-lock parameter is not given, the wait-for-lock
           device setting is going to be used.";
        tailf:info "Migrate the device to a new NED type";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          choice ned-id {
            leaf new-ned-id {
              mandatory true;
              tailf:info "The new NED Identity";
              type identityref {
                base ned:ned-id;
              }
            }
            container lsa-additional-ned-id {
              tailf:display-when "derived-from-or-self(../../device-type/"
                + "netconf/ned-id, 'ned:lsa-netconf')";
              leaf old {
                mandatory true;
                tailf:info "The old LSA additional NED identity to delete";
                type identityref {
                  base ned:netconf-ned-id;
                }
              }
              leaf new {
                mandatory true;
                tailf:info "The new LSA additional NED identity to create";
                type identityref {
                  base ned:netconf-ned-id;
                }
              }
            }
          }
          leaf dry-run {
            type empty;
          }
          leaf no-networking {
            type empty;
            description
              "Do not generate any southbound traffic towards the
               device. Use the device configuration in CDB.";
          }
          leaf verbose {
            tailf:info "Report all service instances";
            description
              "Report all service instances instead of just the
               service points.";
            type empty;
          }
          uses wait-for-lock;
        }
        output {
          uses migrate-result;
        }
      }

      leaf device-profile {
        type leafref {
          path "/devices/profiles/profile/name";
        }
      }

      uses device-profile-parameters {
        augment commit-queue {
          leaf queue-length {
            type int32;
            config false;
            description
              "The number of queue items that contain the device.";
            tailf:callpoint ncs {
              tailf:internal;
            }
          }
          list waiting-for {
            config false;
            description
              "A list of devices in the queue that the device is waiting
               for in order to execute.";
            tailf:callpoint ncs {
              tailf:internal;
            }
            choice type {
              leaf device {
                type leafref {
                  path "/devices/device/name";
                }
              }
              leaf cluster-node {
                type leafref {
                  path "/cluster/remote-node/name";
                }
              }
            }
          }
        }
      }

      container active-settings {
        config false;
        tailf:info "Show all active settings for the device";
        description
          "The active set of parameters used when communicating with
           the device.";
        tailf:callpoint ncs {
          tailf:internal;
        }
        uses device-profile-parameters;
      }

      list live-status-protocol {
        tailf:info "Additional protocols for the live-tree (read-only)";
        key name;
        description
          "It is possible to have additional NEDs speaking
           southbound to the managed device for the device's
           'live-status' tree.

           All configuration data must be handled by one NED, but
           multiple NEDs can be used for the 'live-status' tree.

           For example a CLI NED can be used for 'show routes'
           and the SNMP NED for some additional MIBs";
        leaf name {
          type string;
        }

        leaf address {
          tailf:info "IP Address for the management interface";
          type inet:host;
          description
            "IP address or host name for the management interface on
             the device. If omitted the same address as configured for
             this device will be used.";
        }

        leaf port {
          tailf:info "Port for the management interface";
          type inet:port-number;
          description
            "Port for the management interface on the device.  If this leaf
             is not configured, NCS will use a default value based on
             the type of device.  For example, a NETCONF device uses
             port 830, a CLI device over SSH uses port 22, and a SNMP
             device uses port 161.";
        }

        container ssh {
          presence "protocol-specific ssh host keys";
          tailf:info "SSH host key configuration";
          tailf:code-name ssh_container;
          description
            "SSH host keys for this protocol. If not present, the host keys
             configured for this device will be used.";
          uses ssh-host-keys;
        }

        uses ne-type {
          refine device-type {
            must "not(boolean(../../remote-node) and boolean(./*/ned-id))" {
              error-message
                "A device-type should not be configured for a remote-node.";
              tailf:dependency "../../remote-node";
              tailf:dependency "ncs:netconf/ned-id";
              tailf:dependency "ncs:generic/ned-id";
              tailf:dependency "ncs:cli/ned-id";
              tailf:dependency "ncs:snmp/ned-id";
            }
            must "../../remote-node or netconf or generic or cli or snmp" {
              // Same error message as when the choice is mandatory
              error-message
                "must configure one of: snmp, cli, generic, netconf";
              tailf:dependency "../../remote-node";
              tailf:dependency "ncs:netconf";
              tailf:dependency "ncs:generic";
              tailf:dependency "ncs:cli";
              tailf:dependency "ncs:snmp";
            }
          }
        }

        container state {
          tailf:info "Operational State for the live protocol";
          config false;
          tailf:cdb-oper {
            tailf:persistent true;
          }
          uses oper-state;
        }

        list capability {
          tailf:info "List of capabillities supported by the device";
          key uri;
          config false;
          description
            "This is a list of the capabilities supported by the device.
             when additional NEDs have been configured in the live tree.
             This list is thus the result of those extra stats NEDs.
             This list is populated the first time NCS connects to the
             device.  Not dependant on local-user.";
          tailf:cdb-oper {
            tailf:persistent true;
          }

          leaf uri {
            tailf:info "Capability URI";
            type string;
          }
          leaf revision {
            tailf:info "Capability revision";
            type string;
          }
          leaf module {
            tailf:info "Capability module";
            type string;
          }
          leaf-list feature {
            tailf:info "Capability features";
            type string;
          }
          leaf-list deviation {
            tailf:info "Capability deviations";
            type string;
          }
        }
      }

      container state {
        tailf:info "Show states for the device";
        uses oper-state;

        leaf transaction-mode {
          type enumeration {
            enum start-trans-running {
              description
                "NETCONF devices that support the Tail-f capability
                 http://tail-f.com/ns/netconf/transactions/1.0 and
                 :writable-running.";
            }
            enum lock-reset-candidate {
              description
                "NETCONF devices that support :candidate and
                 :writable-running.";
            }
            enum lock-candidate {
              description
                "NETCONF devices that support :candidate but not
                 :writable-running.";
            }
            enum startup {
              description
                "NETCONF devices with :writable-running and :startup.";
            }
            enum running-only {
              description
                "NETCONF devices with :writable-running only.";
            }
            enum private-candidate {
              description
                "NETCONF devices that support the concept of a private
                 candidate.  There is no standard capability for this,
                 but some devices support it.";
            }
            enum ned {
              tailf:code-name transmode-ned;
              description
                "The transaction is controlled by a Network Equipment
                 Driver.  The exact transaction mode depends on the type
                 of the NED.";
            }
            enum candidate-startup {
              description
                "NETCONF devices with :candidate and :startup.";
            }
          }
          config false;
          description
            "Describes which transaction mode NCS has choosen for
             NETCONF traffic towards the device.";
          tailf:cdb-oper {
            tailf:persistent true;
          }
        }

        leaf last-transaction-id {
          type string;
          config false;
          description
            "If the device supports the tailf-netconf-monitoring module,
             NCS keeps track of this string when reconfiguring a
             device, making it possible to cheeply check if a device
             has been reconfigured out of band.

             This value gets intialized when NCS syncs towards a device,
             and is then subsequently updated with each commit.";

          tailf:cdb-oper {
            tailf:persistent true;
          }
        }
        container last-modules-state {
          config false;
          tailf:cdb-oper {
            tailf:persistent true;
          }
          description
            "If the device supports the ietf-yang-library module, NCS
             stores a copy of the YANG library advertised on the device,
             to avoid reading the module list at every connect.";
          // NOTE: the yang library data is augmented by
          // tailf-ncs-devices-yang-library, in order to avoid having a
          // dependency to ietf-yang-library in this module
        }
        leaf admin-state {
          must "(. = 'call-home' and ../../local-user and "
             + "../../device-type/netconf) or (. != 'call-home')" {
            error-message
              "when admin-state indicates call-home the device-type "
            + "must indicate netconf and the local-user must be set.";
            tailf:dependency "../../local-user";
            tailf:dependency "../../device-type/netconf";
          }
          tailf:info "Controls configuration and southbound communication";
          type admin-state;
          default southbound-locked;
        }
        leaf admin-state-description {
          type string;
          description
            "Reason for the admin state.";
        }
      }
      container source {
        tailf:info "How the device was added to NCS";
        leaf added-by-user {
          type string;
        }
        leaf context {
          type string;
        }
        leaf when {
          type yang:date-and-time;
        }
        leaf from-ip {
          type inet:ip-address;
        }
        leaf source {
          type string;
          reference "TMF518 NRB Network Resource Basics";
        }
      }

      uses capability-module-grouping {
        refine capability {
          tailf:info "A list of capabilities supported by the device";
          config false;
          description
            "This is a list of the capabilities supported by the device.

             This list is populated the first time NCS connects to the
             device.  Not dependent on local-user.

             This list is not populated if the device doesn't
             advertise any known YANG modules, unless it is a NETCONF
             device with ned-id 'tailf-ncs-ned:netconf'.  By setting
             the ned-id to 'tailf-ncs-ned:netconf' it is possible to
             connect to a device, inspect its capabilities, and then pick
             a suitable ned-id based on the capabilities it advertises.

             For a NETCONF device, this list contains all capabilities
             announced in the <hello> message, and all YANG modules
             announced as implemented by the YANG library, if it is
             implemented on the device.";
          tailf:cdb-oper {
            tailf:persistent true;
          }
        }
        refine module {
          config false;
          description
            "This is a list of the YANG modules implemented by the device
             that are also supported by the NED for the device.

             This list is populated the first time NCS connects to the
             device.";
          tailf:cdb-oper {
            tailf:persistent true;
          }
        }
        augment capability {
          tailf:action remove {
            description
              "This action removes a capability from the list of capabilities.
               If leaf module is set then corresponding module is attempted to
               be removed from the list of modules for this device. This action
               is only intended to be used for pre-provisioning: it is not
               possible to override capabilities and modules provided by the
               NED implementation using this action.";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
          }
        }
      }

      tailf:action find-capabilities {
        description
          "This action overwrites existing list of capabilities.

           This action is only intended to be used for
           pre-provisioning: it is not possible to override
           capabilities and modules provided by the NED implementation
           using this action.

           This action populates the list of capabilities based on the
           configured ned-id for the device, if possible.  NCS will
           look up the package corresponding to the ned-id and add all
           the modules from these packages to the list of device
           capabilities and list of modules.  It is the responsibility
           of the caller to verify that the automatically populated
           list of capabilities matches actual device capabilities.
           The list of capabilities can then be fine-tuned using
           add-capability and capability/remove actions.

           Currently this approach works only for CLI and generic
           devices.";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        output {
          leaf result {
            description
              "The result indicates whether any new capabilities have
               been found and saved for this device.";
            type boolean;
          }
        }
      }

      tailf:action add-capability {
        description
          "This action adds a capability to the list of capabilities.

           This action is only intended to be used for
           pre-provisioning.  It is not possible to override
           capabilities and modules provided by the NED implementation
           using this action.

           If a uri is specified, then it is parsed as a YANG
           capability string, and module, revision, feature and
           deviation parameters are derived from the string.

           If a module is specified, then the namespace is looked up
           in the list of loaded namespaces and a capability string is
           constructed automatically.  If a module is specified and
           the attempt to look it up failed, then the action does
           nothing.

           If a module is specified or can be derived from the
           capability string, then the module is also added/replaced
           in the list of modules.";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          choice capability-input {
            mandatory true;
            case capability-uri {
              leaf uri {
                type string;
              }
            }
            case capability-parameters {
              leaf ned-id {
                tailf:non-strict-leafref {
                  path "/devices/ned-ids/ned-id/id";
                }
                type identityref {
                  base ned:ned-id;
                }
              }
              leaf module {
                tailf:non-strict-leafref {
                  path "/devices/ned-ids/ned-id[id = current()/../ned-id]"
                     + "/module/name";
                }
                type string;
                mandatory true;
              }
              leaf revision {
                tailf:non-strict-leafref {
                  path "/devices/ned-ids/ned-id[id = current()/../ned-id]"
                     + "/module[name = current()/../module]/revision";
                }
                type string;
              }
              leaf-list feature {
                type string;
              }
              leaf-list deviation {
                type string;
              }
            }
          }
        }
      }

      container platform {
        config false;
        tailf:cdb-oper {
          tailf:persistent true;
        }
        description
          "Contains vendor-specific information for
           identifying the system platform.

           NEDs MAY augment this container with more device-specific
           nodes.";

        leaf name {
          type string;
          description
            "The name of the system platform, for example,
             'ios', 'ios-xr', or 'open-wrt'.";
        }
        leaf version {
          type string;
          description
            "The current version of the system platform.  The format
             of this string is vendor-specific.";
        }
        leaf model {
          type string;
          description
            "The name of the product model.  For example: if the device
             comes in different types of hardware it may refer to the
             hardware model or if the NED supports several different
             platforms the model may refer to a product family.";
        }
        leaf serial-number {
          type string;
          description
            "Serial number of the device.";
        }
      }

      uses apply-template-grouping;

      tailf:action instantiate-from-other-device {
        description
          "Instantiate the configuration for the device as a copy of the
           configuration of some other already working device.";
        tailf:info "Instantiate the config for the device from existing device";
        tailf:cli-configure-mode;
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf device-name {
            type leafref {
              path "/devices/device/name";
            }
          }
        }
      }

      tailf:action compare-config {
        description
          "Retrieve the config from the device and compare
           to the NCS locally stored copy.

           If the wait-for-lock parameter is not given, the wait-for-lock
           device setting is going to be used.";
        tailf:info "Compare the actual device config with the NCS copy";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf outformat {
            type outformat2;
          }
          uses wait-for-lock;
        }
        output {
          choice compare-result {
            leaf diff {
              type string;
            }
            leaf info {
              type string;
              description
                "If present, contains additional information about the result.";
            }
          }
        }
      }

      tailf:action sync-from {
        description
          "Synchronize the NCS copy of the device configuration by
           reading the actual device configuration. The change will be
           immediately committed to NCS.

           If the wait-for-lock parameter is not given, the wait-for-lock
           device setting is going to be used.";
        tailf:info "Synchronize the config by pulling from the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          container dry-run {
            presence "";
            leaf outformat {
              type outformat2;
              description
                "Report what would be done towards CDB, without
                 actually doing anything.";
            }
          }
          leaf verbose {
            type empty;
            description
              "Use this to show additional parse information if supported
               by the NED.";
          }
          uses wait-for-lock;
        }
        output {
          uses sync-result;
        }
      }

      tailf:action sync-to {
        description
          "Synchronize the device configuration by pushing NCS copy
           to the device.

           NCS pushes a minimal diff to the device. The
           diff is calculated by reading the configuration from the
           device and comparing with the configuration in NCS.

           For a NETCONF device, NCS can optionally replace the
           configuration on the device by sending its own
           configuration without calculating the diff.  Note that NCS
           will send an <edit-config> with the 'replace' option in
           this case.  This means that configuration subtrees that NCS
           does not know about are not replaced.

           If the dry-run option is used, the action simply
           reports (in different formats) what it would do.

           If the wait-for-lock parameter is not given, the wait-for-lock
           device setting is going to be used.";
        tailf:info "Synchronize the config by pushing to the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf mode {
            status deprecated;
            tailf:info "DEPRECATED - use sync-to default behaviour instead";
            type enumeration {
              enum replace;
            }
            description
              "For a NETCONF device, replace the device configurations
               with the NCS configurations, instead of sending the diff.

               Cannot be used with a non-NETCONF device.

               This leaf is deprecated. Use sync-to default behaviour
               instead.";
          }
          container dry-run {
            presence "";
            leaf outformat {
              type outformat3;
              description
                "Report what would be done towards the device, without
                 actually doing anything.";
            }
          }
          uses wait-for-lock;
        }
        output {
          uses sync-to-result;
        }
      }

      tailf:action check-sync {
        description
          "Check if the NCS copy of the device configuration is in sync
           with the actual device configuration, using device-specific
           mechanisms. This operation is usually cheap as it only
           compares a signature of the configuration from the
           device rather than comparing the entire configuration.

           Depending on the device the signature is implemented as a
           transaction-id, timestamp, hash-sum or not at all.
           The capability must be supported by the corresponding
           NED. The output might say unsupported, and then the only way
           to perform this would be to do a full 'compare-config' command.

           As some NEDs implements the signature as an hash-sum
           of the entire configuration, this operation might for
           some devices be just as expensive as performing a full
           compare-config command.

           If the wait-for-lock parameter is not given, the wait-for-lock
           device setting is going to be used.";
        tailf:info "Check if the NCS config is in sync with the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          uses wait-for-lock;
        }
        output {
          uses check-sync-result;
        }
      }

      tailf:action check-yang-modules {
        description
          "Check if the device YANG modules loaded by NCS
           have revisions that are compatible with the ones reported
           by the device.";
        tailf:info "Check if NCS and the device have compatible YANG modules";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf verbose {
            type empty;
            description
              "Use this to show additional compatibility info.";
          }
        }
        output {
          uses check-yang-modules-result;
        }
      }

      tailf:action connect {
        description
          "Set up a session to the unlocked device.";
        tailf:info "Connect to the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf override-southbound-locked {
            type empty;
            description
              "When a device is southbound locked, all southbound
               communication is turned off. This flag overrides the
               southbound lock for connection attempts. Thus, this
               is a way to update the capabilities including revision
               information for a managed device although the device
               is southbound locked.";
          }
        }
        output {
          uses connect-result;
        }
      }

      uses disconnect-grouping-specific;

      tailf:action ping {
        description
          "ICMP ping the device.";
        tailf:info "ICMP ping the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        output {
          leaf result {
            type string;
          }
        }
      }

      tailf:action delete-config {
        description
          "Delete the device configuration in NCS without executing
           the corresponding delete on the managed device.";
        tailf:info "Delete the config in NCS without deleting it on the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf ned-id {
            tailf:info "The NED Identity for which configuration will be
                        deleted";
            type identityref {
              base ned:ned-id;
            }
          }
        }
      }

      tailf:action scp-to {
        description
          "Secure copy file to the device.";
        tailf:info "Secure copy file to the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf local-file {
            tailf:info "Name of the file in the local filesystem.";
            type string;
            mandatory true;
          }
          leaf remote-file {
            tailf:info "Name of the file on the device.";
            type string;
            default ".";
          }
          leaf port {
            tailf:info "Port to connect to on the device";
            type inet:port-number;
            description
              "Specifies the port to connect to on the device.
               If this leaf is not configured, NCS will use the port for the
               management interface of the device.";
          }
          leaf preserve {
            type empty;
            description
              "Preserves modification times, access times, and modes
               from the original file. This is not always supported by the
               device.";
          }
        }
        output {
        }
      }

      tailf:action scp-from {
        description
          "Secure copy file from the device.";
        tailf:info "Secure copy file to the device";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf local-file {
            tailf:info "Name of the file in the local filesystem.";
            type string;
            default ".";
          }
          leaf remote-file {
            tailf:info "Name of the file on the device.";
            type string;
            mandatory true;
          }
          leaf port {
            tailf:info "Port to connect to on the device";
            type inet:port-number;
            description
              "Specifies the port to connect to on the device.
               If this leaf is not configured, NCS will use the port for the
               management interface of the device.";
          }
          leaf preserve {
            type empty;
            description
              "Preserves modification times, access times, and modes
               from the original file. This is not always supported by the
               device.";
          }
        }
        output {
        }
      }

      tailf:action load-native-config {
        tailf:display-when "../device-type/cli or "
          + "../device-type/generic or ../device-type/netconf";
        description
          "Load configuration data in native format into the transaction.
           This action is only applicable for devices with
           NETCONF, CLI and generic NEDs.

           By default the behaviour is to merge the configuration
           that is applied. This can be changed by setting the mode option
           to replace. This will replace the entire device configuration.

           If the action is invoked without a read-write transaction,
           it will automatically create one and commit it.";
        tailf:info "Load configuration data in native format";
        tailf:cli-configure-mode;
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          choice source {
            leaf file {
              type string;
              description
                "Name of file with configuration data in native format
                 in the local filesystem. If the device is remote
                 the file must exists in the local filesystem of the
                 remote node.";
            }
            leaf data {
              type string;
              tailf:cli-multi-line-prompt;
              description
                "Configuration data in native format. If loading
                 XML the data must be a valid XML document,
                 either with a single namespace or wrapped in a
                 config node with the http://tail-f.com/ns/config/1.0
                 namespace.";
            }
            mandatory true;
          }
          leaf mode {
            type enumeration {
              enum merge {
                tailf:code-name load_native_merge;
                description
                  "Merge with the existing device configuration.";
              }
              enum replace {
                tailf:code-name load_native_replace;
                description
                  "Replace the entire device configuration.";
              }
            }
            default merge;
            description
              "Merge or replace the configuration. The default behaviour
               is to merge.";
          }
          leaf verbose {
            type empty;
            description
              "Use this to show additional parse information if supported
               by the NED.";
          }
        }
        output {
          leaf info {
            type string;
            description
              "If present, contains additional information about the result.";
          }
        }
      }

      container config {
        yangmnt:mount-point ncs-device-config;
        tailf:cli-add-mode;
        tailf:cli-expose-ns-prefix;
        tailf:info "NCS copy of the device configuration";
        description
          "This container is used to mount configuration data nodes
           from the device's data models.

           This is where NCS's copy of the device configuration is stored.

           This container defines a mount point as defined in 'YANG
           Schema Mount' (draft-ietf-netmod-schema-mount-10).  This
           means that NCS maintains a config false instantiation of
           the YANG library under this container, which can be read by a
           client to learn the data model (schema) for the device.";
      }

      container live-status {
        yangmnt:mount-point ncs-device-live;
        tailf:info "Status data fetched from the device";
        description
          "This container is used to mount state data nodes from the
           device's data models.

           All data models from the device are mounted as config
           false data.  Thus this container contains both the state
           and running configuration on the device.  Whenever data in
           this tree is accessed, NCS will retrieve data from the
           device in real time.

           The purpose is to expose state data from the managed devices in
           the NCS data tree.

           This container defines a mount point as defined in 'YANG
           Schema Mount' (draft-ietf-netmod-schema-mount-10).  This
           means that NCS maintains a config false instantiation of
           the YANG library under this container, which can be read by a
           client to learn the data model (schema) for the device.";
        tailf:callpoint ncs_live {
          tailf:internal;
        }
        config false;
      }

      container rpc {
        tailf:mount-point ncs-device-rpc;
        tailf:info "RPCs from the device";
        description
          "This container is augmented with top-level rpcs
           from the device's data models.

           The rpcs are augments as tailf:actions.  This makes it possible
           to invoke rpcs on the devices through the NCS data model.";
      }

      container netconf-notifications {
        tailf:info "NETCONF notifications from the device";
        description
          "NETCONF notification support";
        reference "RFC5277 - NETCONF Event Notifications";

        list subscription {
          tailf:info "List of subscriptions";
          key "name";
          description
            "A list of our NETCONF notification subscriptions
             for this managed device.";

          leaf name {
            type string;
            description
              "Each subscription must have a unique name.";
          }

          // This really should be a leafref to ../stream/name but since
          // it's a truly bad idea to have leafrefs to stats data, it's
          // just a string

          leaf stream {
            tailf:info "The notification stream name";
            type string;
            mandatory true;
            description
              "The name of the NETCONF notification stream
               this subscription refers to.";
          }

          choice filter {
            description
              "Optional element, if not set, no filters are applied.";
            case xpath {
              leaf xpath {
                tailf:info "XPath filter for the notifications";
                type yang:xpath1.0;
              }
            }
            case subtree {
              leaf subtree {
                tailf:info "Subtree filter for the notifications";
                type string;
              }
            }
          }

          // add connection interval, interval check if down etc etc

          leaf local-user {
            type string;
            mandatory true;
            description
              "The local user is used when setting up a device
               connection.";
          }

          leaf store-in-cdb {
            tailf:info "Store notifications in CDB";
            type boolean;
            default true;
            description
              "Indicate whether notifications should be stored as
               operational data in CDB.

               When notifications are generated at a high rate,
               storage consumes lots of resources. In cases like that,
               consider using the device-notification event stream
               instead.";
          }

          leaf utilize-replay {
            tailf:info "Use replay when connecting to the device";
            type boolean;
            default true;
            description
              "If the device supports replay, should NCS
               attempt to use that when connecting to the
               device.";
          }

          leaf reconnect-interval {
            tailf:info "Interval for re-establishing the subscription";
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            default 60;
            description
              "If the device is non operational, with which
               interval (in seconds) shall NCS attempt to re-establish
               the subscription.";
          }

          leaf status {
            type enumeration {
              enum running {
                description
                  "The subscription is established and NCS should
                   be receiving NETCONF notifications.";
              }
              enum connecting {
                description
                  "Attempting to establish the subscription.";
              }
              enum failed {
                tailf:code-name 'notif-failed';
                description
                  "The subscription has failed.  Unless the failure is
                   in the connection establishing, i.e., connect()
                   failed, there will be no automatic re-connect.";
              }
            }
            config false;
            default connecting;
            description
              "Is this subscription currently running.";
          }

          leaf failure-reason {
            type enumeration {
              enum connection-refused {
                description
                  "Failed to connect to the device.";
              }
              enum connection-timeout {
                description
                  "Timeout when connecting to the device.";
              }
              enum session {
                description
                  "Failed to establish NETCONF session.";
              }
              enum subscribe {
                description
                  "The device rejected our subscription attempt.";
              }
              enum xml {
                tailf:code-name 'notif-xml';
                description
                  "NCS received XML that could not be parsed.";
              }
              enum internal {
                description
                  "Internal NCS error.";
              }
              enum disconnected {
                description
                  "Manually disconnected.";
              }
              enum closed {
                tailf:code-name 'notif-closed';
                description
                  "Server closed its end.";
              }
              enum not-master {
                status obsolete;
                description
                  "This status is obsolete and will never be reported.
                   The 'read-only' status will be used instead to
                   indicate that the HA node is in slave mode.";
              }
              enum locked {
                tailf:code-name 'notif-locked';
                description
                  "No subscriptions allowed towards devices that are
                   locked or southbound locked.";
              }
              enum auth-failed {
                description
                  "Device authentication failed.";
              }
              enum same-pass {
                tailf:code-name 'notif-same-pass';
                description
                  "Subscription is not allowed when 'same-pass' option is
                   configured for authentication.";
              }
              enum call-home {
                tailf:code-name 'notif-call-home';
                description
                  "Subscription is not allowed until a call
                   home connection has been established.";
              }
              enum read-only {
                tailf:code-name 'notif-read-only';
                description
                  "Subscription is not allowed until read-only
                   mode is disabled and/or the mode of the HA node has
                   changed.";
              }
            }
            config false;
            description
              "If there is a problem with this subscription
               this leaf indicates what the problem is.";
            tailf:callpoint ncs {
              tailf:internal;
            }
          }

          leaf error-info {
            type string;
            config false;
            description
              "Contains additional information, if available, when the
               status is not equal to 'running'.";
            tailf:callpoint ncs {
              tailf:internal;
            }
          }


          tailf:action reconnect {
            tailf:info "Attempt to reconnect this subscription";
            description
              "Attempt to reconnect this subscription.";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
          }

          tailf:action disconnect {
            tailf:info "Disconnect this subscription if connected";
            description
              "Disconnect this subscription if connected.";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
          }

          tailf:action replay {
            tailf:info "Replay (missed) notifications from the device";
            description
              "Ask the device to replay all notifications for this
               subscription.  Optionally if a timestamp is given, all
               notifications newer than the provided timestamp are
               requested.";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
            input  {
              leaf from-date-time {
                type yang:date-and-time;
              }
            }
          }
        }
        list stream {
          key name;
          config false;

          description
            "A list of the NETCONF notification streams
             provided by the device. NCS reads this list in
             realtime.";

          tailf:callpoint ncs {
            tailf:internal;
          }
          leaf name {
            type string;
            description
              "The name of the the stream.";
          }
          leaf description {
            type string;
            description
              "A textual description of the stream.";
          }
          leaf replay-support {
            type boolean;
            description
              "An indication of whether or not event replay
               is available on this stream.";
          }
          leaf replay-log-creation-time {
            type yang:date-and-time;
            description
              "The timestamp of the creation of the log used to support
               the replay function on this stream.  Note that this might
               be earlier then the earliest available notification in the
               log.  This object is updated if the log resets for some
               reason.";
          }
          leaf replay-log-aged-time {
            type yang:date-and-time;
            description
              "The timestamp of the last notification aged out of the log.";
          }
        }

        list notification-name {
          key name;
          config false;

          description
            "List of all names of notifications defined by this device.";

          tailf:callpoint ncs {
            tailf:internal;
          }
          leaf name {
            type string;
            description
              "The XML tag of the notification name.";
          }
          leaf uri {
            type string;
            description
              "The XML namespace uri for this notification.";
          }
        }

        container received-notifications {

          leaf max-size {
            type int32;
            default 200;
            description
              "Max size of the list of received notifications.
               When the maximum size is reached, the oldest
               received notification is purged.";
          }

          leaf clear-time {
            type yang:date-and-time;
            config false;
            tailf:cdb-oper {
              tailf:persistent true;
            }
            description
              "When were notifications last cleared.";
          }

          tailf:action clear {
            description
              "Delete all received notifications from the
               'notification' list.";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
          }

          list notification {
            key "event-time sequence-no";

            config false;
            description
              "A list of received NETCONF notifications from
               the device. The list is a circular list, with a
               maximum size. When a new notification is added to the
               list, the oldest entry is purged.";

            tailf:cdb-oper {
              tailf:persistent true;
            }

            leaf event-time {
              type yang:date-and-time;
              description
                "The time the event was generated at the device.";
            }
            leaf sequence-no {
               type int32;
            }
            leaf user {
              type string;
              description
                "User name of the user that created the subscription
                 that made this notification end up here.";
            }
            leaf subscription {
              type string;
              description
                "The name of the subscription that made this
                 notification end up here.";
            }
            leaf stream {
              type string;
              description
                "The name of the stream this notification belongs to.";
            }
            leaf received-time {
              type yang:date-and-time;
              description
                "The time the event was received at NCS.";
            }

            container data {
              tailf:mount-point ncs-device-notif;
              description
                "This container is automatically augmented with notifications
                 from the managed device. Whenever a device module
                 that contains NETCONF notifications is compiled, the device
                 specific notifications end up here, as a container
                 with the same name as the device notification.";
            }
          }
        }
      }

      leaf-list service-list {
        tailf:info "Show services that use this device";
        type string;
        config false;
        description
          "A list of services that use this device.";
        tailf:callpoint ncs {
          tailf:internal;
        }
      }
    }

    container ned-ids {
      config false;
      tailf:callpoint ncs {
        tailf:internal;
      }
      list ned-id {
        key id;
        tailf:info "List installed NED ids";

        leaf id {
          type identityref {
            base ned:ned-id;
          }
        }
        list module {
          key "name";
          tailf:info "List YANG modules provided by the NED id";

          leaf name {
            type string;
            tailf:info "The module name";
          }
          leaf revision {
            type string;
            tailf:info "The module revision";
          }
          leaf namespace {
            type string;
            tailf:info "The module namespace";
          }
        }
      }
    }

    container commit-queue {
      tailf:info "List of queued and completed commits";
      tailf:display-groups "none details summary";
      config false;
      tailf:cdb-oper {
        tailf:persistent true;
      }

      tailf:action clear {
        description
          "Delete all items in the queue except locks taken by the system.
           This makes all queued devices in the commit queue out of sync.";
        tailf:info "Clear the entire queue";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        output {
          leaf num-deleted-queue-items {
            type uint32;
          }
        }
      }
      tailf:action prune {
        description
          "Prune the portions of all queue items that contain
           any of the devices in the input. This is a useful action to
           run when a device has been taken off-line. When we do that
           we want to ensure that no queue item remain for that
           device, possibly blocking the queue. Devices which are
           currently being committed to will not be pruned, if not
           the 'force' option is used. Atomic queue items will
           not be affected.";
        tailf:info "Prune portions of all queue items in the queue";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf-list device {
            type leafref {
              path "/devices/device/name";
            }
          }
          leaf force {
            type empty;
            description
              "Will brutally kill an ongoing commit. This will most likely
               leave the device in a bad state and could leave traces in the
               error log. It is not recommended in any normal use case.";
          }
        }
        output {
          leaf num-matched-queue-items {
            type uint32;
            description
              "Queue items that contained any of the devices in the input.";
          }
          leaf num-deleted-queue-items {
            type uint32;
            description
              "Queue items that were finally deleted because
               nothing remained.";
          }
        }
      }
      tailf:action set-atomic-behaviour {
        description
          "Sets the atomic behaviour of all queue items.
           If these are set to false, the devices contained in these
           queue items can start executing if the same devices in
           other non-atomic queue items ahead of it in the queue are
           completed. If set to true, the atomic integrity of these
           queue items are preserved.";
        tailf:info "Set the atomic behaviour of all queue items";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf atomic {
            type boolean;
            mandatory true;
          }
        }
        output {
          leaf num-affected-queue-items {
            type uint32;
            description
              "Queue items that have changed atomic behaviour.";
          }
        }
      }
      tailf:action wait-until-empty {
        description
          "Wait at most 'timeout' seconds for the commit queue
           to become empty. Useful action when we script towards
           NCS, usually combined with locking NCS exclusively.

           If no parameter is given, the action waits indefinitely.";
        tailf:info "Wait for the commit queue to become empty";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          choice timeout-choice {
            default infinity;
            leaf timeout {
              type uint32 {
                range "0..4294967";
              }
              units "seconds";
            }
            leaf infinity {
              type empty;
            }
          }
        }
        output {
          leaf result {
            type enumeration {
              enum empty {
                description
                  "Returned if the queue is empty.";
              }
              enum timeout {
                description
                  "Returned if the timer expired before the queue became
                   empty.";
                tailf:code-name wait_timeout;
              }
            }
          }
        }
      }
      tailf:action add-lock {
        description
          "Add a locked queue item to the commit queue.";

        tailf:info "Add a lock for devices in the queue";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf tag {
            type string;
            description
              "User defined opaque tag.
               The tag is present in all notifications and events
               sent referencing the specific queue item.";
          }
          uses commit-queue-basic-options {
            refine "operation-mode/async/async" {
              description
                "Add the lock asynchronously to the commit queue";
            }
            refine "operation-mode/sync/sync" {
              description
                "Add the lock synchronously. Block until the lock
                 has been successfully placed in the commit queue and
                 no other queue items, using any of the devices, are
                 ahead in the queue.";
            }
            refine "operation-mode/sync/sync/timeout-choice/timeout" {
              description
                "Wait for the specified number of seconds for the lock
                 to be placed in the queue. If no timeout is set,
                 the action waits indefinitely.";
            }
          }
          leaf block-others {
            type empty;
            description
              "The lock will block other items, using any of the devices
               in the lock, to enter the commit queue.";
          }
          leaf-list device {
            type string;
            tailf:non-strict-leafref {
              path "/devices/device/name";
            }
            min-elements 1;
          }
        }
        output {
          leaf commit-queue-id {
            type uint64;
            description
              "The operation was successful, the lock is now in place.
               To unlock the queue item see the action
               /devices/commit-queue/queue-item/unlock.";
          }
          leaf result {
            type enumeration {
              enum timeout {
                tailf:code-name cq_add_lock_timeout;
                description
                  "A timeout occurred, the lock is not in place, the
                   operation was not successful.";
              }
              enum failed {
                tailf:code-name cq_add_lock_failed;
                description
                  "The queue item was manually unlocked or deleted, the
                   devices are not locked, the operation was not
                   successful";
              }
            }
          }
        }
      }
      list queue-item {
        tailf:display-groups "none details summary";
        tailf:info "An item in the commit queue";
        tailf:callpoint ncs {
          tailf:internal;
        }
        key id;
        leaf id {
          type uint64;
          description
            "Unique id identifying a queue item.";
        }
        leaf tag {
          type string;
          description
            "Opaque string set at commit time. The 'tag' will be present in
             progress events sent about a queue item.";
        }
        leaf age {
          tailf:display-groups "none details summary";
          type uint32;
          units "seconds";
          description
            "The age in seconds of this queue item. How long time
             has this item been in the queue.";
        }
        uses queue-item-status;
        leaf-list devices {
          tailf:display-groups "none details summary";
          type leafref {
            path "/devices/device/name";
          }
          description
            "The names of the devices that are part of this queue
             item.";
        }
        leaf-list services {
          tailf:display-groups "details";
          description
            "The service instances that are part of this queue item.";
          type string;
        }
        leaf-list waiting-for {
          tailf:display-groups "none details summary";
          type leafref {
            path "/devices/device/name";
          }
          description
            "If this queue item's status is 'waiting', 'blocked' or
             'locked', this leaf-list contains the devices the queue
             item is waiting for in order to execute.";
        }
        leaf-list transient-errors {
          tailf:display-groups "none details summary";
          type leafref {
            path "/devices/device/name";
          }
          description
            "This leaf-list contains devices with transient errors,
             e.g., connection problems or a locked device.  These
             devices can possibly block other queue items from being
             processed.";
        }
        leaf-list completed {
          tailf:display-groups "none details";
          type leafref {
            path "/devices/device/name";
          }
          description
            "The devices which were completed for this queue item.
             A device is completed when its device modifications
             are pushed to the network.";
        }
        list failed {
          tailf:code-name failedx;
          key "name";
          leaf name {
            type leafref {
              path "/devices/device/name";
            }
          }
          leaf reason {
            type string;
            description
              "The error for this failing device.";
          }
          description
            "The devices which are failed for this queue item.";
        }
        list remote-queue-item {
          key "node";
          leaf node {
            type leafref {
              path "/cluster/remote-node/name";
            }
            description
              "Parts of the queue-item has been distributed to this node.
               This is only present when using clusters.";
          }
          leaf id {
            type uint64;
            description
              "The is the id of the queue-item on the remote node.";
          }
        }
        leaf is-atomic {
          tailf:display-groups "none details";
          type boolean;
          description
            "Whether the queue item runs atomic or not.";
        }
        list modification {
          tailf:display-groups "details";
          key device;
          description
            "A detailed view of the queued modifications.";
          leaf device {
            type leafref {
              path "/devices/device/name";
            }
            description
              "Name of the device.";
          }
          leaf data {
            tailf:display-groups "details";
            type string;
            description
              "Textual description of data queued to be sent.";
            tailf:cli-preformatted;
          }
          leaf local-user {
            tailf:display-groups "details";
            type string;
            description
              "Name of local NCS user that commited this data.";
          }
        }
        tailf:action delete {
          description
            "Delete this queue item. This will make the devices out-of-sync
             with NCS since the devices will never receive the configuration
             changes committed to NCS. Locks taken by the system will not be
             deleted by default, unless pending (not yet granted).";
          tailf:info "Delete this queue item";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
          input {
            leaf force {
              type empty;
              description
                "Will brutally kill an ongoing commit. This will most likely
                 leave the device in a bad state and could leave traces in the
                 error log. If used on a sentinel, it allows to delete a lock
                 taken by the system, however deleting such a lock will result
                 in unpredictable behaviour since actions that are normally
                 not allowed to run in parallel will be able to do that.
                 It is not recommended in any normal use case.";
            }
          }
        }
        tailf:action lock {
          description
            "Put a lock on this queue item. This can only be performed
             when the queue item has status 'waiting' or 'blocked'.
             A lock can also be placed on a queue-item at commit time
             through the commit parameter 'commit-queue/lock'.";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
        }
        tailf:action unlock {
          description
            "Unlock this queue item. For a queue item with status 'locked'
             the status will change to 'waiting', for all other statuses this
             action is ignored.";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
          input {
            leaf atomic {
              tailf:hidden full;
              type boolean;
            }
          }
        }
        tailf:action prune {
          description
            "Prune a queue item that contain any of the devices in
             the input. The devices will be removed from the queue item.
             If no devices remain the queue item will be deleted.
             If the queue item was part of a service transaction the
             service will be flagged as failed. Devices which are
             currently being committed to will not be pruned, if not
             the 'force' option is used. Atomic queue items will
             not be affected.";
          tailf:info "Prune a queue item";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
          input {
            leaf-list device {
              type leafref {
                path "/devices/device/name";
              }
            }
            leaf force {
              type empty;
              description
                "Will brutally kill an ongoing commit. This will most likely
                 leave the device in a bad state and could leave traces in the
                 error log. It is not recommended in any normal use case.";
            }
          }
        }
        tailf:action set-atomic-behaviour {
          description
            "Sets the atomic behaviour of this queue item.
             If this is set to false, the devices contained in this
             queue item can start executing if the same devices in
             other non-atomic queue items ahead of it in the queue are
             completed. If set to true, the atomic integrity of the
             queue item is preserved.";
          tailf:info "Set the atomic behaviour of this queue item";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
          input {
            leaf atomic {
              type boolean;
              mandatory true;
            }
          }
        }
        tailf:action wait-until-completed {
          description
            "Wait at most 'timeout' seconds for the queue item
             to be completed. Useful action when we script towards NCS.

             If no parameter is given, the action waits indefinitely.";
          tailf:info "Wait for the queue item to be completed";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
          input {
            choice timeout-choice {
              default infinity;
              leaf timeout {
                type uint32 {
                  range "0..4294967";
                }
                units "seconds";
              }
              leaf infinity {
                type empty;
              }
            }
          }
          output {
            leaf result {
              type enumeration {
                enum completed {
                  description
                    "The queue item was successfully completed.";
                  tailf:code-name wait_cq_completed;
                }
                enum timeout {
                  description
                    "The timer expired before the queue item was completed.";
                  tailf:code-name wait_cq_timeout;
                }
                enum failed {
                  description
                    "The queue item failed.";
                  tailf:code-name wait_cq_failed;
                }
                enum deleted {
                  description
                    "The queue item was deleted from the queue.";
                  tailf:code-name wait_cq_deleted;
                }
              }
            }
          }
        }
      }

      container completed {
        tailf:info "List of completed commits";
        tailf:display-groups "details summary";

        tailf:action purge {
          tailf:info "Remove completed queue items";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
          description
            "This action requests to delete items from the queue-item
             list according to the supplied criteria.";
          input {
            uses commit-queue-item-status;
            container older-than {
              presence "Age specification";
              description
                "Matches the 'when' leaf in the queue item.";
              choice age-spec {
                case seconds {
                  leaf seconds {
                    type uint16;
                  }
                }
                case minutes {
                  leaf minutes {
                    type uint16;
                  }
                }
                case hours {
                  leaf hours {
                    type uint16;
                  }
                }
                case days {
                  leaf days {
                    type uint16;
                  }
                }
                case weeks {
                  leaf weeks {
                    type uint16;
                  }
                }
              }
            }
          }
          output {
            leaf num-deleted-queue-items {
              type uint32;
              description
                "Queue items that were deleted.";
            }
          }
        }

        list queue-item {
          tailf:display-groups "none details summary";
          tailf:info "A completed item from the commit queue";
          key id;
          leaf id {
            type uint64;
            description
              "Unique id identifying a queue item.";
          }
          leaf tag {
            type string;
            description
              "Opaque string set at commit time.";
          }
          leaf when {
            type yang:date-and-time;
            description
              "When the queue item was completed.";
          }
          uses commit-queue-item-status;
          leaf-list devices {
            type string;
            tailf:non-strict-leafref {
              path "/devices/device/name";
            }
            description
              "The names of the devices that was part of this queue
               item.";
          }
          leaf-list completed {
            type string;
            tailf:non-strict-leafref {
              path "/devices/device/name";
            }
            description
              "The devices which were completed for this queue item.
               A device is completed when its device modifications
               are pushed to the network.";
          }
          list failed {
            tailf:code-name failedx;
            key "name";
            leaf name {
              type string;
              tailf:non-strict-leafref {
                path "/devices/device/name";
              }
            }
            leaf reason {
              type string;
              description
                "The error for this failing device.";
            }
            description
              "The devices which failed for this queue item.";
          }
          leaf-list completed-services {
            description
              "The services that have been completed. A service has
               completed if all its device modifications have been
               successfully completed.";
            type string;
          }
          leaf-list failed-services {
            description
              "The services that have failed. A service has failed
               if any of its device modifications have failed.";
            type string;
          }
          list remote-queue-item {
            tailf:hidden full;
            key "name";
            leaf name {
              type string;
              tailf:non-strict-leafref {
                path "/devices/device/name";
              }
              description
                "Parts of the queue-item has been distributed to this
                 LSA device.";
            }
            leaf id {
              type uint64;
              description
                "The is the id of the queue-item used on the remote device.";
            }
          }
          leaf reverse-chgset {
            tailf:hidden full;
            type binary;
          }
          leaf rollback-data {
            tailf:display-groups "details";
            tailf:cli-preformatted;
            tailf:callpoint ncs {
              tailf:internal;
            }
            description
              "The reverse of the original configuration data which
               resulted in this commit queue item.";
            type string;
          }
          tailf:action rollback {
            tailf:display-when "../reverse-chgset";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
            description
              "Rollback the original configuration data. This is the
               reverse of the output of original-data.";
            input {
              container dry-run {
                presence "";
                leaf outformat {
                  type outformat3;
                }
              }
              leaf no-out-of-sync-check {
                type empty;
                description
                  "Continue with the transaction even if NCS detects that
                   a device's configuration is out of sync. The device's
                   sync state is assumed to be unknown after such commit
                   and the stored transaction id value is cleared";
              }
              container commit-queue {
                presence "Commit through the commit queue";
                uses commit-queue-options;
              }
            }
            output {
              choice outformat {
                case case-xml {
                  uses dry-run-xml;
                }
                case case-cli {
                  uses dry-run-cli;
                }
                case case-native {
                  uses dry-run-native;
                }
              }
              uses ncs-commit-result;
            }
          }
          tailf:action delete {
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
            description
              "Delete this queue item.";
          }
        }
      }

      list device-chgset {
        tailf:hidden full;
        key device;
        description
          "Hidden NCS private data used by the commit queue.";

        tailf:cdb-oper {
          tailf:persistent true;
        }
        leaf device {
          type leafref {
            path "/devices/device/name";
          }
        }
        list chgset {
          key id;
          description
            "A queue of device changesets to be applied to the
             snapshot database. When applied the snapshot database
             and the changeset represents running and pre-commit
             running at a particular point in time.";
          leaf id {
            type uint64;
            description
              "Unique id for the changeset.";
          }
          leaf when {
            type yang:date-and-time;
            description
              "When the changeset was added.";
          }
          leaf cq-id {
            type leafref {
              path "/devices/commit-queue/qitem/cq-id";
            }
            description
              "To what queue item the changeset belongs, if any.";
          }
          leaf chgset {
            type binary;
            description
              "A snapshot of pre-commit running for a device.";
          }
        }
      }

      list qitem {
        tailf:hidden full;
        key cq-id;
        description
          "Hidden NCS private data used by the commit queue.";
        tailf:cdb-oper {
          tailf:persistent true;
        }
        leaf cq-id {
          type uint64;
        }
        leaf cq-tag {
          type string;
          description
            "The tag of the commit";
        }
        leaf cq-username {
          type string;
        }
        leaf cq-locked {
          type boolean;
        }
        leaf cq-block-others {
          type boolean;
        }
        leaf cq-atomic {
          type boolean;
        }
        leaf cq-sentinel {
          type boolean;
        }
        leaf cq-data {
          type binary;
          description
            "Persistent representation of a queue-item.";
        }
        leaf cq-reverse-diffset {
          type binary;
          description
            "Persistent representation of the rollback changeset.";
        }
        list cq-completed {
          key dev;
          description
            "Which local and remote devices in this qitem are completed.";
          leaf dev {
            type string;
          }
        }
        list cq-failed {
          key dev;
          description
            "Which local and remote devices in this qitem has failed.";
          leaf dev {
            type string;
          }
          leaf reason {
            type string;
            description
              "A string representing the error for this failing device.";
          }
        }
        list cq-pending {
          key dev;
          leaf dev {
            type string;
          }
          leaf cq-id {
            type uint64;
          }
        }
        list cq-remote {
          key dev;
          leaf dev {
            type string;
          }
          leaf cq-id {
            type uint64;
          }
        }
      }
    }

    container session-pool {
      tailf:info "List of pooled NED sessions";
      tailf:display-groups "none details summary";
      config false;

      tailf:action close {
        description
          "Close all sessions in the session pool.";
        tailf:info "Close all sessions in the session pool";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
      }

      list pooled-device {
        tailf:display-groups "none details summary";
        tailf:info "A pooled device in the session pool";
        tailf:callpoint ncs {
          tailf:internal;
        }
        key device;
        leaf device {
          type leafref {
            path "/devices/device/name";
          }
          description
            "Name of the device.";
        }
        leaf device-type {
          type string;
          description
            "Device type";
        }
        leaf sessions {
          type uint32;
          description
            "Number of pooled sessions";
        }
        leaf max-sessions {
          type string;
          description
            "Max sessions in pool for this device.";
        }
        leaf idle-time {
          type uint32;
          description
            "The maximum idle-time for sessions in pool for this device.";
        }

        tailf:action close {
          description
            "Close all pooled sessions in the session pool
            for this device.";
          tailf:info "Close pooled sessions for this device";
          tailf:actionpoint ncsinternal {
            tailf:internal;
          }
        }
      }
    }
  }

  notification ncs-commit-queue-progress-event {
    description
      "Generated for state changes in the internal NCS commit queue.";
    leaf id {
      type leafref {
        path "/devices/commit-queue/queue-item/id";
      }
      description
        "This value represents the queue item id in the commit queue.
         The leafref is valid in the NCS which produced the event.";
    }
    leaf tag {
      type leafref {
        path "/devices/commit-queue/queue-item/tag";
      }
      description
        "Opaque tag set in the commit. The leafref is valid in the NCS which
         produced the event.";
    }
    leaf state {
      type enumeration {
        enum waiting {
          description
            "The queue item is waiting to run. This state means
             that there is some other item in the queue, ahead of this item.";
          tailf:code-name 'cq_event_waiting';
        }
        enum executing {
          description
            "The queue item is currently executing at the
             head of the commit queue.

             Still transient error can have occured when NCS tried to
             communicate with some of the devices. Such errors are
             shown in the transient-errors leaf-list.
             NCS will try to push down the changes after some time, as set in
             /devices/global-settings/commit-queue/
             connection-failure-reconnect-timer.

             Examples of transient errors are connection failures
             and that the changes are rejected due to the device
             being locked.

             Having transient errors are potentially bad, since the queue might
             grow if new items are added, waiting for the same device.";
          tailf:code-name 'cq_event_executing';
        }
        enum locked {
          description
            "This queue item has been locked and waits to be unlocked.

             In a NCS cluster this is used as a synchronization mechanism
             between the different NCSes taking part in a transaction.";
          tailf:code-name 'cq_event_locked';
        }
        enum completed {
          description
          "The queue item was successfully completed.";
          tailf:code-name 'cq_event_completed';
        }
        enum failed {
          description
            "The queue item ended with a failing status.";
          tailf:code-name 'cq_event_failed';
        }
        enum deleted {
          description
            "The queue item was deleted from the queue.";
          tailf:code-name 'cq_event_deleted';
        }
      }
    }
    list completed-services {
      description
        "For a notification with state 'completed' or 'failed'
         this list contains all services that have been completed.
         A service has completed if all its device modifications
         have been successfully completed. ";
      key name;
      leaf name {
        type string;
      }
      leaf-list completed-devices {
        description
          "This leaf-list contains all completed devices for this service.
           A device is completed when its device modifications are pushed
           to the network.";
        type leafref {
          path "/devices/device/name";
        }
      }
    }
    list failed-services {
      description
        "For a notification with state 'completed' or 'failed'
         this list contains all services that have failed.
         A service has failed if any of its device modifications
         have failed. ";
      key name;
      leaf name {
        type string;
      }
      leaf-list completed-devices {
        description
          "This leaf-list contains all completed devices for this service.
           A device is completed when its device modifications are pushed
           to the network.";
        type leafref {
          path "/devices/device/name";
        }
      }
      leaf-list failed-devices {
        description
          "This leaf-list contains all devices which failed
           in the commit queue for this service.";
        type leafref {
          path "/devices/device/name";
        }
      }
    }
    list completed-devices {
      key name;
      description
        "In the case of 'executing' notification type. This list contains the
         devices that has successfully finished since the previous executing
         notification for this commit queue item.";
      leaf name {
        type leafref {
          path "/devices/device/name";
        }
        description
          "The name of a completed device.";
      }
    }
    list transient-devices {
      key name;
      description
        "In the case of a 'executing' notification, this list contains the
         devices for which a transient (temporary) error has occured.
         This list will be empty for all other notification types.";
      leaf name {
        type leafref {
          path "/devices/device/name";
        }
        description
          "The name of a transient device.";
      }
    }
    list failed-devices {
      key name;
      description
        "In the case of a 'executing' notification, this list contains all the
         currently known failed devices.
         For a 'failed' notification this list contains all failed devices.
         In the case of a 'deleted' notification that is emitted as a result of
         a prune action this list will contain the devices that are deleted.
         This list is empty in all other cases.";
      leaf name {
        type leafref {
          path "/devices/device/name";
        }
        description
          "The name of a failed device.";
      }
      leaf reason {
        type string;
        description
          "A string representing the error for this failing device.";
      }
    }
  }
}
