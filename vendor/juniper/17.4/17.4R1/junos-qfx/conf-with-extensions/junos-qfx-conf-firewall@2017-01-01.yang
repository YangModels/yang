/*
 * Copyright (c) 2017 Juniper Networks, Inc.
 * All rights reserved.
 */
 module junos-qfx-conf-firewall {
   namespace "http://yang.juniper.net/junos-qfx/conf/firewall";

   prefix jc-firewall;

   import junos-common-ddl-extensions {
     prefix junos;
   }

   import junos-common-types {
     prefix jt;
   }

   import junos-qfx-conf-root {
     prefix jc;
   }

   organization "Juniper Networks, Inc.";

   contact "yang-support@juniper.net";

   description "Junos firewall configuration module";

   revision 2017-01-01 {
     description "Junos: 17.4R1.16";
   }

   augment /jc:configuration {
     uses firewall-group;
   }
   augment /jc:configuration/jc:groups {
     uses firewall-group;
   }
   grouping firewall-group {
     container firewall {
       description "Define a firewall configuration";
       uses apply-advanced;
       container family {
         description "Protocol family";
         container inet {
           description "Protocol family IPv4 for firewall filter";
           uses apply-advanced;
           list dialer-filter {
             key name;
             ordered-by user;
             description "Define an IPv4 dialer filter";
             uses inet_dialer_filter;
           }
           list prefix-action {
             key name;
             ordered-by user;
             description "Define a prefix action";
             uses prefix_action;
           }
           list filter {
             key name;
             ordered-by user;
             description "Define an IPv4 firewall filter";
             uses inet_filter;
           }
           list template {
             key name;
             ordered-by user;
             description "Define an Inet firewall template";
             uses inet_template;
           }
           list service-filter {
             key name;
             ordered-by user;
             description "One or more IPv4 service filters";
             uses inet_service_filter;
           }
           list fast-update-filter {
             key name;
             ordered-by user;
             description "One or more fast update filters";
             uses inet_fuf;
           }
         }
         container inet6 {
           description "Protocol family IPv6 for firewall filter";
           uses apply-advanced;
           list filter {
             key name;
             ordered-by user;
             description "Define an IPv6 firewall filter";
             uses inet6_filter;
           }
           list service-filter {
             key name;
             ordered-by user;
             description "One or more IPv6 service filters";
             uses inet6_service_filter;
           }
           list fast-update-filter {
             key name;
             ordered-by user;
             description "One or more fast update filters";
             uses inet6_fuf;
           }
           list template {
             key name;
             ordered-by user;
             description "Define an Inet6 firewall template";
             uses inet6_template;
           }
         }
         container mpls {
           description "Protocol family MPLS for firewall filter";
           uses apply-advanced;
           list filter {
             key name;
             ordered-by user;
             uses mpls_filter;
           }
           list template {
             key name;
             ordered-by user;
             description "Define an MPLS firewall template";
             uses mpls_template;
           }
         }
         container vpls {
           description "Protocol family VPLS for firewall filter";
           uses apply-advanced;
           list filter {
             key name;
             ordered-by user;
             uses vpls_filter;
           }
         }
         container evpn {
           description "Protocol family EVPN for firewall filter";
           uses apply-advanced;
           list filter {
             key name;
             ordered-by user;
             uses vpls_filter;
           }
         }
         container bridge {
           description "Protocol family BRIDGE for firewall filter";
           uses apply-advanced;
           list filter {
             key name;
             ordered-by user;
             uses bridge_filter;
           }
         }
         container ccc {
           description "Protocol family CCC for firewall filter";
           uses apply-advanced;
           list filter {
             key name;
             ordered-by user;
             uses ccc_filter;
           }
         }
         container any {
           description "Protocol-independent filter";
           uses apply-advanced;
           list filter {
             key name;
             ordered-by user;
             description "Define a protocol independent filter";
             uses any_filter;
           }
           list template {
             key name;
             ordered-by user;
             description "Define Protocol independent filter template";
             uses any_template;
           }
         }
         container ethernet-switching {
           description "Protocol family Ethernet Switching for firewall filter";
           uses apply-advanced;
           list filter {
             key name;
             ordered-by user;
             description "Define an Ethernet Switching firewall filter";
             uses es_filter;
           }
           list template {
             key name;
             ordered-by user;
             description "Define an ethernet switching firewall template";
             uses es_template;
           }
         }
       }
       list policer {
         key name;
         ordered-by user;
         description "Policer template definition";
         uses firewall_policer;
       }
       list flexible-match {
         key name;
         ordered-by user;
         description "Flexible packet match template definition";
         uses firewall_flexible_match;
       }
       list tunnel-end-point {
         key name;
         ordered-by user;
         description "Tunnel end-point template definition";
         uses tunnel_end_point;
       }
       list interface-set {
         key name;
         ordered-by user;
         description "Interface set definition";
         uses interface_set_type;
       }
       list three-color-policer {
         key name;
         ordered-by user;
         description "Three-color policer";
         junos:must "(!(\".. loss-priority\"))";
         junos:must-message "cannot support three-color-policer action if loss-priority is configured";
         uses three-color-policer-type;
       }
       list filter {
         key name;
         ordered-by user;
         description "Define an IPv4 firewall filter";
         uses inet_filter;
       }
     }
   }
   grouping any_filter {
     leaf name {
       description "Filter name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     list term {
       key name;
       ordered-by user;
       description "Define a firewall term";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       container from {
         description "Define match criteria";
         uses apply-advanced;
         list interface {
           key name;
           ordered-by user;
           description "Match interface name";
           uses match_interface_object_oam;
         }
         list interface-set {
           key name;
           ordered-by user;
           description "Match interface in set";
           uses match_interface_set_object;
         }
         choice packet-length_choice {
           case case_1 {
             leaf-list packet-length {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f])(-([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f]))?$";
                 junos:pattern-message "Must be a numeric value or a range between 0-65535";
               }
             }
           }
           case case_2 {
             leaf-list packet-length-except {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f])(-([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f]))?$";
                 junos:pattern-message "Must be a numeric value or a range between 0-65535";
               }
             }
           }
         }
         choice forwarding-class_choice {
           case case_1 {
             leaf-list forwarding-class {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list forwarding-class-except {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
         }
         choice loss-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list loss-priority-except {
               type enumeration {
                 enum "low" {
                   description "Loss priority low";
                 }
                 enum "high" {
                   description "Loss priority high";
                 }
                 enum "medium-low" {
                   description "Loss priority medium-low";
                 }
                 enum "medium-high" {
                   description "Loss priority medium-high";
                 }
               }
             }
           }
         }
         choice policy-map_choice {
           case case_1 {
             leaf-list policy-map {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list policy-map-except {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         choice policer-choice {
           case case_1 {
             leaf policer {
               description "Name of policer to use to rate-limit traffic";
               junos:must "(!(\"firewall policer $$ aggregate\"))";
               junos:must-message "Cannot attach a aggregate policer to filter";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             container three-color-policer {
               junos:must "(!(\".. loss-priority\"))";
               junos:must-message "cannot support three-color-policer action if loss-priority is configured";
               description "Police the packet using a three-color-policer";
               uses apply-advanced;
               choice type-choice {
                 case case_1 {
                   leaf single-rate {
                     description "Name of single-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-rate\")";
                     junos:must-message "Referenced single-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_2 {
                   leaf single-packet-rate {
                     description "Name of single-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-packet-rate\")";
                     junos:must-message "Referenced single-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_3 {
                   leaf two-rate {
                     description "Name of two-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-rate\")";
                     junos:must-message "Referenced two-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_4 {
                   leaf two-packet-rate {
                     description "Name of two-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-packet-rate\")";
                     junos:must-message "Referenced two-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
               }
             }
           }
           case case_3 {
           }
         }
         choice policy-map-choice {
           case case_1 {
             leaf clear-policy-map {
               description "Clear the policy marking";
               type empty;
             }
           }
           case case_2 {
             leaf policy-map {
               description "Policy map action";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "referenced policy map must be defined";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         leaf count {
           description "Count the packet in the named counter";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf service-accounting {
           description "Count the packets for service accounting";
           junos:must "(!(\".. service-accounting-deferred\"))";
           junos:must-message "'service-accounting-deferred' and 'service-accounting' cannot coexist";
           junos:must "(!(\".. count\"))";
           junos:must-message "'count' and 'service-accounting' cannot coexist";
           type empty;
         }
         leaf service-accounting-deferred {
           description "Count the packets for deferred service accounting";
           junos:must "(!(\".. service-accounting\"))";
           junos:must-message "Cannot be both 'service-accounting' and 'service-accounting-deferred'";
           junos:must "(!(\".. count\"))";
           junos:must-message "'count' and 'service-accounting-deferred' cannot coexist";
           type empty;
         }
         leaf loss-priority {
           description "Classify packet to loss-priority";
           type enumeration {
             enum "low" {
               description "Loss priority low";
             }
             enum "high" {
               description "Loss priority high";
             }
             enum "medium-low" {
               description "Loss priority medium-low";
             }
             enum "medium-high" {
               description "Loss priority medium-high";
             }
           }
         }
         leaf forwarding-class {
           description "Classify packet to forwarding class";
           type string {
             junos:posix-pattern "^.{1,64}$";
             junos:pattern-message "Must be string of 64 characters or less";
           }
         }
         choice designation {
           case case_1 {
           }
           case case_2 {
             leaf accept {
               description "Accept the packet";
               type empty;
             }
           }
           case case_3 {
             leaf discard {
               description "Discard the packet";
               type empty;
             }
           }
           case case_4 {
             leaf next {
               description "Continue to next term in a filter";
               type enumeration {
                 enum "term" {
                   description "Continue to next term in a filter";
                 }
               }
             }
           }
         }
       }
       container template {
         description "Refer a template";
         uses apply-advanced;
         leaf template-name {
           description "Template name";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
       }
     }
   }
   grouping any_template {
     leaf name {
       description "Template name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     container attributes {
       description "Template attributes";
       uses apply-advanced;
       leaf forwarding-class {
         description "Match forwarding class";
         type empty;
       }
       leaf forwarding-class-except {
         description "Do not match forwarding class";
         type empty;
       }
       leaf interface {
         description "Match interface name";
         type empty;
       }
       leaf interface-set {
         description "Match interface in set";
         type empty;
       }
       leaf loss-priority {
         description "Match Loss Priority";
         type empty;
       }
       leaf loss-priority-except {
         description "Do not match Loss Priority";
         type empty;
       }
       leaf packet-length {
         description "Match packet length";
         type empty;
       }
       leaf packet-length-except {
         description "Do not match packet length";
         type empty;
       }
     }
   }
   grouping apply-advanced {
     description "Apply advanced configuration logic";
     leaf-list apply-groups {
       description "Groups from which to inherit configuration data";
       type string;
     }
     leaf-list apply-groups-except {
       description "Don't inherit configuration data from these groups";
       type string;
     }
     list apply-macro {
       key name;
       ordered-by user;
       description "Macro and parameters for commit script expansion";
       uses apply-macro-type;
     }
   }
   grouping apply-macro-type {
     description "Macro data for commit-script expansion";
     leaf name {
       description "Name of the macro to be expanded";
       type string;
     }
     list data {
       key name;
       uses macro-data-type;
     }
   }
   grouping bridge_filter {
     description "Define a BRIDGE firewall filter";
     leaf name {
       description "Filter name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf-list accounting-profile {
       description "Accounting profile name";
       junos:must "(\"accounting-options filter-profile\")";
       junos:must-message "referenced accounting profile must be defined";
       type string;
     }
     leaf interface-specific {
       description "Defined counters are interface specific";
       type empty;
     }
     list term {
       key name;
       ordered-by user;
       description "Define a firewall term";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       leaf filter {
         description "Filter to include";
         junos:must "(\"firewall family bridge filter $$\")";
         junos:must-message "Referenced filter is not defined";
         junos:must "((!(\".. from\") && !(\".. then\")))";
         junos:must-message "Not compatible with 'from or then'";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       container from {
         description "Define match criteria";
         uses apply-advanced;
         choice interface-group_choice {
           case case_1 {
             leaf-list interface-group {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list interface-group-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice ether-type_choice {
           case case_1 {
             leaf-list ether-type {
               type string;
             }
           }
           case case_2 {
             leaf-list ether-type-except {
               type string;
             }
           }
         }
         choice vlan-ether-type_choice {
           case case_1 {
             leaf-list vlan-ether-type {
               type string;
             }
           }
           case case_2 {
             leaf-list vlan-ether-type-except {
               type string;
             }
           }
         }
         list destination-mac-address {
           key name;
           ordered-by user;
           description "Destination MAC address";
           uses firewall_mac_addr_object;
         }
         list source-mac-address {
           key name;
           ordered-by user;
           description "Source MAC address";
           uses firewall_mac_addr_object;
         }
         choice forwarding-class_choice {
           case case_1 {
             leaf-list forwarding-class {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list forwarding-class-except {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
         }
         choice loss-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list loss-priority-except {
               type enumeration {
                 enum "low" {
                   description "Loss priority low";
                 }
                 enum "high" {
                   description "Loss priority high";
                 }
                 enum "medium-low" {
                   description "Loss priority medium-low";
                 }
                 enum "medium-high" {
                   description "Loss priority medium-high";
                 }
               }
             }
           }
         }
         choice learn-vlan-id_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list learn-vlan-id-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice learn-vlan-1p-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list learn-vlan-1p-priority-except {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
         }
         choice user-vlan-id_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list user-vlan-id-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice user-vlan-1p-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list user-vlan-1p-priority-except {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
         }
         choice learn-vlan-dei_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list learn-vlan-dei-except {
               description "DEI value 0-1";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 1";
                 }
               }
             }
           }
         }
         choice traffic-type_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list traffic-type-except {
               type enumeration {
                 enum "broadcast" {
                   description "Packets with broadcast ethernet address";
                 }
                 enum "multicast" {
                   description "Packets with multicast ethernet address";
                 }
                 enum "unknown-unicast" {
                   description "Packets for which destination ethernet address has not been learnt";
                 }
                 enum "known-unicast" {
                   description "Packets for which destination ethernet address has been learnt";
                 }
               }
             }
           }
         }
         choice ip-protocol_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ip-protocol-except {
               type string;
             }
           }
         }
         choice dscp_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list dscp-except {
               type string;
             }
           }
         }
         choice ip-precedence_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ip-precedence-except {
               type string;
             }
           }
         }
         choice source-port_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list source-port-except {
               type string;
             }
           }
         }
         choice destination-port_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list destination-port-except {
               type string;
             }
           }
         }
         choice port_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list port-except {
               type string;
             }
           }
         }
         choice icmp-type_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list icmp-type-except {
               type string;
             }
           }
         }
         choice icmp-code_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list icmp-code-except {
               type string;
             }
           }
         }
         list interface {
           key name;
           ordered-by user;
           description "Match interface name";
           uses match_interface_object;
         }
         list interface-set {
           key name;
           ordered-by user;
           description "Match interface in set";
           uses match_interface_set_object;
         }
         choice ipv6-next-header_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ipv6-next-header-except {
               type string;
             }
           }
         }
         choice ipv6-payload-protocol_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ipv6-payload-protocol-except {
               type string;
             }
           }
         }
         choice ipv6-traffic-class_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ipv6-traffic-class-except {
               type string;
             }
           }
         }
         choice flex-mask_choice {
           case case_1 {
             container flexible-match-mask {
               description "Match flexible mask";
               uses match_L2_flexible_mask;
             }
           }
         }
         choice policy-map_choice {
           case case_1 {
             leaf-list policy-map {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list policy-map-except {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         choice isid_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list isid-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice isid-priority-code-point_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list isid-priority-code-point-except {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
         }
         choice isid-dei_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list isid-dei-except {
               description "DEI value 0-1";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 1";
                 }
               }
             }
           }
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         choice policer-choice {
           case case_1 {
             leaf policer {
               description "Name of policer to use to rate-limit traffic";
               junos:must "(!(\"firewall policer $$ aggregate\"))";
               junos:must-message "Cannot attach a aggregate policer to filter";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             container three-color-policer {
               junos:must "(!(\".. loss-priority\"))";
               junos:must-message "cannot support three-color-policer action if loss-priority is configured";
               description "Police the packet using a three-color-policer";
               uses apply-advanced;
               choice type-choice {
                 case case_1 {
                   leaf single-rate {
                     description "Name of single-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-rate\")";
                     junos:must-message "Referenced single-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_2 {
                   leaf single-packet-rate {
                     description "Name of single-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-packet-rate\")";
                     junos:must-message "Referenced single-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_3 {
                   leaf two-rate {
                     description "Name of two-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-rate\")";
                     junos:must-message "Referenced two-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_4 {
                   leaf two-packet-rate {
                     description "Name of two-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-packet-rate\")";
                     junos:must-message "Referenced two-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
               }
             }
           }
           case case_3 {
           }
         }
         choice policy-map-choice {
           case case_1 {
             leaf clear-policy-map {
               description "Clear the policy marking";
               type empty;
             }
           }
           case case_2 {
             leaf policy-map {
               description "Policy map action";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "referenced policy map must be defined";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         leaf count {
           description "Count the packet in the named counter";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf loss-priority {
           description "Packet's loss priority";
           type enumeration {
             enum "low" {
               description "Loss priority low";
             }
             enum "high" {
               description "Loss priority high";
             }
             enum "medium-low" {
               description "Loss priority medium-low";
             }
             enum "medium-high" {
               description "Loss priority medium-high";
             }
           }
         }
         leaf forwarding-class {
           description "Classify packet to forwarding class";
           type string {
             junos:posix-pattern "^.{1,64}$";
             junos:pattern-message "Must be string of 64 characters or less";
           }
         }
         choice designation {
           case case_1 {
             leaf accept {
               description "Accept the packet";
               type empty;
             }
           }
           case case_2 {
             leaf discard {
               description "Discard the packet";
               type empty;
             }
           }
           case case_3 {
             leaf next {
               description "Continue to next term in a filter";
               type enumeration {
                 enum "term" {
                   description "Continue to next term in a filter";
                 }
               }
             }
           }
         }
         leaf port-mirror-instance {
           description "Port-mirror the packet to specified instance";
           junos:must "(\"forwarding-options port-mirroring instance $$\")";
           junos:must-message "Referenced port-mirroring instance does not exist";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf port-mirror {
           description "Port-mirror the packet";
           junos:must "(!(\".. port-mirror-instance\"))";
           junos:must-message "'port-mirror' and 'port-mirror-instance' are mutually exclusive";
           junos:must "(\"forwarding-options port-mirroring\")";
           junos:must-message "Configure 'port-mirroring' under 'forwarding-options'";
           type empty;
         }
         container forwarding-policy {
           description "Specify forwarding policy for extended port";
           uses apply-advanced;
           leaf uplink-select {
             description "Specify port group for uplink selection";
             type string;
           }
         }
       }
     }
   }
   grouping ccc_filter {
     description "Define a CCC firewall filter";
     leaf name {
       description "Filter name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf-list accounting-profile {
       description "Accounting profile name";
       junos:must "(\"accounting-options filter-profile\")";
       junos:must-message "referenced accounting profile must be defined";
       type string;
     }
     leaf interface-specific {
       description "Any counters defined will be interface specific";
       type empty;
     }
     list term {
       key name;
       ordered-by user;
       description "Define a firewall term";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       leaf filter {
         description "Filter to include";
         junos:must "(\"firewall family ccc filter $$\")";
         junos:must-message "Referenced filter is not defined";
         junos:must "((!(\".. from\") && !(\".. then\")))";
         junos:must-message "Not compatible with 'from or then'";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       container from {
         description "Define match criteria";
         uses apply-advanced;
         choice interface-group_choice {
           case case_1 {
             leaf-list interface-group {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list interface-group-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice forwarding-class_choice {
           case case_1 {
             leaf-list forwarding-class {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list forwarding-class-except {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
         }
         choice loss-priority_choice {
           case case_1 {
             leaf-list loss-priority {
               type enumeration {
                 enum "low" {
                   description "Loss priority low";
                 }
                 enum "high" {
                   description "Loss priority high";
                 }
                 enum "medium-low" {
                   description "Loss priority medium-low";
                 }
                 enum "medium-high" {
                   description "Loss priority medium-high";
                 }
               }
             }
           }
           case case_2 {
             leaf-list loss-priority-except {
               type enumeration {
                 enum "low" {
                   description "Loss priority low";
                 }
                 enum "high" {
                   description "Loss priority high";
                 }
                 enum "medium-low" {
                   description "Loss priority medium-low";
                 }
                 enum "medium-high" {
                   description "Loss priority medium-high";
                 }
               }
             }
           }
         }
         choice learn-vlan-1p-priority_choice {
           case case_1 {
             leaf-list learn-vlan-1p-priority {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
           case case_2 {
             leaf-list learn-vlan-1p-priority-except {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
         }
         choice user-vlan-1p-priority_choice {
           case case_1 {
             leaf-list user-vlan-1p-priority {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
           case case_2 {
             leaf-list user-vlan-1p-priority-except {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
         }
         list destination-mac-address {
           key name;
           ordered-by user;
           description "Destination MAC address";
           uses firewall_mac_addr_object;
         }
         list source-mac-address {
           key name;
           ordered-by user;
           description "Source MAC address";
           uses firewall_mac_addr_object;
         }
         list ip-source-address {
           key name;
           ordered-by user;
           description "Match IP source address";
           uses firewall_addr_object;
         }
         list ip-destination-address {
           key name;
           ordered-by user;
           description "Match IP destination address";
           uses firewall_addr_object;
         }
         choice dscp_choice {
           case case_1 {
             leaf-list dscp {
               type string;
             }
           }
           case case_2 {
             leaf-list dscp-except {
               type string;
             }
           }
         }
         choice ip-precedence_choice {
           case case_1 {
             leaf-list ip-precedence {
               type string;
             }
           }
           case case_2 {
             leaf-list ip-precedence-except {
               type string;
             }
           }
         }
         choice ip-protocol_choice {
           case case_1 {
             leaf-list ip-protocol {
               type string;
             }
           }
           case case_2 {
             leaf-list ip-protocol-except {
               type string;
             }
           }
         }
         choice icmp-type_choice {
           case case_1 {
             leaf-list icmp-type {
               type string;
             }
           }
           case case_2 {
             leaf-list icmp-type-except {
               type string;
             }
           }
         }
         choice icmp-code_choice {
           case case_1 {
             leaf-list icmp-code {
               type string;
             }
           }
           case case_2 {
             leaf-list icmp-code-except {
               type string;
             }
           }
         }
         choice source-port_choice {
           case case_1 {
             leaf-list source-port {
               type string;
             }
           }
           case case_2 {
             leaf-list source-port-except {
               type string;
             }
           }
         }
         choice destination-port_choice {
           case case_1 {
             leaf-list destination-port {
               type string;
             }
           }
           case case_2 {
             leaf-list destination-port-except {
               type string;
             }
           }
         }
         choice policy-map_choice {
           case case_1 {
             leaf-list policy-map {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list policy-map-except {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         choice flex-mask_choice {
           case case_1 {
             container flexible-match-mask {
               description "Match flexible mask";
               uses match_L2_flexible_mask;
             }
           }
         }
         choice user-vlan-id_choice {
           case case_1 {
             leaf-list user-vlan-id {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list user-vlan-id-except {
               description "Range of values";
               type string;
             }
           }
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         choice policer-choice {
           case case_1 {
             leaf policer {
               description "Name of policer to use to rate-limit traffic";
               junos:must "(!(\"firewall policer $$ aggregate\"))";
               junos:must-message "Cannot attach a aggregate policer to filter";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             container three-color-policer {
               junos:must "(!(\".. loss-priority\"))";
               junos:must-message "cannot support three-color-policer action if loss-priority is configured";
               description "Police the packet using a three-color-policer";
               uses apply-advanced;
               choice type-choice {
                 case case_1 {
                   leaf single-rate {
                     description "Name of single-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-rate\")";
                     junos:must-message "Referenced single-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_2 {
                   leaf single-packet-rate {
                     description "Name of single-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-packet-rate\")";
                     junos:must-message "Referenced single-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_3 {
                   leaf two-rate {
                     description "Name of two-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-rate\")";
                     junos:must-message "Referenced two-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_4 {
                   leaf two-packet-rate {
                     description "Name of two-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-packet-rate\")";
                     junos:must-message "Referenced two-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
               }
             }
           }
           case case_3 {
           }
         }
         choice policy-map-choice {
           case case_1 {
             leaf clear-policy-map {
               description "Clear the policy marking";
               type empty;
             }
           }
           case case_2 {
             leaf policy-map {
               description "Policy map action";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "referenced policy map must be defined";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         leaf count {
           description "Count the packet in the named counter";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf loss-priority {
           description "Packet's loss priority";
           type enumeration {
             enum "low" {
               description "Loss priority low";
             }
             enum "high" {
               description "Loss priority high";
             }
             enum "medium-low" {
               description "Loss priority medium-low";
             }
             enum "medium-high" {
               description "Loss priority medium-high";
             }
           }
         }
         leaf forwarding-class {
           description "Classify packet to forwarding class";
           type string {
             junos:posix-pattern "^.{1,64}$";
             junos:pattern-message "Must be string of 64 characters or less";
           }
         }
         leaf port-mirror-instance {
           description "Port-mirror the packet to the specified instance";
           junos:must "(\"forwarding-options port-mirroring instance $$\")";
           junos:must-message "Referenced port-mirroring instance does not exist";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf port-mirror {
           description "Port-mirror the packet";
           junos:must "(!(\".. port-mirror-instance\"))";
           junos:must-message "'port-mirror' and 'port-mirror-instance' are mutually exclusive";
           junos:must "(\"forwarding-options port-mirroring\")";
           junos:must-message "Configure 'port-mirroring' under 'forwarding-options'";
           type empty;
         }
         leaf log {
           description "Log the packet";
           type empty;
         }
         leaf syslog {
           description "System log (syslog) information about the packet";
           type empty;
         }
         choice designation {
           case case_1 {
           }
           case case_2 {
             leaf accept {
               description "Accept the packet";
               type empty;
             }
           }
           case case_3 {
             leaf discard {
               description "Discard the packet";
               type empty;
             }
           }
           case case_4 {
             leaf next {
               description "Continue to next term in a filter";
               type enumeration {
                 enum "term" {
                   description "Continue to next term in a filter";
                 }
               }
             }
           }
         }
       }
     }
   }
   grouping es_filter {
     leaf name {
       description "Filter name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf interface-specific {
       description "Defined counters are interface specific";
       type empty;
     }
     list term {
       key name;
       ordered-by user;
       description "Define a firewall term";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       container from {
         description "Define match criteria";
         uses apply-advanced;
         list interface {
           key name;
           ordered-by user;
           description "Match interface name";
           uses match_interface_object;
         }
         list source-mac-address {
           key name;
           ordered-by user;
           description "Match MAC source address";
           uses firewall_mac_addr_object;
         }
         list destination-mac-address {
           key name;
           ordered-by user;
           description "Match MAC destination address";
           uses firewall_mac_addr_object;
         }
         choice ether-type_choice {
           case case_1 {
             leaf-list ether-type {
               type string;
             }
           }
           case case_2 {
             leaf-list ether-type-except {
               type string;
             }
           }
         }
         choice l2-encap-type_choice {
           case case_1 {
             leaf-list l2-encap-type {
               type string;
             }
           }
           case case_2 {
             leaf-list l2-encap-type-except {
               type string;
             }
           }
         }
         choice vlan_choice {
           case case_1 {
             leaf-list vlan {
               description "VLAN name or ID";
               junos:must "(!(\".. .. dot1q-tag\"))";
               junos:must-message "vlan may not be matched in same rule as dot1q-tag";
               type string;
             }
           }
           case case_2 {
             leaf-list vlan-except {
               description "VLAN name or ID";
               junos:must "(!(\".. .. dot1q-tag\"))";
               junos:must-message "vlan may not be matched in same rule as dot1q-tag";
               type string;
             }
           }
         }
         choice dot1q-tag_choice {
           case case_1 {
             leaf-list dot1q-tag {
               description "Range of values";
               junos:must "(!(any \".. .. vlan <*>\"))";
               junos:must-message "dot1q-tag may not be matched in same rule as vlan";
               type string {
                 junos:posix-pattern "^([0-9]{1,3}|[1-3][0-9][0-9][0-9]|40[0-9][0-5])(-([0-9]{1,3}|[1-3][0-9][0-9][0-9]|40[0-9][0-5]))?$";
                 junos:pattern-message "Must be a numerical value or range between 0-4095";
               }
             }
           }
           case case_2 {
             leaf-list dot1q-tag-except {
               description "Range of values";
               junos:must "(!(any \".. .. vlan <*>\"))";
               junos:must-message "dot1q-tag may not be matched in same rule as vlan";
               type string {
                 junos:posix-pattern "^([0-9]{1,3}|[1-3][0-9][0-9][0-9]|40[0-9][0-5])(-([0-9]{1,3}|[1-3][0-9][0-9][0-9]|40[0-9][0-5]))?$";
                 junos:pattern-message "Must be a numerical value or range between 0-4095";
               }
             }
           }
         }
         choice dot1q-user-priority_choice {
           case case_1 {
             leaf-list dot1q-user-priority {
               type string;
             }
           }
           case case_2 {
             leaf-list dot1q-user-priority-except {
               type string;
             }
           }
         }
         list source-address {
           key name;
           ordered-by user;
           description "Match IP source address";
           uses firewall_addr_object;
         }
         list destination-address {
           key name;
           ordered-by user;
           description "Match IP destination address";
           uses firewall_addr_object;
         }
         choice dscp_choice {
           case case_1 {
             leaf-list dscp {
               type string;
             }
           }
           case case_2 {
             leaf-list dscp-except {
               type string;
             }
           }
         }
         choice precedence_choice {
           case case_1 {
             leaf-list precedence {
               type string;
             }
           }
           case case_2 {
             leaf-list precedence-except {
               type string;
             }
           }
         }
         choice ip-options_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ip-options-except {
               type enumeration {
                 enum "any" {
                   description "Any IP option";
                 }
               }
             }
           }
         }
         leaf fragment-flags {
           description "Match fragment flags (in symbolic or hex formats) - (Ingress only)";
           type string {
             junos:posix-pattern "^(0x4000|0x2000|dont-fragment|more-fragments)$";
             junos:pattern-message "fragment-flags must be either dont-fragment(0x4000) or more-fragments(0x2000)";
           }
         }
         leaf is-fragment {
           description "Match if packet is a fragment";
           type empty;
         }
         choice protocol_choice {
           case case_1 {
             leaf-list protocol {
               type string;
             }
           }
           case case_2 {
             leaf-list protocol-except {
               type string;
             }
           }
         }
         choice source-port_choice {
           case case_1 {
             leaf-list source-port {
               type string;
             }
           }
           case case_2 {
             leaf-list source-port-except {
               type string;
             }
           }
         }
         choice destination-port_choice {
           case case_1 {
             leaf-list destination-port {
               type string;
             }
           }
           case case_2 {
             leaf-list destination-port-except {
               type string;
             }
           }
         }
         choice port_choice {
           case case_1 {
             leaf-list port {
               type string;
             }
           }
           case case_2 {
             leaf-list port-except {
               type string;
             }
           }
         }
         leaf tcp-flags {
           description "Match TCP flags (in symbolic or hex formats)";
           junos:must "(!(\".. tcp-established\"))";
           junos:must-message "tcp-flags may not be matched in same rule as tcp-established";
           junos:must "(!(\".. tcp-initial\"))";
           junos:must-message "tcp-flags may not be matched in same rule as tcp-initial";
           type string;
         }
         leaf tcp-initial {
           description "Match initial packet of a TCP connection";
           type empty;
         }
         leaf tcp-established {
           description "Match packet of an established TCP connection";
           type empty;
         }
         choice icmp-type_choice {
           case case_1 {
             leaf-list icmp-type {
               type string;
             }
           }
           case case_2 {
             leaf-list icmp-type-except {
               type string;
             }
           }
         }
         choice icmp-code_choice {
           case case_1 {
             leaf-list icmp-code {
               type string;
             }
           }
           case case_2 {
             leaf-list icmp-code-except {
               type string;
             }
           }
         }
         list source-prefix-list {
           key name;
           ordered-by user;
           description "Match IP source prefixes in named list";
           uses firewall_prefix_list;
         }
         list destination-prefix-list {
           key name;
           ordered-by user;
           description "Match IP destination prefixes in named list";
           uses firewall_prefix_list;
         }
         list ip-source-address {
           key name;
           ordered-by user;
           description "Match IP source address";
           uses firewall_addr_object;
         }
         list ip-destination-address {
           key name;
           ordered-by user;
           description "Match IP destination address";
           uses firewall_addr_object;
         }
         choice ip-protocol_choice {
           case case_1 {
             leaf-list ip-protocol {
               type string;
             }
           }
           case case_2 {
             leaf-list ip-protocol-except {
               type string;
             }
           }
         }
         choice ip-precedence_choice {
           case case_1 {
             leaf-list ip-precedence {
               type string;
             }
           }
           case case_2 {
             leaf-list ip-precedence-except {
               type string;
             }
           }
         }
         choice ipv6-next-header_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ipv6-next-header-except {
               type string;
             }
           }
         }
         choice ipv6-payload-protocol_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ipv6-payload-protocol-except {
               type string;
             }
           }
         }
         choice ipv6-traffic-class_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ipv6-traffic-class-except {
               type string;
             }
           }
         }
         choice interface-group_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list interface-group-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice vlan-ether-type_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list vlan-ether-type-except {
               type string;
             }
           }
         }
         choice loss-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list loss-priority-except {
               type enumeration {
                 enum "low" {
                   description "Loss priority low";
                 }
                 enum "high" {
                   description "Loss priority high";
                 }
                 enum "medium-low" {
                   description "Loss priority medium-low";
                 }
                 enum "medium-high" {
                   description "Loss priority medium-high";
                 }
               }
             }
           }
         }
         choice learn-vlan-id_choice {
           case case_1 {
             leaf-list learn-vlan-id {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list learn-vlan-id-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice learn-vlan-1p-priority_choice {
           case case_1 {
             leaf-list learn-vlan-1p-priority {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
           case case_2 {
             leaf-list learn-vlan-1p-priority-except {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
         }
         choice learn-vlan-dei_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list learn-vlan-dei-except {
               description "DEI value 0-1";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 1";
                 }
               }
             }
           }
         }
         choice user-vlan-id_choice {
           case case_1 {
             leaf-list user-vlan-id {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list user-vlan-id-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice user-vlan-1p-priority_choice {
           case case_1 {
             leaf-list user-vlan-1p-priority {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
           case case_2 {
             leaf-list user-vlan-1p-priority-except {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
         }
         choice traffic-type_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list traffic-type-except {
               type enumeration {
                 enum "broadcast" {
                   description "Packets with broadcast ethernet address";
                 }
                 enum "multicast" {
                   description "Packets with multicast ethernet address";
                 }
                 enum "unknown-unicast" {
                   description "Packets for which destination ethernet address has not been learnt";
                 }
                 enum "known-unicast" {
                   description "Packets for which destination ethernet address has been learnt";
                 }
               }
             }
           }
         }
         choice isid_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list isid-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice isid-priority-code-point_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list isid-priority-code-point-except {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
         }
         choice isid-dei_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list isid-dei-except {
               description "DEI value 0-1";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 1";
                 }
               }
             }
           }
         }
         choice forwarding-class_choice {
           case case_1 {
             leaf-list forwarding-class {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list forwarding-class-except {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
         }
         container to-fabric {
           description "Match packets going to fabric";
           uses to_fabric_object;
         }
         leaf from-fabric {
           description "Match packets coming from fabric";
           type empty;
         }
         choice arp-type_choice {
           case case_1 {
             leaf-list arp-type {
               type string;
             }
           }
         }
         choice flex-mask_choice {
           case case_1 {
             container flexible-match-mask {
               description "Match flexible mask";
               uses match_L2_flexible_mask;
             }
           }
         }
         container ip-version {
           description "Define IP version";
           uses apply-advanced;
           container ipv4 {
             junos:must "(!(\".. ipv6\"))";
             junos:must-message "Same term cannot have both IPv4 & IPv6 IP version";
             description "Define L3/L4 match items to match IPv4 packets";
             uses apply-advanced;
             list address {
               key name;
               ordered-by user;
               description "Match IP source or destination address";
               uses firewall_addr_object;
             }
             list source-address {
               key name;
               ordered-by user;
               description "Match IP source address";
               uses firewall_addr_object;
             }
             list destination-address {
               key name;
               ordered-by user;
               description "Match IP destination address";
               uses firewall_addr_object;
             }
             choice dscp_choice {
               case case_1 {
                 leaf-list dscp {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list dscp-except {
                   type string;
                 }
               }
             }
             choice precedence_choice {
               case case_1 {
                 leaf-list precedence {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list precedence-except {
                   type string;
                 }
               }
             }
             choice ip-options_choice {
               case case_1 {
                 leaf-list ip-options {
                   type enumeration {
                     enum "any" {
                       description "Any IP option";
                     }
                   }
                 }
               }
               case case_2 {
                 leaf-list ip-options-except {
                   type enumeration {
                     enum "any" {
                       description "Any IP option";
                     }
                   }
                 }
               }
             }
             leaf fragment-flags {
               description "Match fragment flags (in symbolic or hex formats) - (Ingress only)";
               type string;
             }
             leaf is-fragment {
               description "Match if packet is a fragment";
               type empty;
             }
             choice protocol_choice {
               case case_1 {
                 leaf-list protocol {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list protocol-except {
                   type string;
                 }
               }
             }
             choice source-port_choice {
               case case_1 {
                 leaf-list source-port {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list source-port-except {
                   type string;
                 }
               }
             }
             choice destination-port_choice {
               case case_1 {
                 leaf-list destination-port {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list destination-port-except {
                   type string;
                 }
               }
             }
             choice port_choice {
               case case_1 {
                 leaf-list port {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list port-except {
                   type string;
                 }
               }
             }
             leaf tcp-flags {
               description "Match TCP flags (in symbolic or hex formats) - (Ingress only)";
               junos:must "(!(\".. tcp-established\"))";
               junos:must-message "tcp-flags may not be matched in same rule as tcp-established";
               junos:must "(!(\".. tcp-initial\"))";
               junos:must-message "tcp-flags may not be matched in same rule as tcp-initial";
               type string;
             }
             leaf tcp-initial {
               description "Match initial packet of a TCP connection - (Ingress only)";
               type empty;
             }
             leaf tcp-established {
               description "Match packet of an established TCP connection";
               type empty;
             }
             choice icmp-type_choice {
               case case_1 {
                 leaf-list icmp-type {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list icmp-type-except {
                   type string;
                 }
               }
             }
             choice icmp-code_choice {
               case case_1 {
                 leaf-list icmp-code {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list icmp-code-except {
                   type string;
                 }
               }
             }
             list source-prefix-list {
               key name;
               ordered-by user;
               description "Match IP source prefixes in named list";
               uses firewall_prefix_list;
             }
             list destination-prefix-list {
               key name;
               ordered-by user;
               description "Match IP destination prefixes in named list";
               uses firewall_prefix_list;
             }
             list ip-source-address {
               key name;
               ordered-by user;
               description "Match IP source address";
               uses firewall_addr_object;
             }
             list ip-destination-address {
               key name;
               ordered-by user;
               description "Match IP destination address";
               uses firewall_addr_object;
             }
             choice ip-protocol_choice {
               case case_1 {
                 leaf-list ip-protocol {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list ip-protocol-except {
                   type string;
                 }
               }
             }
             choice ip-precedence_choice {
               case case_1 {
                 leaf-list ip-precedence {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list ip-precedence-except {
                   type string;
                 }
               }
             }
           }
           container ipv6 {
             junos:must "(!(\".. ipv4\"))";
             junos:must-message "Same term cannot have both IPv4 & IPv6 IP version";
             description "Define L3/L4 match items to match IPv6 packets";
             uses apply-advanced;
             choice traffic-class_choice {
               case case_1 {
                 leaf-list traffic-class {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list traffic-class-except {
                   type string;
                 }
               }
             }
             choice next-header_choice {
               case case_1 {
                 leaf-list next-header {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list next-header-except {
                   type string;
                 }
               }
             }
             choice payload-protocol_choice {
               case case_1 {
               }
               case case_2 {
                 leaf-list payload-protocol-except {
                   type string;
                 }
               }
             }
             choice source-port_choice {
               case case_1 {
                 leaf-list source-port {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list source-port-except {
                   type string;
                 }
               }
             }
             choice destination-port_choice {
               case case_1 {
                 leaf-list destination-port {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list destination-port-except {
                   type string;
                 }
               }
             }
             choice port_choice {
               case case_1 {
                 leaf-list port {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list port-except {
                   type string;
                 }
               }
             }
             choice extension-header_choice {
               case case_1 {
               }
               case case_2 {
                 leaf-list extension-header-except {
                   type string;
                 }
               }
             }
             leaf tcp-flags {
               description "Match TCP flags (in symbolic or hex formats)";
               junos:must "((\".. next-header tcp\" || (\".. next-header 6\" || \".. payload-protocol tcp\")))";
               junos:must-message "next-header tcp or next-header 6 or payload-protocol tcp must be defined in the same clause";
               junos:must "(\".. next-header tcp\")";
               junos:must-message "next-header tcp must be defined in the same clause";
               junos:must "(!(\".. tcp-established\"))";
               junos:must-message "tcp-flags may not be matched in same rule as tcp-established";
               junos:must "(!(\".. tcp-initial\"))";
               junos:must-message "tcp-flags may not be matched in same rule as tcp-initial";
               type string;
             }
             leaf tcp-initial {
               description "Match initial packet of a TCP connection";
               junos:must "((\".. next-header tcp\" || (\".. next-header 6\" || \".. payload-protocol tcp\")))";
               junos:must-message "next-header tcp or next-header 6 or payload-protocol tcp must be defined in the same clause";
               type empty;
             }
             leaf tcp-established {
               description "Match packet of an established TCP connection";
               junos:must "((\".. next-header tcp\" || (\".. next-header 6\" || \".. payload-protocol tcp\")))";
               junos:must-message "next-header tcp or next-header 6 or payload-protocol tcp must be defined in the same clause";
               type empty;
             }
             choice icmp-type_choice {
               case case_1 {
                 leaf-list icmp-type {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list icmp-type-except {
                   type string;
                 }
               }
             }
             choice icmp-code_choice {
               case case_1 {
                 leaf-list icmp-code {
                   type string;
                 }
               }
               case case_2 {
                 leaf-list icmp-code-except {
                   type string;
                 }
               }
             }
             list source-prefix-list {
               key name;
               ordered-by user;
               description "Match IP source prefixes in named list";
               uses firewall_prefix_list;
             }
             list destination-prefix-list {
               key name;
               ordered-by user;
               description "Match IP destination prefixes in named list";
               uses firewall_prefix_list;
             }
             list ip6-source-address {
               key name;
               ordered-by user;
               description "Match source address";
               uses firewall_addr6_object;
             }
             list ip6-destination-address {
               key name;
               ordered-by user;
               description "Match destination address";
               uses firewall_addr6_object;
             }
           }
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         choice designation {
           case case_1 {
             leaf accept {
               description "Accept the packet";
               type empty;
             }
           }
           case case_2 {
             leaf discard {
               description "Discard the packet";
               type empty;
             }
           }
           case case_3 {
             leaf next {
               description "Continue to next term in a filter";
               type enumeration {
                 enum "term" {
                   description "Continue to next term in a filter";
                 }
               }
             }
           }
         }
         leaf log {
           description "Log the packet";
           type empty;
         }
         leaf pkt-trace {
           description "Trace the packet";
           type empty;
         }
         leaf syslog {
           description "System log (syslog) information about the packet";
           type empty;
         }
         leaf forwarding-class {
           description "Classify packet to forwarding class";
           junos:must "(\".. loss-priority\")";
           junos:must-message "To configure forwarding-class, loss-priority must be set";
           type string {
             junos:posix-pattern "^.{1,64}$";
             junos:pattern-message "Must be string of 64 characters or less";
           }
         }
         leaf analyzer {
           description "Name of analyzer - (Ingress only)";
           junos:must "(\"ethernet-switching-options analyzer $$\")";
           junos:must-message "Named Analyzer must be set";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf port-mirror-instance {
           description "Port-mirror the packet to specified instance";
           junos:must "(\"forwarding-options port-mirroring instance $$\")";
           junos:must-message "Referenced port-mirroring instance does not exist";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf port-mirror {
           description "Port-mirror the packet";
           junos:must "(!(\".. port-mirror-instance\"))";
           junos:must-message "'port-mirror' and 'port-mirror-instance' are mutually exclusive";
           junos:must "(\"forwarding-options port-mirroring\")";
           junos:must-message "Configure 'port-mirroring' under 'forwarding-options'";
           type empty;
         }
         leaf loss-priority {
           description "Packet's loss priority";
           junos:must "(\".. forwarding-class\")";
           junos:must-message "To configure loss-priority, forwarding-class must be set";
           type enumeration {
             enum "low" {
               description "Loss priority low";
             }
             enum "high" {
               description "Loss priority high";
             }
             enum "medium-low" {
               description "Loss priority medium-low";
             }
             enum "medium-high" {
               description "Loss priority medium-high";
             }
           }
         }
         leaf count {
           description "Count the packet in the named counter";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         choice policer-choice {
           case case_1 {
             leaf policer {
               description "Name of policer to use to rate-limit traffic";
               junos:must "(!(\"firewall policer $$ aggregate\"))";
               junos:must-message "Cannot attach a aggregate policer to filter";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             container three-color-policer {
               junos:must "(!(\".. loss-priority\"))";
               junos:must-message "cannot support three-color-policer action if loss-priority is configured";
               description "Police the packet using a three-color-policer";
               uses apply-advanced;
               choice type-choice {
                 case case_1 {
                   leaf single-rate {
                     description "Name of single-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-rate\")";
                     junos:must-message "Referenced single-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_2 {
                   leaf single-packet-rate {
                     description "Name of single-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-packet-rate\")";
                     junos:must-message "Referenced single-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_3 {
                   leaf two-rate {
                     description "Name of two-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-rate\")";
                     junos:must-message "Referenced two-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_4 {
                   leaf two-packet-rate {
                     description "Name of two-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-packet-rate\")";
                     junos:must-message "Referenced two-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
               }
             }
           }
           case case_3 {
           }
         }
         leaf vlan {
           description "Name of VLAN - (Ingress only)";
           junos:must "((\"vlans $$\" && !(\"vlans $$ vlan-range\")))";
           junos:must-message "Named or Non-range vlan must be set";
           type string;
         }
         leaf interface {
           description "Switch traffic to the specified interface by-passing switching lookup - (Ingress only)";
           type union {
             type jt:interface-unit;
             type string {
               pattern "<.*>|$.*";
             }
           }
         }
       }
       container template {
         description "Refer a template";
         uses apply-advanced;
         leaf template-name {
           description "Template name";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
       }
     }
   }
   grouping es_template {
     leaf name {
       description "Template name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     container attributes {
       description "Template attributes";
       uses apply-advanced;
       container ip-version {
         description "Define IP version";
         uses apply-advanced;
         container ipv4 {
           description "Define L3/L4 match items to match IPv4 packets";
           uses apply-advanced;
           leaf destination-port {
             description "Match TCP/UDP destination port";
             type empty;
           }
           leaf destination-prefix-list {
             description "Match IP destination prefixes in named list";
             type empty;
           }
           leaf dscp {
             description "Match Differentiated Services (DiffServ) code point";
             type empty;
           }
           leaf fragment-flags {
             description "Match fragment flags";
             type empty;
           }
           leaf icmp-code {
             description "Match ICMP message code";
             type empty;
           }
           leaf icmp-type {
             description "Match ICMP message type";
             type empty;
           }
           leaf ip-destination-address {
             description "Match IP destination address";
             type empty;
           }
           leaf ip-precedence {
             description "Match IP precedence value";
             type empty;
           }
           leaf ip-protocol {
             description "Match IP protocol type";
             type empty;
           }
           leaf ip-source-address {
             description "Match IP source address";
             type empty;
           }
           leaf is-fragment {
             description "Match if packet is a fragment";
             type empty;
           }
           leaf source-port {
             description "Match TCP/UDP source port";
             type empty;
           }
           leaf source-prefix-list {
             description "Match IP source prefixes in named list";
             type empty;
           }
           leaf tcp-established {
             description "Match packet of an established TCP connection";
             type empty;
           }
           leaf tcp-flags {
             description "Match TCP flags";
             type empty;
           }
           leaf tcp-initial {
             description "Match initial packet of a TCP connection";
             type empty;
           }
         }
         container ipv6 {
           description "Define L3/L4 match items to match IPv6 packets";
           uses apply-advanced;
           leaf destination-port {
             description "Match TCP/UDP destination port";
             type empty;
           }
           leaf destination-prefix-list {
             description "Match IP destination prefixes in named list";
             type empty;
           }
           leaf icmp-code {
             description "Match ICMP message code";
             type empty;
           }
           leaf icmp-type {
             description "Match ICMP message type";
             type empty;
           }
           leaf ip6-destination-address {
             description "Match destination address";
             type empty;
           }
           leaf ip6-source-address {
             description "Match source address";
             type empty;
           }
           leaf next-header {
             description "Match next header protocol type";
             type empty;
           }
           leaf source-port {
             description "Match TCP/UDP source port";
             type empty;
           }
           leaf source-prefix-list {
             description "Match IP source prefixes in named list";
             type empty;
           }
           leaf tcp-established {
             description "Match packet of an established TCP connection";
             type empty;
           }
           leaf tcp-flags {
             description "Match TCP flags";
             type empty;
           }
           leaf tcp-initial {
             description "Match initial packet of a TCP connection";
             type empty;
           }
           leaf traffic-class {
             description " Match Differentiated Services (DiffServ) code point";
             type empty;
           }
         }
       }
       leaf arp-type {
         description "Match ARP type";
         type empty;
       }
       leaf destination-mac-address {
         description "Match MAC destination address";
         type empty;
       }
       leaf destination-port {
         description "Match TCP/UDP destination port";
         type empty;
       }
       leaf destination-prefix-list {
         description "Match IP destination prefixes in named list";
         type empty;
       }
       leaf dscp {
         description "Match Differentiated Services (DiffServ) code point";
         type empty;
       }
       leaf ether-type {
         description "Match Ethernet Type";
         type empty;
       }
       leaf fragment-flags {
         description "Match fragment flags";
         type empty;
       }
       leaf icmp-code {
         description "Match ICMP message code";
         type empty;
       }
       leaf icmp-type {
         description "Match ICMP message type";
         type empty;
       }
       leaf interface {
         description "Match interface name";
         type empty;
       }
       leaf ip-destination-address {
         description "Match IP destination address";
         type empty;
       }
       leaf ip-precedence {
         description "Match IP precedence value";
         type empty;
       }
       leaf ip-protocol {
         description "Match IP protocol type";
         type empty;
       }
       leaf ip-source-address {
         description "Match IP source address";
         type empty;
       }
       leaf is-fragment {
         description "Match if packet is a fragment";
         type empty;
       }
       leaf l2-encap-type {
         description "Match Ethernet Encapsulation Type";
         type empty;
       }
       leaf learn-vlan-id {
         description "Match Learnt VLAN ID";
         type empty;
       }
       leaf source-mac-address {
         description "Match MAC source address";
         type empty;
       }
       leaf source-port {
         description "Match TCP/UDP source port";
         type empty;
       }
       leaf source-prefix-list {
         description "Match IP source prefixes in named list";
         type empty;
       }
       leaf tcp-established {
         description "Match packet of an established TCP connection";
         type empty;
       }
       leaf tcp-flags {
         description "Match TCP flags";
         type empty;
       }
       leaf tcp-initial {
         description "Match initial packet of a TCP connection";
         type empty;
       }
       leaf user-vlan-1p-priority {
         description "Match User 802.1p VLAN priority";
         type empty;
       }
       leaf user-vlan-id {
         description "Match User VLAN ID";
         type empty;
       }
     }
   }
   grouping firewall_addr6_object {
     leaf name {
       description "Prefix to match";
       type jt:ipv6prefix;
     }
     leaf except {
       description "Match address not in this prefix";
       type empty;
     }
   }
   grouping firewall_addr_object {
     leaf name {
       description "Prefix to match";
       type jt:ipv4prefix;
     }
     leaf except {
       description "Match address not in this prefix";
       type empty;
     }
   }
   grouping firewall_flexible_match {
     description "Define a flexible match";
     leaf name {
       description "Flex match template name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf match-start {
       description "Start point to match in packet";
       type enumeration {
         enum "layer-2" {
           description "Layer-2 match start";
         }
         enum "layer-3" {
           description "Layer-3 match start";
         }
         enum "layer-4" {
           description "Layer-4 match start";
         }
         enum "payload" {
           description "Payload match start";
         }
       }
     }
     leaf byte-offset {
       description "Byte offset after the match start point";
       type union {
         type uint32;
         type string {
           pattern "<.*>|$.*";
         }
       }
     }
     leaf bit-offset {
       description "Bit offset after the (match-start + byte) offset";
       type union {
         type string {
           pattern "<.*>|$.*";
         }
         type uint32 {
           range "0 .. 7";
         }
       }
     }
     leaf bit-length {
       description "Length of the data to be matched in bits, not needed for string input";
       type union {
         type string {
           pattern "<.*>|$.*";
         }
         type uint32 {
           range "1 .. 128";
         }
       }
     }
   }
   grouping firewall_mac_addr_object {
     leaf name {
       description "MAC address to match";
       type jt:mac-addr-prefix;
     }
     leaf except {
       description "Match MAC address not in this range";
       type empty;
     }
   }
   grouping firewall_policer {
     description "Define a policer";
     leaf name {
       description "Policer name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf filter-specific {
       description "Policer is filter-specific";
       type empty;
     }
     leaf logical-interface-policer {
       description "Policer is logical interface policer";
       type empty;
     }
     leaf logical-bandwidth-policer {
       description "Policer uses logical interface bandwidth";
       type empty;
     }
     choice exceeding {
       case case_1 {
         container if-exceeding {
           presence "enable if-exceeding";
           description "Define rate limits";
           uses apply-advanced;
           choice bandwidth {
             case case_1 {
               leaf bandwidth-limit {
                 description "Bandwidth limit";
                 units "bits per second";
                 type string;
               }
             }
             case case_2 {
               leaf bandwidth-percent {
                 description "Bandwidth limit in percentage";
                 units "percent";
                 type union {
                   type string {
                     pattern "<.*>|$.*";
                   }
                   type uint32 {
                     range "1 .. 100";
                   }
                 }
               }
             }
           }
           leaf burst-size-limit {
             description "Burst size limit";
             units "bytes";
             type string;
           }
         }
       }
       case case_2 {
       }
     }
     container then {
       description "Action to take if the rate limits are exceeded";
       uses apply-advanced;
       leaf discard {
         description "Discard the packet";
         type empty;
       }
       leaf loss-priority {
         description "Packet's loss priority";
         type enumeration {
           enum "low" {
             description "Loss priority low";
           }
           enum "high" {
             description "Loss priority high";
           }
           enum "medium-low" {
             description "Loss priority medium-low";
           }
           enum "medium-high" {
             description "Loss priority medium-high";
           }
         }
       }
       leaf forwarding-class {
         description "Classify packet to forwarding class";
         type string {
           junos:posix-pattern "^.{1,64}$";
           junos:pattern-message "Must be string of 64 characters or less";
         }
       }
     }
   }
   grouping firewall_prefix_list {
     leaf name {
       description "Prefix list to match";
       type string;
     }
     leaf except {
       description "Match addresses not in this prefix list";
       type empty;
     }
   }
   grouping inet6_filter {
     description "Define an IPv6 firewall filter";
     leaf name {
       description "Filter name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf-list accounting-profile {
       description "Accounting profile name";
       junos:must "(\"accounting-options filter-profile\")";
       junos:must-message "referenced accounting profile must be defined";
       type string;
     }
     leaf interface-specific {
       description "Defined counters are interface specific";
       type empty;
     }
     list term {
       key name;
       ordered-by user;
       description "Define a firewall term";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       leaf filter {
         description "Filter to include";
         junos:must "(\"firewall family inet6 filter $$\")";
         junos:must-message "Referenced filter is not defined";
         junos:must "((!(\".. from\") && !(\".. then\")))";
         junos:must-message "Not compatible with 'from or then'";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       container from {
         description "Define match criteria";
         uses apply-advanced;
         choice destination-class_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list destination-class-except {
               description "String name";
               type string;
             }
           }
         }
         choice source-class_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list source-class-except {
               description "String name";
               type string;
             }
           }
         }
         choice interface-group_choice {
           case case_1 {
             leaf-list interface-group {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list interface-group-except {
               description "Range of values";
               type string;
             }
           }
         }
         list source-address {
           key name;
           ordered-by user;
           description "Match  source address";
           uses firewall_addr6_object;
         }
         list destination-address {
           key name;
           ordered-by user;
           description "Match destination address";
           uses firewall_addr6_object;
         }
         list address {
           key name;
           ordered-by user;
           description "Match source or destination address";
           uses firewall_addr6_object;
         }
         list source-prefix-list {
           key name;
           ordered-by user;
           description "Match source prefixes in named list";
           uses firewall_prefix_list;
         }
         list destination-prefix-list {
           key name;
           ordered-by user;
           description "Match destination prefixes in named list";
           uses firewall_prefix_list;
         }
         list prefix-list {
           key name;
           ordered-by user;
           description "Match source or destination prefixes in named list";
           uses firewall_prefix_list;
         }
         choice next-header_choice {
           case case_1 {
             leaf-list next-header {
               type string;
             }
           }
           case case_2 {
             leaf-list next-header-except {
               type string;
             }
           }
         }
         choice payload-protocol_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list payload-protocol-except {
               type string;
             }
           }
         }
         choice source-port_choice {
           case case_1 {
             leaf-list source-port {
               type string;
             }
           }
           case case_2 {
             leaf-list source-port-except {
               type string;
             }
           }
         }
         choice destination-port_choice {
           case case_1 {
             leaf-list destination-port {
               type string;
             }
           }
           case case_2 {
             leaf-list destination-port-except {
               type string;
             }
           }
         }
         choice port_choice {
           case case_1 {
             leaf-list port {
               type string;
             }
           }
           case case_2 {
             leaf-list port-except {
               type string;
             }
           }
         }
         choice extension-header_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list extension-header-except {
               type string;
             }
           }
         }
         choice packet-length_choice {
           case case_1 {
             leaf-list packet-length {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f])(-([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f]))?$";
                 junos:pattern-message "Must be a numeric value or a range between 0-65535";
               }
             }
           }
           case case_2 {
             leaf-list packet-length-except {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f])(-([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f]))?$";
                 junos:pattern-message "Must be a numeric value or a range between 0-65535";
               }
             }
           }
         }
         choice traffic-class_choice {
           case case_1 {
             leaf-list traffic-class {
               type string;
             }
           }
           case case_2 {
             leaf-list traffic-class-except {
               type string;
             }
           }
         }
         choice icmp-type_choice {
           case case_1 {
             leaf-list icmp-type {
               type string;
             }
           }
           case case_2 {
             leaf-list icmp-type-except {
               type string;
             }
           }
         }
         choice icmp-code_choice {
           case case_1 {
             leaf-list icmp-code {
               type string;
             }
           }
           case case_2 {
             leaf-list icmp-code-except {
               type string;
             }
           }
         }
         leaf tcp-initial {
           description "Match initial packet of a TCP connection";
           junos:must "((\".. next-header tcp\" || (\".. next-header 6\" || \".. payload-protocol tcp\")))";
           junos:must-message "next-header tcp or next-header 6 or payload-protocol tcp must be defined in the same clause";
           type empty;
         }
         leaf tcp-established {
           description "Match packet of an established TCP connection";
           junos:must "((\".. next-header tcp\" || (\".. next-header 6\" || \".. payload-protocol tcp\")))";
           junos:must-message "next-header tcp or next-header 6 or payload-protocol tcp must be defined in the same clause";
           type empty;
         }
         leaf tcp-flags {
           description "Match TCP flags (in symbolic or hex formats)";
           junos:must "((\".. next-header tcp\" || (\".. next-header 6\" || \".. payload-protocol tcp\")))";
           junos:must-message "next-header tcp or next-header 6 or payload-protocol tcp must be defined in the same clause";
           junos:must "(\".. next-header tcp\")";
           junos:must-message "next-header tcp must be defined in the same clause";
           junos:must "(!(\".. tcp-established\"))";
           junos:must-message "tcp-flags may not be matched in same rule as tcp-established";
           junos:must "(!(\".. tcp-initial\"))";
           junos:must-message "tcp-flags may not be matched in same rule as tcp-initial";
           type string;
         }
         list interface {
           key name;
           ordered-by user;
           description "Match interface name";
           uses match_interface_object;
         }
         choice forwarding-class_choice {
           case case_1 {
             leaf-list forwarding-class {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list forwarding-class-except {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
         }
         choice loss-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list loss-priority-except {
               type enumeration {
                 enum "low" {
                   description "Loss priority low";
                 }
                 enum "high" {
                   description "Loss priority high";
                 }
                 enum "medium-low" {
                   description "Loss priority medium-low";
                 }
                 enum "medium-high" {
                   description "Loss priority medium-high";
                 }
               }
             }
           }
         }
         choice hop-limit_choice {
           case case_1 {
             leaf-list hop-limit {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|0x[0-f]|0x[0-f][0-f])(-([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|0x[0-f]|0x[0-f][0-f]))?$";
                 junos:pattern-message "Must be a numerical hop-limit value or range between 0-255";
               }
             }
           }
           case case_2 {
             leaf-list hop-limit-except {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|0x[0-f]|0x[0-f][0-f])(-([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|0x[0-f]|0x[0-f][0-f]))?$";
                 junos:pattern-message "Must be a numerical hop-limit value or range between 0-255";
               }
             }
           }
         }
         choice flex-mask_choice {
           case case_1 {
             container flexible-match-mask {
               description "Match flexible mask";
               uses match_L3_flexible_mask;
             }
           }
         }
         choice gre-key_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list gre-key-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice policy-map_choice {
           case case_1 {
             leaf-list policy-map {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list policy-map-except {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         choice policer-choice {
           case case_1 {
             leaf policer {
               description "Name of policer to use to rate-limit traffic";
               junos:must "(!(\"firewall policer $$ aggregate\"))";
               junos:must-message "Cannot attach a aggregate policer to filter";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             container three-color-policer {
               junos:must "(!(\".. loss-priority\"))";
               junos:must-message "cannot support three-color-policer action if loss-priority is configured";
               description "Police the packet using a three-color-policer";
               uses apply-advanced;
               choice type-choice {
                 case case_1 {
                   leaf single-rate {
                     description "Name of single-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-rate\")";
                     junos:must-message "Referenced single-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_2 {
                   leaf single-packet-rate {
                     description "Name of single-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-packet-rate\")";
                     junos:must-message "Referenced single-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_3 {
                   leaf two-rate {
                     description "Name of two-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-rate\")";
                     junos:must-message "Referenced two-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_4 {
                   leaf two-packet-rate {
                     description "Name of two-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-packet-rate\")";
                     junos:must-message "Referenced two-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
               }
             }
           }
           case case_3 {
           }
         }
         choice policy-map-choice {
           case case_1 {
             leaf clear-policy-map {
               description "Clear the policy marking";
               type empty;
             }
           }
           case case_2 {
             leaf policy-map {
               description "Policy map action";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "referenced policy map must be defined";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         choice inet6cnt {
           case case_1 {
           }
           case case_2 {
             leaf count {
               description "Count the packet in the named counter";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         leaf service-accounting {
           description "Count the packets for service accounting";
           junos:must "(!(\".. service-accounting-deferred\"))";
           junos:must-message "'service-accounting-deferred' and 'service-accounting' cannot coexist";
           junos:must "(!(\".. count\"))";
           junos:must-message "'count' and 'service-accounting' cannot coexist";
           type empty;
         }
         leaf service-accounting-deferred {
           description "Count the packets for deferred service accounting";
           junos:must "(!(\".. service-accounting\"))";
           junos:must-message "Cannot be both 'service-accounting' and 'service-accounting-deferred'";
           junos:must "(!(\".. count\"))";
           junos:must-message "'count' and 'service-accounting-deferred' cannot coexist";
           type empty;
         }
         leaf log {
           description "Log the packet";
           type empty;
         }
         leaf pkt-trace {
           description "Trace packet forwarding ";
           type empty;
         }
         leaf syslog {
           description "System log (syslog) information about the packet";
           type empty;
         }
         leaf sample {
           description "Sample the packet";
           junos:must "((\"forwarding-options sampling family inet6\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family inet6\")))";
           junos:must-message "Requires forwarding-options sampling or packet-capture config";
           type empty;
         }
         leaf port-mirror-instance {
           description "Port-mirror the packet to specified instance";
           junos:must "(\"forwarding-options port-mirroring instance $$\")";
           junos:must-message "Referenced port-mirroring instance does not exist";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf port-mirror {
           description "Port-mirror the packet";
           junos:must "(!(\".. port-mirror-instance\"))";
           junos:must-message "'port-mirror' and 'port-mirror-instance' are mutually exclusive";
           junos:must "(\"forwarding-options port-mirroring\")";
           junos:must-message "Configure 'port-mirroring' under 'forwarding-options'";
           type empty;
         }
         leaf analyzer {
           description "Name of analyzer";
           junos:must "(\"ethernet-switching-options analyzer $$\")";
           junos:must-message "Named Analyzer must be set";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf loss-priority {
           description "Packet's loss priority";
           junos:must "(\".. forwarding-class\")";
           junos:must-message "To configure loss-priority, forwarding-class must be set";
           type enumeration {
             enum "low" {
               description "Loss priority low";
             }
             enum "high" {
               description "Loss priority high";
             }
             enum "medium-low" {
               description "Loss priority medium-low";
             }
             enum "medium-high" {
               description "Loss priority medium-high";
             }
           }
         }
         leaf forwarding-class {
           description "Classify packet to forwarding class";
           junos:must "(\".. loss-priority\")";
           junos:must-message "To configure forwarding-class, loss-priority must be set";
           type string {
             junos:posix-pattern "^.{1,64}$";
             junos:pattern-message "Must be string of 64 characters or less";
           }
         }
         leaf traffic-class {
           description "Set traffic-class code point";
           type string;
         }
         leaf skip-services {
           description "Skip the services";
           type empty;
         }
         leaf service-filter-hit {
           description "Marked when packet processing by the current type of chained filters is done, the packet is directed to the next type of filters";
           type empty;
         }
         choice designation {
           case case_1 {
             container decapsulate {
               presence "enable decapsulate";
               description "Terminate a tunnel";
               choice tunnel-protocol {
                 case case_1 {
                   container gre {
                     presence "enable gre";
                     description "GRE protocol";
                     uses apply-advanced;
                     leaf-list sample {
                       description "Sample the packet";
                       junos:must "(!(\".. sampling-instance\"))";
                       junos:must-message "'sampling' and 'sampling-instance' are mutually exclusive";
                       type enumeration {
                         enum "inet" {
                           description "IPV4 protocol";
                           junos:must "((\"forwarding-options sampling family inet\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family inet\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                         enum "inet6" {
                           description "IPV6 protocol";
                           junos:must "((\"forwarding-options sampling family inet6\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family inet6\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                         enum "mpls" {
                           description "MPLS protocol";
                           junos:must "(!(\".. .. sample mpls-ipvx-payload\"))";
                           junos:must-message "Cannot configure both sample mpls and sample mpls-ipvx-payload";
                           junos:must "((\"forwarding-options sampling family mpls\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family mpls\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                       }
                     }
                     leaf no-decrement-ttl {
                       description "Do not decrement TTL";
                       type empty;
                     }
                     leaf forwarding-class {
                       description "Classify packet to forwarding class";
                       type string {
                         junos:posix-pattern "^.{1,64}$";
                         junos:pattern-message "Must be string of 64 characters or less";
                       }
                     }
                     leaf interface-group {
                       description "Set the interface group";
                       type union {
                         type string {
                           pattern "<.*>|$.*";
                         }
                         type uint32 {
                           range "0 .. 255";
                         }
                       }
                     }
                     choice destination {
                       case case_1 {
                         container routing-instance {
                           description "Packets are directed to specified routing instance";
                           leaf routing-instance-name {
                             description "Name of routing instance";
                             junos:must "(\"routing-instances $$\")";
                             junos:must-message "referenced routing instance must be defined";
                             type string {
                               junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                               junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                             }
                           }
                         }
                       }
                     }
                   }
                 }
                 case case_2 {
                 }
                 case case_3 {
                 }
                 case case_4 {
                   container l2tp {
                     description "L2TP protocol";
                     uses apply-advanced;
                     leaf-list sample {
                       description "Sample the packet";
                       junos:must "(!(\".. sampling-instance\"))";
                       junos:must-message "'sampling' and 'sampling-instance' are mutually exclusive";
                       type enumeration {
                         enum "inet" {
                           description "IPV4 protocol";
                           junos:must "((\"forwarding-options sampling family inet\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family inet\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                         enum "inet6" {
                           description "IPV6 protocol";
                           junos:must "((\"forwarding-options sampling family inet6\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family inet6\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                         enum "mpls" {
                           description "MPLS protocol";
                           junos:must "(!(\".. .. sample mpls-ipvx-payload\"))";
                           junos:must-message "Cannot configure both sample mpls and sample mpls-ipvx-payload";
                           junos:must "((\"forwarding-options sampling family mpls\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family mpls\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                       }
                     }
                     leaf no-decrement-ttl {
                       description "Do not decrement TTL";
                       type empty;
                     }
                     leaf forwarding-class {
                       description "Classify packet to forwarding class";
                       type string {
                         junos:posix-pattern "^.{1,64}$";
                         junos:pattern-message "Must be string of 64 characters or less";
                       }
                     }
                     leaf interface-group {
                       description "Set the interface group";
                       type union {
                         type string {
                           pattern "<.*>|$.*";
                         }
                         type uint32 {
                           range "0 .. 255";
                         }
                       }
                     }
                     leaf-list cookie {
                       description "L2TPv3 cookie";
                       type string {
                         length "1 .. 32";
                       }
                     }
                     choice destination {
                       case case_1 {
                         leaf output-interface {
                           description "Interface name";
                           junos:must "(\"interfaces $$\")";
                           junos:must-message "Interface must be defined in the interfaces hierarchy";
                           type union {
                             type jt:interface-unit;
                             type string {
                               pattern "<.*>|$.*";
                             }
                           }
                         }
                       }
                     }
                   }
                 }
               }
             }
           }
           case case_2 {
           }
           case case_3 {
             leaf accept {
               description "Accept the packet";
               type empty;
             }
           }
           case case_4 {
             leaf discard {
               description "Discard the packet";
               type empty;
             }
           }
           case case_5 {
             leaf next {
               description "Continue to next term in a filter";
               type enumeration {
                 enum "term" {
                   description "Continue to next term in a filter";
                 }
               }
             }
           }
           case case_6 {
           }
           case case_7 {
             list logical-system {
               key logical-system-name;
               ordered-by user;
               description "Packets are directed to specified logical system";
               max-elements 1;
               leaf logical-system-name {
                 description "Name of logical system";
                 type string {
                   junos:posix-pattern "^[a-zA-Z0-9_-]{1,63}$";
                   junos:pattern-message "Logical-system name is a string consisting of up to 63 letters, numbers, dashes and underscores";
                 }
               }
               container routing-instance {
                 description "Packets are directed to specified routing instance";
                 leaf routing-instance-name {
                   description "Name of routing instance";
                   type string {
                     junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                   }
                 }
                 leaf topology {
                   description "Packets are directed to specified topology";
                   type string {
                     junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                   }
                 }
               }
               leaf topology {
                 description "Packets are directed to specified topology";
                 type string {
                   junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                   junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                 }
               }
             }
           }
           case case_8 {
             container routing-instance {
               description "Packets are directed to specified routing instance";
               leaf routing-instance-name {
                 description "Name of routing instance";
                 type string {
                   junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                   junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                 }
               }
               leaf topology {
                 description "Packets are directed to specified topology";
                 type string {
                   junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                   junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                 }
               }
             }
           }
           case case_9 {
             leaf topology {
               description "Packets are directed to specified topology";
               type string {
                 junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                 junos:pattern-message "Must be a non-reserved string of 128 characters or less";
               }
             }
           }
           case case_10 {
             container next-ip6 {
               description "Packets are directed to specified the specified ipv6 address";
               leaf address {
                 description "Address to route";
                 type jt:ipv6prefix;
               }
               container routing-instance {
                 description "Packets are directed to specified routing instance";
                 leaf routing-instance-name {
                   description "Name of routing instance";
                   type string {
                     junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                   }
                 }
                 leaf topology {
                   description "Packets are directed to specified topology";
                   type string {
                     junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                   }
                 }
               }
             }
           }
           case case_11 {
             container next-interface {
               presence "enable next-interface";
               description "Packets are to be routed through the specified interface";
               uses apply-advanced;
               leaf interface-name {
                 description "Interface name";
                 type string {
                   length "1 .. 127";
                   junos:posix-pattern "^((ge-)|(xe-)|(et-)|(gr-)|(ae)|(irb))";
                   junos:pattern-message "Only ge, xe, et, ae, irb and point-to-point gr tunnel intefaces are supported";
                 }
               }
               container routing-instance {
                 description "Packets are directed to specified routing instance";
                 leaf routing-instance-name {
                   description "Name of routing instance";
                   type string {
                     junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                   }
                 }
                 leaf topology {
                   description "Packets are directed to specified topology";
                   type string {
                     junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                   }
                 }
               }
               choice designation {
                 case case_1 {
                   leaf accept {
                     description "Accept the packet";
                     type empty;
                   }
                 }
                 case case_2 {
                   leaf next {
                     description "Continue to next term in a filter";
                     type enumeration {
                       enum "term" {
                         description "Continue to next term in a filter";
                       }
                     }
                   }
                 }
               }
             }
           }
           case case_12 {
             container reject {
               presence "enable reject";
               description "Reject the packet";
               choice style {
                 case case_1 {
                   leaf no-route {
                     description "Send ICMPv6 No Route message";
                     type empty;
                   }
                 }
                 case case_2 {
                   leaf administratively-prohibited {
                     description "Send ICMPv6 Administratively Prohibited message";
                     type empty;
                   }
                 }
                 case case_3 {
                   leaf beyond-scope {
                     description "Send ICMPv6 Beyond Scope of Source Address message";
                     type empty;
                   }
                 }
                 case case_4 {
                   leaf address-unreachable {
                     description "Send ICMPv6 Address Unreachable message";
                     type empty;
                   }
                 }
                 case case_5 {
                   leaf port-unreachable {
                     description "Send ICMPv6 Port Unreachable message";
                     type empty;
                   }
                 }
                 case case_6 {
                   leaf tcp-reset {
                     description "Send TCP Reset message";
                     type empty;
                   }
                 }
                 case case_7 {
                   leaf network-unreachable {
                     description "Send ICMPv4 Network Unreachable message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_8 {
                   leaf host-unreachable {
                     description "Send ICMPv4 Host Unreachable message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_9 {
                   leaf protocol-unreachable {
                     description "Send ICMPv4 Protocol Unreachable message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_10 {
                   leaf source-route-failed {
                     description "Send ICMPv4 Source Route Failed message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_11 {
                   leaf network-unknown {
                     description "Send ICMPv4 Network Unknown message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_12 {
                   leaf host-unknown {
                     description "Send ICMPv4 Host Unknown message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_13 {
                   leaf source-host-isolated {
                     description "Send ICMPv4 Source Host Isolated message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_14 {
                   leaf network-prohibited {
                     description "Send ICMPv4 Network Prohibited message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_15 {
                   leaf host-prohibited {
                     description "Send ICMPv4 Host Prohibited message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_16 {
                   leaf bad-network-tos {
                     description "Send ICMPv4 Bad Network ToS message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_17 {
                   leaf bad-host-tos {
                     description "Send ICMPv4 Bad Host ToS message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_18 {
                   leaf precedence-violation {
                     description "Send ICMPv4 Precedence Violation message";
                     status deprecated;
                     type empty;
                   }
                 }
                 case case_19 {
                   leaf precedence-cutoff {
                     description "Send ICMPv4 Precedence Cutoff message";
                     status deprecated;
                     type empty;
                   }
                 }
               }
             }
           }
         }
       }
       container template {
         description "Refer a template";
         uses apply-advanced;
         leaf template-name {
           description "Template name";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
       }
     }
   }
   grouping inet6_fuf {
     leaf name {
       description "Name of fast update filter";
       junos:must "(unique \"firewall family <*> filter $$\")";
       junos:must-message "Fast update filter can not have the same name as firewall family filter";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf interface-specific {
       description "Defined counters are interface specific";
       type empty;
     }
     leaf-list match-order {
       type enumeration {
         enum "next-header" {
           description "Include next header protocol in match set";
         }
         enum "payload-protocol" {
           description "Include payload protocol in match set";
         }
         enum "source-address" {
           description "Include source-address in match set";
         }
         enum "destination-address" {
           description "Include destination-address in match set";
         }
         enum "source-port" {
           description "Include source-port in match set";
         }
         enum "destination-port" {
           description "Include destination-port in match set";
         }
         enum "traffic-class" {
           description "Include traffic-class (DSCP) in match set";
         }
       }
     }
     list term {
       key name;
       ordered-by user;
       description "One or more firewall terms";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       leaf only-at-create {
         description "Add term only when filter is first created.";
         type empty;
       }
       container from {
         description "Match criteria";
         uses apply-advanced;
         container source-address {
           description "Match source IP address";
           uses firewall_addr6_simple_object;
         }
         container destination-address {
           description "Match destination IP address";
           uses firewall_addr6_simple_object;
         }
         choice source-port_choice {
           case case_1 {
             container source-port {
               description "Match TCP/UDP source port";
               uses match_simple_port_value;
             }
           }
         }
         choice destination-port_choice {
           case case_1 {
             container destination-port {
               description "Match TCP/UDP destination port";
               uses match_simple_port_value;
             }
           }
         }
         choice next-header_choice {
           case case_1 {
             container next-header {
               description "Match next header protocol type";
               uses match_simple_protocol_value;
             }
           }
         }
         choice traffic-class_choice {
           case case_1 {
             container traffic-class {
               description "Match Differentiated Services (DiffServ) code point";
               uses match_simple_dscp_value;
             }
           }
         }
         leaf match-terms {
           description "Dynamically supplied list of match criteria";
           type string;
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         choice policer-choice {
           case case_1 {
             leaf policer {
               description "Name of policer to use to rate-limit traffic";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         leaf count {
           description "Count the packet in the named counter";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf service-accounting {
           description "Count the packets for service accounting";
           junos:must "(!(\".. count\"))";
           junos:must-message "'count' and 'service-accounting' cannot coexist";
           type empty;
         }
         leaf log {
           description "Log the packet";
           type empty;
         }
         leaf port-mirror {
           description "Port-mirror the packet";
           type empty;
         }
         leaf loss-priority {
           description "Packet's loss priority";
           junos:must "(!(\".. three-color-policer\"))";
           junos:must-message "Configuring loss-priority is incompatible with configuring three-color-policer";
           junos:must "(\".. forwarding-class\")";
           junos:must-message "To configure loss-priority, forwarding-class must be set";
           type enumeration {
             enum "low" {
               description "Loss priority low";
             }
             enum "high" {
               description "Loss priority high";
             }
             enum "medium-low" {
               description "Loss priority medium-low";
             }
             enum "medium-high" {
               description "Loss priority medium-high";
             }
           }
         }
         leaf forwarding-class {
           description "Classify packet to forwarding class";
           junos:must "(\".. loss-priority\")";
           junos:must-message "To configure forwarding-class, loss-priority must be set";
           type string {
             junos:posix-pattern "^.{1,64}$";
             junos:pattern-message "Must be string of 64 characters or less";
           }
         }
         leaf action-terms {
           description "Dynamically supplied list of actions";
           type string;
         }
         choice designation {
           case case_1 {
             leaf accept {
               description "Accept the packet";
               type empty;
             }
           }
           case case_2 {
             leaf discard {
               description "Discard the packet";
               type empty;
             }
           }
           case case_3 {
             container routing-instance {
               description "Packets are directed to specified routing instance";
               leaf routing-instance-name {
                 description "Name of routing instance";
                 type string {
                   junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                   junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                 }
               }
               leaf topology {
                 description "Packets are directed to specified topology";
                 type string {
                   junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                   junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                 }
               }
             }
           }
         }
       }
     }
   }
   grouping firewall_addr6_simple_object {
     uses apply-advanced;
     leaf address {
       description "Prefix to match";
       type jt:ipv6prefix;
     }
   }
   grouping inet6_service_filter {
     leaf name {
       description "Filter name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     list term {
       key name;
       ordered-by user;
       description "Service filter term";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       container from {
         description "Match criteria";
         uses apply-advanced;
         choice interface-group_choice {
           case case_1 {
             leaf-list interface-group {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list interface-group-except {
               description "Range of values";
               type string;
             }
           }
         }
         list source-address {
           key name;
           ordered-by user;
           description "Match  source address";
           uses firewall_addr6_object;
         }
         list destination-address {
           key name;
           ordered-by user;
           description "Match destination address";
           uses firewall_addr6_object;
         }
         list address {
           key name;
           ordered-by user;
           description "Match source or destination address";
           uses firewall_addr6_object;
         }
         list source-prefix-list {
           key name;
           ordered-by user;
           description "Match source prefixes in named list";
           uses firewall_prefix_list;
         }
         list destination-prefix-list {
           key name;
           ordered-by user;
           description "Match destination prefixes in named list";
           uses firewall_prefix_list;
         }
         list prefix-list {
           key name;
           ordered-by user;
           description "Match source or destination prefixes in named list";
           uses firewall_prefix_list;
         }
         choice next-header_choice {
           case case_1 {
             leaf-list next-header {
               type string;
             }
           }
           case case_2 {
             leaf-list next-header-except {
               type string;
             }
           }
         }
         choice payload-protocol_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list payload-protocol-except {
               type string;
             }
           }
         }
         choice source-port_choice {
           case case_1 {
             leaf-list source-port {
               type string;
             }
           }
           case case_2 {
             leaf-list source-port-except {
               type string;
             }
           }
         }
         choice destination-port_choice {
           case case_1 {
             leaf-list destination-port {
               type string;
             }
           }
           case case_2 {
             leaf-list destination-port-except {
               type string;
             }
           }
         }
         choice port_choice {
           case case_1 {
             leaf-list port {
               type string;
             }
           }
           case case_2 {
             leaf-list port-except {
               type string;
             }
           }
         }
         choice extension-header_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list extension-header-except {
               type string;
             }
           }
         }
         choice esp-spi_choice {
           case case_1 {
             leaf-list esp-spi {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list esp-spi-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice ah-spi_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ah-spi-except {
               description "Range of values";
               type string;
             }
           }
         }
         leaf tcp-flags {
           description "Match TCP flags (in symbolic or hex formats)";
           junos:must "(!(\".. tcp-established\"))";
           junos:must-message "tcp-flags may not be matched in same rule as tcp-established";
           junos:must "(!(\".. tcp-initial\"))";
           junos:must-message "tcp-flags may not be matched in same rule as tcp-initial";
           type string;
         }
         choice loss-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list loss-priority-except {
               type enumeration {
                 enum "low" {
                   description "Loss priority low";
                 }
                 enum "high" {
                   description "Loss priority high";
                 }
                 enum "medium-low" {
                   description "Loss priority medium-low";
                 }
                 enum "medium-high" {
                   description "Loss priority medium-high";
                 }
               }
             }
           }
         }
         choice forwarding-class_choice {
           case case_1 {
             leaf-list forwarding-class {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list forwarding-class-except {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         leaf count {
           description "Count the packet in the named counter";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf log {
           description "Log the packet";
           type empty;
         }
         leaf pkt-trace {
           description "Pkt-Trace the packet";
           type empty;
         }
         leaf sample {
           description "Sample the packet";
           type empty;
         }
         leaf port-mirror {
           description "Port-mirror the packet";
           type empty;
         }
         choice designation {
           case case_1 {
             leaf service {
               description "Forward packets to service processing";
               type empty;
             }
           }
           case case_2 {
             leaf skip {
               description "Skip service processing";
               type empty;
             }
           }
           case case_3 {
           }
         }
       }
     }
   }
   grouping inet6_template {
     leaf name {
       description "Template name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     container attributes {
       description "Template attributes";
       uses apply-advanced;
       leaf destination-address {
         description "Match destination address";
         type empty;
       }
       leaf destination-port {
         description "Match TCP/UDP destination port";
         type empty;
       }
       leaf destination-prefix-list {
         description "Match destination prefixes in named list";
         type empty;
       }
       leaf flexible-match-mask {
         description "Match flexible mask";
         type empty;
       }
       leaf flexible-match-range {
         description "Match ICMP message code";
         type empty;
       }
       leaf hop-limit {
         description "Match Hop Limit";
         type empty;
       }
       leaf icmp-code {
         description "Match ICMP message code";
         type empty;
       }
       leaf icmp-type {
         description "Match ICMP message code";
         type empty;
       }
       leaf interface {
         description "Match interface name";
         type empty;
       }
       leaf next-header {
         description "Match next header protocol type";
         type empty;
       }
       leaf source-address {
         description "Match  source address";
         type empty;
       }
       leaf source-port {
         description "Match TCP/UDP source port";
         type empty;
       }
       leaf source-prefix-list {
         description "Match source prefixes in named list";
         type empty;
       }
       leaf tcp-established {
         description "Match packet of an established TCP connection";
         type empty;
       }
       leaf tcp-flags {
         description "Match TCP flags";
         type empty;
       }
       leaf tcp-initial {
         description "Match initial packet of a TCP connection";
         type empty;
       }
       leaf traffic-class {
         description "Match Differentiated Services (DiffServ) code point";
         type empty;
       }
     }
   }
   grouping inet_dialer_filter {
     leaf name {
       description "Filter name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf-list accounting-profile {
       description "Accounting profile name";
       junos:must "(\"accounting-options filter-profile\")";
       junos:must-message "referenced accounting profile must be defined";
       type string;
     }
     list term {
       key name;
       ordered-by user;
       description "Define a firewall term";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       container from {
         description "Define match criteria";
         uses apply-advanced;
         list source-address {
           key name;
           ordered-by user;
           description "Match IP source address";
           uses firewall_addr_object;
         }
         list destination-address {
           key name;
           ordered-by user;
           description "Match IP destination address";
           uses firewall_addr_object;
         }
         list address {
           key name;
           ordered-by user;
           description "Match IP source or destination address";
           uses firewall_addr_object;
         }
         list source-prefix-list {
           key name;
           ordered-by user;
           description "Match IP source prefixes in named list";
           uses firewall_prefix_list;
         }
         list destination-prefix-list {
           key name;
           ordered-by user;
           description "Match IP destination prefixes in named list";
           uses firewall_prefix_list;
         }
         list prefix-list {
           key name;
           ordered-by user;
           description "Match IP source or destination prefixes in named list";
           uses firewall_prefix_list;
         }
         choice packet-length_choice {
           case case_1 {
             leaf-list packet-length {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f])(-([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f]))?$";
                 junos:pattern-message "Must be a numeric value or a range between 0-65535";
               }
             }
           }
           case case_2 {
             leaf-list packet-length-except {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f])(-([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f]))?$";
                 junos:pattern-message "Must be a numeric value or a range between 0-65535";
               }
             }
           }
         }
         choice precedence_choice {
           case case_1 {
             leaf-list precedence {
               type string;
             }
           }
           case case_2 {
             leaf-list precedence-except {
               type string;
             }
           }
         }
         choice dscp_choice {
           case case_1 {
             leaf-list dscp {
               type string;
             }
           }
           case case_2 {
             leaf-list dscp-except {
               type string;
             }
           }
         }
         choice ip-options_choice {
           case case_1 {
             leaf-list ip-options {
               type string;
             }
           }
           case case_2 {
             leaf-list ip-options-except {
               type string;
             }
           }
         }
         leaf is-fragment {
           description "Match if packet is a fragment";
           type empty;
         }
         leaf first-fragment {
           description "Match if packet is the first fragment";
           type empty;
         }
         choice fragment-offset_choice {
           case case_1 {
             leaf-list fragment-offset {
               description "Range of values";
               type string {
                 junos:posix-pattern "^[[:digit:]]+(-[[:digit:]]+)?$";
                 junos:pattern-message "Must be a in form of number or a range in the form '<minimum-value>-<maximum-value>'";
               }
             }
           }
           case case_2 {
             leaf-list fragment-offset-except {
               description "Range of values";
               type string {
                 junos:posix-pattern "^[[:digit:]]+(-[[:digit:]]+)?$";
                 junos:pattern-message "Must be a in form of number or a range in the form '<minimum-value>-<maximum-value>'";
               }
             }
           }
         }
         leaf fragment-flags {
           description "Match fragment flags";
           type string;
         }
         choice protocol_choice {
           case case_1 {
             leaf-list protocol {
               type string;
             }
           }
           case case_2 {
             leaf-list protocol-except {
               type string;
             }
           }
         }
         choice ttl_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ttl-except {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|0x[0-f]|0x[0-f][0-f])(-([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|0x[0-f]|0x[0-f][0-f]))?$";
                 junos:pattern-message "Must be a numerical TTL value or range between 0-255";
               }
             }
           }
         }
         choice icmp-type_choice {
           case case_1 {
             leaf-list icmp-type {
               type string;
             }
           }
           case case_2 {
             leaf-list icmp-type-except {
               type string;
             }
           }
         }
         choice icmp-code_choice {
           case case_1 {
             leaf-list icmp-code {
               type string;
             }
           }
           case case_2 {
             leaf-list icmp-code-except {
               type string;
             }
           }
         }
         choice source-port_choice {
           case case_1 {
             leaf-list source-port {
               type string;
             }
           }
           case case_2 {
             leaf-list source-port-except {
               type string;
             }
           }
         }
         choice destination-port_choice {
           case case_1 {
             leaf-list destination-port {
               type string;
             }
           }
           case case_2 {
             leaf-list destination-port-except {
               type string;
             }
           }
         }
         choice port_choice {
           case case_1 {
             leaf-list port {
               type string;
             }
           }
           case case_2 {
             leaf-list port-except {
               type string;
             }
           }
         }
         leaf tcp-initial {
           description "Match initial packet of a TCP connection";
           type empty;
         }
         leaf tcp-established {
           description "Match packet of an established TCP connection";
           type empty;
         }
         leaf tcp-flags {
           description "Match TCP flags (in symbolic or hex formats)";
           type string;
         }
         choice esp-spi_choice {
           case case_1 {
             leaf-list esp-spi {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list esp-spi-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice ah-spi_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ah-spi-except {
               description "Range of values";
               type string;
             }
           }
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         leaf log {
           description "Log the packet";
           type empty;
         }
         leaf syslog {
           description "System log (syslog) information about the packet";
           type empty;
         }
         leaf sample {
           description "Sample the packet";
           type empty;
         }
         choice designation {
           case case_1 {
             leaf note {
               description "Interested ISDN packet";
               type empty;
             }
           }
           case case_2 {
             leaf ignore {
               description "Non-interested ISDN packet";
               type empty;
             }
           }
         }
       }
     }
   }
   grouping inet_filter {
     leaf name {
       description "Filter name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf-list accounting-profile {
       description "Accounting profile name";
       junos:must "(\"accounting-options filter-profile\")";
       junos:must-message "referenced accounting profile must be defined";
       type string;
     }
     leaf interface-specific {
       description "Defined counters are interface specific";
       type empty;
     }
     list term {
       key name;
       ordered-by user;
       description "Define a firewall term";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       leaf filter {
         description "Filter to include";
         junos:must "((\"firewall filter $$\" || \"firewall family inet filter $$\"))";
         junos:must-message "Referenced filter is not defined";
         junos:must "((!(\".. from\") && !(\".. then\")))";
         junos:must-message "Not compatible with 'from or then'";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       container from {
         description "Define match criteria";
         uses apply-advanced;
         choice destination-class_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list destination-class-except {
               description "String name";
               type string;
             }
           }
         }
         choice source-class_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list source-class-except {
               description "String name";
               type string;
             }
           }
         }
         choice interface-group_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list interface-group-except {
               description "Range of values";
               type string;
             }
           }
         }
         list source-address {
           key name;
           ordered-by user;
           description "Match IP source address";
           uses firewall_addr_object;
         }
         list destination-address {
           key name;
           ordered-by user;
           description "Match IP destination address";
           uses firewall_addr_object;
         }
         list source-prefix-list {
           key name;
           ordered-by user;
           description "Match IP source prefixes in named list";
           uses firewall_prefix_list;
         }
         list destination-prefix-list {
           key name;
           ordered-by user;
           description "Match IP destination prefixes in named list";
           uses firewall_prefix_list;
         }
         choice packet-length_choice {
           case case_1 {
             leaf-list packet-length {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f])(-([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f]))?$";
                 junos:pattern-message "Must be a numeric value or a range between 0-65535";
               }
             }
           }
           case case_2 {
             leaf-list packet-length-except {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f])(-([0-9]{1,4}|[1-5][0-9][0-9][0-9][0-9]|[6][0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f]))?$";
                 junos:pattern-message "Must be a numeric value or a range between 0-65535";
               }
             }
           }
         }
         choice dscp_choice {
           case case_1 {
             leaf-list dscp {
               type string;
             }
           }
           case case_2 {
             leaf-list dscp-except {
               type string;
             }
           }
         }
         choice precedence_choice {
           case case_1 {
             leaf-list precedence {
               type string;
             }
           }
           case case_2 {
             leaf-list precedence-except {
               type string;
             }
           }
         }
         choice ip-options_choice {
           case case_1 {
             leaf-list ip-options {
               type string;
             }
           }
           case case_2 {
             leaf-list ip-options-except {
               type string;
             }
           }
         }
         leaf is-fragment {
           description "Match if packet is a fragment";
           type empty;
         }
         choice fragment-offset_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list fragment-offset-except {
               description "Range of values";
               type string {
                 junos:posix-pattern "^[[:digit:]]+(-[[:digit:]]+)?$";
                 junos:pattern-message "Must be a in form of number or a range in the form '<minimum-value>-<maximum-value>'";
               }
             }
           }
         }
         leaf fragment-flags {
           description "Match fragment flags (in symbolic or hex formats) - (Ingress only)";
           type string {
             junos:posix-pattern "^(0x4000|0x2000|dont-fragment|more-fragments)$";
             junos:pattern-message "fragment-flags must be either dont-fragment(0x4000) or more-fragments(0x2000)";
           }
         }
         choice protocol_choice {
           case case_1 {
             leaf-list protocol {
               type string;
             }
           }
           case case_2 {
             leaf-list protocol-except {
               type string;
             }
           }
         }
         choice ttl_choice {
           case case_1 {
             leaf-list ttl {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|0x[0-f]|0x[0-f][0-f])(-([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|0x[0-f]|0x[0-f][0-f]))?$";
                 junos:pattern-message "Must be a numerical TTL value or range between 0-255";
               }
             }
           }
           case case_2 {
             leaf-list ttl-except {
               description "Range of values";
               type string {
                 junos:posix-pattern "^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|0x[0-f]|0x[0-f][0-f])(-([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|0x[0-f]|0x[0-f][0-f]))?$";
                 junos:pattern-message "Must be a numerical TTL value or range between 0-255";
               }
             }
           }
         }
         choice icmp-type_choice {
           case case_1 {
             leaf-list icmp-type {
               type string;
             }
           }
           case case_2 {
             leaf-list icmp-type-except {
               type string;
             }
           }
         }
         choice icmp-code_choice {
           case case_1 {
             leaf-list icmp-code {
               type string;
             }
           }
           case case_2 {
             leaf-list icmp-code-except {
               type string;
             }
           }
         }
         choice source-port_choice {
           case case_1 {
             leaf-list source-port {
               type string;
             }
           }
           case case_2 {
             leaf-list source-port-except {
               type string;
             }
           }
         }
         choice destination-port_choice {
           case case_1 {
             leaf-list destination-port {
               type string;
             }
           }
           case case_2 {
             leaf-list destination-port-except {
               type string;
             }
           }
         }
         choice port_choice {
           case case_1 {
             leaf-list port {
               type string;
             }
           }
           case case_2 {
             leaf-list port-except {
               type string;
             }
           }
         }
         leaf tcp-initial {
           description "Match initial packet of a TCP connection";
           type empty;
         }
         leaf tcp-established {
           description "Match packet of an established TCP connection";
           type empty;
         }
         leaf tcp-flags {
           description "Match TCP flags (in symbolic or hex formats)";
           junos:must "(!(\".. tcp-established\"))";
           junos:must-message "tcp-flags may not be matched in same rule as tcp-established";
           junos:must "(!(\".. tcp-initial\"))";
           junos:must-message "tcp-flags may not be matched in same rule as tcp-initial";
           type string;
         }
         choice esp-spi_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list esp-spi-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice ah-spi_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ah-spi-except {
               description "Range of values";
               type string;
             }
           }
         }
         list interface {
           key name;
           ordered-by user;
           description "Match interface name";
           uses match_interface_object;
         }
         choice forwarding-class_choice {
           case case_1 {
             leaf-list forwarding-class {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list forwarding-class-except {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
         }
         choice loss-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list loss-priority-except {
               type enumeration {
                 enum "low" {
                   description "Loss priority low";
                 }
                 enum "high" {
                   description "Loss priority high";
                 }
                 enum "medium-low" {
                   description "Loss priority medium-low";
                 }
                 enum "medium-high" {
                   description "Loss priority medium-high";
                 }
               }
             }
           }
         }
         leaf source-port-range-optimize {
           description "Optimize the source port range";
           type empty;
         }
         leaf destination-port-range-optimize {
           description "Optimize the destination port range";
           type empty;
         }
         choice rat-type_choice {
           case case_1 {
             leaf-list rat-type {
               type string;
             }
           }
           case case_2 {
             leaf-list rat-type-except {
               type string;
             }
           }
         }
         choice redirect-reason_choice {
           case case_1 {
             leaf-list redirect-reason {
               type enumeration {
                 enum "aoc" {
                   description "Advice of Charge";
                 }
                 enum "aolb" {
                   description "Advice of Low Balance";
                 }
                 enum "dpi" {
                   description "Layer7 match required";
                 }
               }
             }
           }
           case case_2 {
             leaf-list redirect-reason-except {
               type enumeration {
                 enum "aoc" {
                   description "Advice of Charge";
                 }
                 enum "aolb" {
                   description "Advice of Low Balance";
                 }
                 enum "dpi" {
                   description "Layer7 match required";
                 }
               }
             }
           }
         }
         choice gre-key_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list gre-key-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice flex-mask_choice {
           case case_1 {
             container flexible-match-mask {
               description "Match flexible mask";
               uses match_L3_flexible_mask;
             }
           }
         }
         choice policy-map_choice {
           case case_1 {
             leaf-list policy-map {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list policy-map-except {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         choice policer-choice {
           case case_1 {
             leaf policer {
               description "Name of policer to use to rate-limit traffic";
               junos:must "(!(\"firewall policer $$ aggregate\"))";
               junos:must-message "Cannot attach a aggregate policer to filter";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             container three-color-policer {
               junos:must "(!(\".. loss-priority\"))";
               junos:must-message "cannot support three-color-policer action if loss-priority is configured";
               description "Police the packet using a three-color-policer";
               uses apply-advanced;
               choice type-choice {
                 case case_1 {
                   leaf single-rate {
                     description "Name of single-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-rate\")";
                     junos:must-message "Referenced single-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_2 {
                   leaf single-packet-rate {
                     description "Name of single-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-packet-rate\")";
                     junos:must-message "Referenced single-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_3 {
                   leaf two-rate {
                     description "Name of two-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-rate\")";
                     junos:must-message "Referenced two-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_4 {
                   leaf two-packet-rate {
                     description "Name of two-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-packet-rate\")";
                     junos:must-message "Referenced two-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
               }
             }
           }
           case case_3 {
           }
         }
         choice policy-map-choice {
           case case_1 {
             leaf clear-policy-map {
               description "Clear the policy marking";
               type empty;
             }
           }
           case case_2 {
             leaf policy-map {
               description "Policy map action";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "referenced policy map must be defined";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         choice inetcnt {
           case case_1 {
           }
           case case_2 {
             leaf count {
               description "Count the packet in the named counter";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         leaf service-accounting {
           description "Count the packets for service accounting";
           junos:must "(!(\".. service-accounting-deferred\"))";
           junos:must-message "'service-accounting-deferred' and 'service-accounting' cannot coexist";
           junos:must "(!(\".. count\"))";
           junos:must-message "'count' and 'service-accounting' cannot coexist";
           type empty;
         }
         leaf skip-services {
           description "Skip the services";
           type empty;
         }
         leaf service-accounting-deferred {
           description "Count the packets for deferred service accounting";
           junos:must "(!(\".. service-accounting\"))";
           junos:must-message "Cannot be both 'service-accounting' and 'service-accounting-deferred'";
           junos:must "(!(\".. count\"))";
           junos:must-message "'count' and 'service-accounting-deferred' cannot coexist";
           type empty;
         }
         leaf log {
           description "Log the packet";
           type empty;
         }
         leaf pkt-trace {
           description "Trace the packet";
           type empty;
         }
         leaf syslog {
           description "System log (syslog) information about the packet";
           type empty;
         }
         leaf sample {
           description "Sample the packet";
           junos:must "(!(\".. sampling-instance\"))";
           junos:must-message "'sampling' and 'sampling-instance' are mutually exclusive";
           junos:must "((\"forwarding-options sampling family inet\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family inet\")))";
           junos:must-message "Requires forwarding-options sampling or packet-capture config";
           type empty;
         }
         leaf port-mirror-instance {
           description "Port-mirror the packet to specified instance";
           junos:must "(\"forwarding-options port-mirroring instance $$\")";
           junos:must-message "Referenced port-mirroring instance does not exist";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf port-mirror {
           description "Port-mirror the packet";
           junos:must "(!(\".. port-mirror-instance\"))";
           junos:must-message "'port-mirror' and 'port-mirror-instance' are mutually exclusive";
           junos:must "(\"forwarding-options port-mirroring\")";
           junos:must-message "Configure 'port-mirroring' under 'forwarding-options'";
           type empty;
         }
         leaf analyzer {
           description "Name of analyzer - (Ingress only)";
           junos:must "(\"ethernet-switching-options analyzer $$\")";
           junos:must-message "Named Analyzer must be set";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf loss-priority {
           description "Packet's loss priority";
           junos:must "(!(\".. three-color-policer\"))";
           junos:must-message "Configuring loss-priority is incompatible with configuring three-color-policer";
           junos:must "(\".. forwarding-class\")";
           junos:must-message "To configure loss-priority, forwarding-class must be set";
           type enumeration {
             enum "low" {
               description "Loss priority low";
             }
             enum "high" {
               description "Loss priority high";
             }
             enum "medium-low" {
               description "Loss priority medium-low";
             }
             enum "medium-high" {
               description "Loss priority medium-high";
             }
           }
         }
         leaf forwarding-class {
           description "Classify packet to forwarding class";
           junos:must "(\".. loss-priority\")";
           junos:must-message "To configure forwarding-class, loss-priority must be set";
           type string {
             junos:posix-pattern "^.{1,64}$";
             junos:pattern-message "Must be string of 64 characters or less";
           }
         }
         leaf service-filter-hit {
           description "Marked when packet processing by the current type of chained filters is done, the packet is directed to the next type of filters";
           type empty;
         }
         choice designation {
           case case_1 {
             leaf accept {
               description "Accept the packet";
               type empty;
             }
           }
           case case_2 {
             container discard {
               presence "enable discard";
               description "Discard the packet";
               uses apply-advanced;
               leaf accounting {
                 description "Named discard collector for packet";
                 type string;
               }
             }
           }
           case case_3 {
             leaf next {
               description "Continue to next term in a filter";
               type enumeration {
                 enum "term" {
                   description "Continue to next term in a filter";
                 }
               }
             }
           }
           case case_4 {
             list logical-system {
               key logical-system-name;
               ordered-by user;
               description "Packets are directed to specified logical system";
               max-elements 1;
               leaf logical-system-name {
                 description "Name of logical system";
                 type string {
                   junos:posix-pattern "^[a-zA-Z0-9_-]{1,63}$";
                   junos:pattern-message "Logical-system name is a string consisting of up to 63 letters, numbers, dashes and underscores";
                 }
               }
               container routing-instance {
                 description "Packets are directed to specified routing instance";
                 leaf routing-instance-name {
                   description "Name of routing instance";
                   type string {
                     junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                   }
                 }
                 leaf topology {
                   description "Packets are directed to specified topology";
                   type string {
                     junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                   }
                 }
               }
               leaf topology {
                 description "Packets are directed to specified topology";
                 type string {
                   junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                   junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                 }
               }
             }
           }
           case case_5 {
             container routing-instance {
               description "Packets are directed to specified routing instance";
               leaf routing-instance-name {
                 description "Name of routing instance";
                 type string {
                   junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                   junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                 }
               }
               leaf topology {
                 description "Packets are directed to specified topology";
                 type string {
                   junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                   junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                 }
               }
             }
           }
           case case_6 {
             leaf topology {
               description "Packets are directed to specified topology";
               type string {
                 junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                 junos:pattern-message "Must be a non-reserved string of 128 characters or less";
               }
             }
           }
           case case_7 {
             container next-ip {
               description "Packets are directed to specified the specified ipv4 address";
               leaf address {
                 description "Address to route";
                 type jt:ipv4prefix;
               }
               container routing-instance {
                 description "Packets are directed to specified routing instance";
                 leaf routing-instance-name {
                   description "Name of routing instance";
                   type string {
                     junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                   }
                 }
                 leaf topology {
                   description "Packets are directed to specified topology";
                   type string {
                     junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                   }
                 }
               }
             }
           }
           case case_8 {
             container next-interface {
               presence "enable next-interface";
               description "Packets are to be routed through the specified interface";
               uses apply-advanced;
               leaf interface-name {
                 description "Interface name";
                 type string {
                   length "1 .. 127";
                   junos:posix-pattern "^((ge-)|(xe-)|(et-)|(gr-)|(ae)|(irb))";
                   junos:pattern-message "Only ge, xe, et, ae, irb and point-to-point gr tunnel intefaces are supported";
                 }
               }
               container routing-instance {
                 description "Packets are directed to specified routing instance";
                 leaf routing-instance-name {
                   description "Name of routing instance";
                   type string {
                     junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                   }
                 }
                 leaf topology {
                   description "Packets are directed to specified topology";
                   type string {
                     junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                     junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                   }
                 }
               }
               choice designation {
                 case case_1 {
                   leaf accept {
                     description "Accept the packet";
                     type empty;
                   }
                 }
                 case case_2 {
                   leaf next {
                     description "Continue to next term in a filter";
                     type enumeration {
                       enum "term" {
                         description "Continue to next term in a filter";
                       }
                     }
                   }
                 }
               }
             }
           }
           case case_9 {
             leaf ipsec-sa {
               description "Use specified IPSec security association";
               type string;
             }
           }
           case case_10 {
           }
           case case_11 {
             container decapsulate {
               presence "enable decapsulate";
               description "Terminate a tunnel";
               choice tunnel-protocol {
                 case case_1 {
                   container gre {
                     presence "enable gre";
                     description "GRE protocol";
                     uses apply-advanced;
                     leaf-list sample {
                       description "Sample the packet";
                       junos:must "(!(\".. sampling-instance\"))";
                       junos:must-message "'sampling' and 'sampling-instance' are mutually exclusive";
                       type enumeration {
                         enum "inet" {
                           description "IPV4 protocol";
                           junos:must "((\"forwarding-options sampling family inet\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family inet\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                         enum "inet6" {
                           description "IPV6 protocol";
                           junos:must "((\"forwarding-options sampling family inet6\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family inet6\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                         enum "mpls" {
                           description "MPLS protocol";
                           junos:must "(!(\".. .. sample mpls-ipvx-payload\"))";
                           junos:must-message "Cannot configure both sample mpls and sample mpls-ipvx-payload";
                           junos:must "((\"forwarding-options sampling family mpls\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family mpls\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                       }
                     }
                     leaf no-decrement-ttl {
                       description "Do not decrement TTL";
                       type empty;
                     }
                     leaf forwarding-class {
                       description "Classify packet to forwarding class";
                       type string {
                         junos:posix-pattern "^.{1,64}$";
                         junos:pattern-message "Must be string of 64 characters or less";
                       }
                     }
                     leaf interface-group {
                       description "Set the interface group";
                       type union {
                         type string {
                           pattern "<.*>|$.*";
                         }
                         type uint32 {
                           range "0 .. 255";
                         }
                       }
                     }
                     choice destination {
                       case case_1 {
                         container routing-instance {
                           description "Packets are directed to specified routing instance";
                           leaf routing-instance-name {
                             description "Name of routing instance";
                             junos:must "(\"routing-instances $$\")";
                             junos:must-message "referenced routing instance must be defined";
                             type string {
                               junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                               junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                             }
                           }
                         }
                       }
                     }
                   }
                 }
                 case case_2 {
                 }
                 case case_3 {
                 }
                 case case_4 {
                   container l2tp {
                     description "L2TP protocol";
                     uses apply-advanced;
                     leaf-list sample {
                       description "Sample the packet";
                       junos:must "(!(\".. sampling-instance\"))";
                       junos:must-message "'sampling' and 'sampling-instance' are mutually exclusive";
                       type enumeration {
                         enum "inet" {
                           description "IPV4 protocol";
                           junos:must "((\"forwarding-options sampling family inet\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family inet\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                         enum "inet6" {
                           description "IPV6 protocol";
                           junos:must "((\"forwarding-options sampling family inet6\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family inet6\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                         enum "mpls" {
                           description "MPLS protocol";
                           junos:must "(!(\".. .. sample mpls-ipvx-payload\"))";
                           junos:must-message "Cannot configure both sample mpls and sample mpls-ipvx-payload";
                           junos:must "((\"forwarding-options sampling family mpls\" || (\"forwarding-options packet-capture\" || any \"forwarding-options sampling instance <*> family mpls\")))";
                           junos:must-message "Requires forwarding-options sampling or packet-capture config";
                         }
                       }
                     }
                     leaf no-decrement-ttl {
                       description "Do not decrement TTL";
                       type empty;
                     }
                     leaf forwarding-class {
                       description "Classify packet to forwarding class";
                       type string {
                         junos:posix-pattern "^.{1,64}$";
                         junos:pattern-message "Must be string of 64 characters or less";
                       }
                     }
                     leaf interface-group {
                       description "Set the interface group";
                       type union {
                         type string {
                           pattern "<.*>|$.*";
                         }
                         type uint32 {
                           range "0 .. 255";
                         }
                       }
                     }
                     leaf-list cookie {
                       description "L2TPv3 cookie";
                       type string {
                         length "1 .. 32";
                       }
                     }
                     choice destination {
                       case case_1 {
                         leaf output-interface {
                           description "Interface name";
                           junos:must "(\"interfaces $$\")";
                           junos:must-message "Interface must be defined in the interfaces hierarchy";
                           type union {
                             type jt:interface-unit;
                             type string {
                               pattern "<.*>|$.*";
                             }
                           }
                         }
                       }
                     }
                   }
                 }
               }
             }
           }
           case case_12 {
           }
           case case_13 {
             container reject {
               presence "enable reject";
               description "Reject the packet";
               choice style {
                 case case_1 {
                   leaf network-unreachable {
                     description "Send ICMP Network Unreachable message";
                     type empty;
                   }
                 }
                 case case_2 {
                   leaf host-unreachable {
                     description "Send ICMP Host Unreachable message";
                     type empty;
                   }
                 }
                 case case_3 {
                   leaf protocol-unreachable {
                     description "Send ICMP Protocol Unreachable message";
                     type empty;
                   }
                 }
                 case case_4 {
                   leaf port-unreachable {
                     description "Send ICMP Port Unreachable message";
                     type empty;
                   }
                 }
                 case case_5 {
                   leaf fragmentation-needed {
                     description "Send ICMP Fragmentation Needed message";
                     type empty;
                   }
                 }
                 case case_6 {
                   leaf source-route-failed {
                     description "Send ICMP Source Route Failed message";
                     type empty;
                   }
                 }
                 case case_7 {
                   leaf network-unknown {
                     description "Send ICMP Network Unknown message";
                     type empty;
                   }
                 }
                 case case_8 {
                   leaf host-unknown {
                     description "Send ICMP Host Unknown message";
                     type empty;
                   }
                 }
                 case case_9 {
                   leaf source-host-isolated {
                     description "Send ICMP Source Host Isolated message";
                     type empty;
                   }
                 }
                 case case_10 {
                   leaf network-prohibited {
                     description "Send ICMP Network Prohibited message";
                     type empty;
                   }
                 }
                 case case_11 {
                   leaf host-prohibited {
                     description "Send ICMP Host Prohibited message";
                     type empty;
                   }
                 }
                 case case_12 {
                   leaf bad-network-tos {
                     description "Send ICMP Bad Network ToS message";
                     type empty;
                   }
                 }
                 case case_13 {
                   leaf bad-host-tos {
                     description "Send ICMP Bad Host ToS message";
                     type empty;
                   }
                 }
                 case case_14 {
                   leaf administratively-prohibited {
                     description "Send ICMP Administratively Prohibited message";
                     type empty;
                   }
                 }
                 case case_15 {
                   leaf precedence-violation {
                     description "Send ICMP Precedence Violation message";
                     type empty;
                   }
                 }
                 case case_16 {
                   leaf precedence-cutoff {
                     description "Send ICMP Precedence Cutoff message";
                     type empty;
                   }
                 }
                 case case_17 {
                   leaf tcp-reset {
                     description "Send TCP Reset message";
                     type empty;
                   }
                 }
               }
             }
           }
           case case_14 {
           }
         }
         leaf dscp {
           description "Set Differentiated Services (DiffServ) code point";
           type string;
         }
         leaf prefix-action {
           description "Police or count packets using named prefix action";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
       }
       container template {
         description "Refer a template";
         uses apply-advanced;
         leaf template-name {
           description "Template name";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
       }
     }
   }
   grouping inet_fuf {
     leaf name {
       description "Name of fast update filter";
       junos:must "(unique \"firewall family <*> filter $$\")";
       junos:must-message "Fast update filter can not have the same name as firewall family filter";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf interface-specific {
       description "Defined counters are interface specific";
       type empty;
     }
     leaf-list match-order {
       type enumeration {
         enum "protocol" {
           description "Include IP protocol in match set";
         }
         enum "source-address" {
           description "Include source-address in match set";
         }
         enum "destination-address" {
           description "Include destination-address in match set";
         }
         enum "source-port" {
           description "Include source-port in match set";
         }
         enum "destination-port" {
           description "Include destination-port in match set";
         }
         enum "dscp" {
           description "Include Differentiated Services (DiffServ) code point in match set";
         }
       }
     }
     list term {
       key name;
       ordered-by user;
       description "One or more firewall terms";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       leaf only-at-create {
         description "Add term only when filter is first created.";
         type empty;
       }
       container from {
         description "Match criteria";
         uses apply-advanced;
         container source-address {
           description "Match source IP address";
           uses firewall_addr_simple_object;
         }
         container destination-address {
           description "Match destination IP address";
           uses firewall_addr_simple_object;
         }
         choice source-port_choice {
           case case_1 {
             container source-port {
               description "Match TCP/UDP source port";
               uses match_simple_port_value;
             }
           }
         }
         choice destination-port_choice {
           case case_1 {
             container destination-port {
               description "Match TCP/UDP destination port";
               uses match_simple_port_value;
             }
           }
         }
         choice protocol_choice {
           case case_1 {
             container protocol {
               description "Match IP protocol type";
               uses match_simple_protocol_value;
             }
           }
         }
         choice dscp_choice {
           case case_1 {
             container dscp {
               description "Match Differentiated Services (DiffServ) code point";
               uses match_simple_dscp_value;
             }
           }
         }
         leaf match-terms {
           description "Dynamically supplied list of match criteria";
           type string;
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         choice policer-choice {
           case case_1 {
             leaf policer {
               description "Name of policer to use to rate-limit traffic";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         leaf count {
           description "Count the packet in the named counter";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf service-accounting {
           description "Count the packets for service accounting";
           junos:must "(!(\".. count\"))";
           junos:must-message "'count' and 'service-accounting' cannot coexist";
           type empty;
         }
         leaf log {
           description "Log the packet";
           type empty;
         }
         leaf port-mirror {
           description "Port-mirror the packet";
           type empty;
         }
         leaf loss-priority {
           description "Packet's loss priority";
           junos:must "(!(\".. three-color-policer\"))";
           junos:must-message "Configuring loss-priority is incompatible with configuring three-color-policer";
           junos:must "(\".. forwarding-class\")";
           junos:must-message "To configure loss-priority, forwarding-class must be set";
           type enumeration {
             enum "low" {
               description "Loss priority low";
             }
             enum "high" {
               description "Loss priority high";
             }
             enum "medium-low" {
               description "Loss priority medium-low";
             }
             enum "medium-high" {
               description "Loss priority medium-high";
             }
           }
         }
         leaf forwarding-class {
           description "Classify packet to forwarding class";
           junos:must "(\".. loss-priority\")";
           junos:must-message "To configure forwarding-class, loss-priority must be set";
           type string {
             junos:posix-pattern "^.{1,64}$";
             junos:pattern-message "Must be string of 64 characters or less";
           }
         }
         leaf action-terms {
           description "Dynamically supplied list of actions";
           type string;
         }
         choice designation {
           case case_1 {
             leaf accept {
               description "Accept the packet";
               type empty;
             }
           }
           case case_2 {
             leaf discard {
               description "Discard the packet";
               type empty;
             }
           }
           case case_3 {
             container routing-instance {
               description "Packets are directed to specified routing instance";
               leaf routing-instance-name {
                 description "Name of routing instance";
                 type string {
                   junos:posix-pattern "!^((__.*__)|(all)|(.*[ ].*)|(\"\")|(.{129,}))$";
                   junos:pattern-message "Must be a non-reserved string of 128 characters or less with no spaces.";
                 }
               }
               leaf topology {
                 description "Packets are directed to specified topology";
                 type string {
                   junos:posix-pattern "!^((.*:.*)|(.{129,}))$";
                   junos:pattern-message "Must be a non-reserved string of 128 characters or less";
                 }
               }
             }
           }
         }
       }
     }
   }
   grouping firewall_addr_simple_object {
     uses apply-advanced;
     leaf address {
       description "Prefix to match";
       type jt:ipv4prefix;
     }
   }
   grouping inet_service_filter {
     leaf name {
       description "Filter name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     list term {
       key name;
       ordered-by user;
       description "Service filter term";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       container from {
         description "Match criteria";
         uses apply-advanced;
         choice interface-group_choice {
           case case_1 {
             leaf-list interface-group {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list interface-group-except {
               description "Range of values";
               type string;
             }
           }
         }
         list source-address {
           key name;
           ordered-by user;
           description "Match IP source address";
           uses firewall_addr_object;
         }
         list destination-address {
           key name;
           ordered-by user;
           description "Match IP destination address";
           uses firewall_addr_object;
         }
         list address {
           key name;
           ordered-by user;
           description "Match IP source or destination address";
           uses firewall_addr_object;
         }
         list source-prefix-list {
           key name;
           ordered-by user;
           description "Match IP source prefixes in named list";
           uses firewall_prefix_list;
         }
         list destination-prefix-list {
           key name;
           ordered-by user;
           description "Match IP destination prefixes in named list";
           uses firewall_prefix_list;
         }
         list prefix-list {
           key name;
           ordered-by user;
           description "Match IP source or destination prefixes in named list";
           uses firewall_prefix_list;
         }
         choice protocol_choice {
           case case_1 {
             leaf-list protocol {
               type string;
             }
           }
           case case_2 {
             leaf-list protocol-except {
               type string;
             }
           }
         }
         choice ip-options_choice {
           case case_1 {
             leaf-list ip-options {
               type enumeration {
                 enum "any" {
                   description "Any IP option";
                 }
               }
             }
           }
           case case_2 {
             leaf-list ip-options-except {
               type enumeration {
                 enum "any" {
                   description "Any IP option";
                 }
               }
             }
           }
         }
         choice source-port_choice {
           case case_1 {
             leaf-list source-port {
               type string;
             }
           }
           case case_2 {
             leaf-list source-port-except {
               type string;
             }
           }
         }
         choice destination-port_choice {
           case case_1 {
             leaf-list destination-port {
               type string;
             }
           }
           case case_2 {
             leaf-list destination-port-except {
               type string;
             }
           }
         }
         choice port_choice {
           case case_1 {
             leaf-list port {
               type string;
             }
           }
           case case_2 {
             leaf-list port-except {
               type string;
             }
           }
         }
         choice esp-spi_choice {
           case case_1 {
             leaf-list esp-spi {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list esp-spi-except {
               description "Range of values";
               type string;
             }
           }
         }
         leaf is-fragment {
           description "Match if packet is a fragment";
           type empty;
         }
         leaf first-fragment {
           description "Match if packet is the first fragment";
           type empty;
         }
         choice fragment-offset_choice {
           case case_1 {
             leaf-list fragment-offset {
               description "Range of values";
               type string {
                 junos:posix-pattern "^[[:digit:]]+(-[[:digit:]]+)?$";
                 junos:pattern-message "Must be a in form of number or a range in the form '<minimum-value>-<maximum-value>'";
               }
             }
           }
           case case_2 {
             leaf-list fragment-offset-except {
               description "Range of values";
               type string {
                 junos:posix-pattern "^[[:digit:]]+(-[[:digit:]]+)?$";
                 junos:pattern-message "Must be a in form of number or a range in the form '<minimum-value>-<maximum-value>'";
               }
             }
           }
         }
         leaf fragment-flags {
           description "Match fragment flags";
           type string;
         }
         leaf tcp-flags {
           description "Match TCP flags (in symbolic or hex formats)";
           junos:must "(!(\".. tcp-established\"))";
           junos:must-message "tcp-flags may not be matched in same rule as tcp-established";
           junos:must "(!(\".. tcp-initial\"))";
           junos:must-message "tcp-flags may not be matched in same rule as tcp-initial";
           type string;
         }
         choice ah-spi_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ah-spi-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice loss-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list loss-priority-except {
               type enumeration {
                 enum "low" {
                   description "Loss priority low";
                 }
                 enum "high" {
                   description "Loss priority high";
                 }
                 enum "medium-low" {
                   description "Loss priority medium-low";
                 }
                 enum "medium-high" {
                   description "Loss priority medium-high";
                 }
               }
             }
           }
         }
         choice forwarding-class_choice {
           case case_1 {
             leaf-list forwarding-class {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list forwarding-class-except {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
         }
         choice redirect-reason_choice {
           case case_1 {
             leaf-list redirect-reason {
               type enumeration {
                 enum "aoc" {
                   description "Advice of Charge";
                 }
                 enum "aolb" {
                   description "Advice of Low Balance";
                 }
                 enum "dpi" {
                   description "Layer7 match required";
                 }
               }
             }
           }
           case case_2 {
             leaf-list redirect-reason-except {
               type enumeration {
                 enum "aoc" {
                   description "Advice of Charge";
                 }
                 enum "aolb" {
                   description "Advice of Low Balance";
                 }
                 enum "dpi" {
                   description "Layer7 match required";
                 }
               }
             }
           }
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         leaf count {
           description "Count the packet in the named counter";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf log {
           description "Log the packet";
           type empty;
         }
         leaf pkt-trace {
           description "Pkt-Trace the packet";
           type empty;
         }
         leaf sample {
           description "Sample the packet";
           type empty;
         }
         leaf port-mirror {
           description "Port-mirror the packet";
           type empty;
         }
         choice designation {
           case case_1 {
             leaf service {
               description "Forward packets to service processing";
               type empty;
             }
           }
           case case_2 {
             leaf skip {
               description "Skip service processing";
               type empty;
             }
           }
           case case_3 {
           }
         }
       }
     }
   }
   grouping inet_template {
     leaf name {
       description "Template name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     container attributes {
       description "Template attributes";
       uses apply-advanced;
       leaf destination-address {
         description "Match IP destination address";
         type empty;
       }
       leaf destination-port {
         description "Match TCP/UDP destination port";
         type empty;
       }
       leaf destination-port-range-optimize {
         description "Optimize the destination port range";
         type empty;
       }
       leaf destination-prefix-list {
         description "Match IP destination prefixes in named list";
         type empty;
       }
       leaf dscp {
         description "Match Differentiated Services (DiffServ) code point";
         type empty;
       }
       leaf flexible-match-mask {
         description "Match flexible mask";
         type empty;
       }
       leaf flexible-match-range {
         description "Match flexible range";
         type empty;
       }
       leaf fragment-flags {
         description "Match fragment flags";
         type empty;
       }
       leaf icmp-code {
         description "Match ICMP message code";
         type empty;
       }
       leaf icmp-type {
         description "Match ICMP message type";
         type empty;
       }
       leaf interface {
         description "Match interface name";
         type empty;
       }
       leaf ip-options {
         description "Match IP options";
         type empty;
       }
       leaf is-fragment {
         description "Match if packet is a fragment";
         type empty;
       }
       leaf packet-length {
         description "Match packet length";
         type empty;
       }
       leaf precedence {
         description "Match IP precedence value";
         type empty;
       }
       leaf protocol {
         description "Match IP protocol type";
         type empty;
       }
       leaf rat-type {
         description "Match RAT Type";
         type empty;
       }
       leaf redirect-reason {
         description "Match Redirect Reason";
         type empty;
       }
       leaf source-address {
         description "Match IP source address";
         type empty;
       }
       leaf source-port {
         description "Match TCP/UDP source port";
         type empty;
       }
       leaf source-port-range-optimize {
         description "Optimize the source port range";
         type empty;
       }
       leaf source-prefix-list {
         description "Match IP source prefixes in named list";
         type empty;
       }
       leaf tcp-established {
         description "Match packet of an established TCP connection";
         type empty;
       }
       leaf tcp-flags {
         description "Match TCP flags";
         type empty;
       }
       leaf tcp-initial {
         description "Match initial packet of a TCP connection";
         type empty;
       }
       leaf ttl {
         description "Match IP ttl type";
         type empty;
       }
     }
   }
   grouping interface_set_type {
     leaf name {
       description "Interface set name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     list interface-list {
       key name;
       ordered-by user;
       description "Interface list";
       leaf name {
         description "Interface name";
         type union {
           type jt:interface-wildcard;
           type string {
             pattern "<.*>|$.*";
           }
         }
       }
       uses apply-advanced;
     }
   }
   grouping macro-data-type {
     leaf name {
       description "Keyword part of the keyword-value pair";
       type string;
     }
     leaf value {
       description "Value part of the keyword-value pair";
       type string;
     }
   }
   grouping match_L2_flexible_mask {
     description "Define a flexible match";
     uses apply-advanced;
     leaf match-start {
       description "Start point to match in packet";
       type enumeration {
         enum "layer-2" {
           description "Layer-2 match start";
         }
         enum "layer-3" {
           description "Layer-3 match start";
         }
         enum "layer-4" {
           description "Layer-4 match start";
         }
         enum "payload" {
           description "Payload match start";
         }
       }
     }
     leaf byte-offset {
       description "Byte offset after the match start point";
       type union {
         type uint32;
         type string {
           pattern "<.*>|$.*";
         }
       }
     }
     leaf bit-length {
       description "Length of the data to be matched in bits, not needed for string input";
       type union {
         type string {
           pattern "<.*>|$.*";
         }
         type uint32 {
           range "1 .. 128";
         }
       }
     }
     leaf prefix {
       description "Value data/string to be matched";
       junos:must "((\".. flexible-mask-name\" || \".. match-start\"))";
       junos:must-message "To configure prefix, 'flexible-mask-name' or 'match-start' must be configured";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
   }
   grouping match_L3_flexible_mask {
     description "Define a flexible match";
     uses apply-advanced;
     leaf match-start {
       description "Start point to match in packet";
       type enumeration {
         enum "layer-3" {
           description "Layer-3 match start";
         }
         enum "layer-4" {
           description "Layer-4 match start";
         }
         enum "payload" {
           description "Payload match start";
         }
       }
     }
     leaf byte-offset {
       description "Byte offset after the match start point";
       type union {
         type uint32;
         type string {
           pattern "<.*>|$.*";
         }
       }
     }
     leaf bit-length {
       description "Length of the data to be matched in bits, not needed for string input";
       type union {
         type string {
           pattern "<.*>|$.*";
         }
         type uint32 {
           range "1 .. 128";
         }
       }
     }
     leaf prefix {
       description "Value data/string to be matched";
       junos:must "((\".. flexible-mask-name\" || \".. match-start\"))";
       junos:must-message "To configure prefix, 'flexible-mask-name' or 'match-start' must be configured";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
   }
   grouping match_interface_object {
     leaf name {
       description "Interface to match";
       type union {
         type jt:interface-wildcard;
         type string {
           pattern "<.*>|$.*";
         }
       }
     }
   }
   grouping match_interface_object_oam {
     leaf name {
       description "Interface to match";
       type union {
         type jt:interface-wildcard;
         type string {
           pattern "<.*>|$.*";
         }
       }
     }
   }
   grouping match_interface_set_object {
     leaf name {
       description "Interface set to match";
       type string;
     }
   }
   grouping match_simple_dscp_value {
     uses apply-advanced;
     leaf value_keyword {
       type string;
     }
   }
   grouping match_simple_port_value {
     uses apply-advanced;
     leaf value_keyword {
       type string;
     }
   }
   grouping match_simple_protocol_value {
     uses apply-advanced;
     leaf value_keyword {
       type string;
     }
   }
   grouping mpls_filter {
     description "Define an MPLS firewall filter";
     leaf name {
       description "Filter name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf-list accounting-profile {
       description "Accounting profile name";
       junos:must "(\"accounting-options filter-profile\")";
       junos:must-message "referenced accounting profile must be defined";
       type string;
     }
     leaf interface-specific {
       description "Defined counters are interface specific";
       type empty;
     }
     list term {
       key name;
       ordered-by user;
       description "Define a firewall term";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       leaf filter {
         description "Filter to include";
         junos:must "(\"firewall family mpls filter $$\")";
         junos:must-message "Referenced filter is not defined";
         junos:must "((!(\".. from\") && !(\".. then\")))";
         junos:must-message "Not compatible with 'from or then'";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       container from {
         description "Define match criteria";
         uses apply-advanced;
         choice interface-group_choice {
           case case_1 {
             leaf-list interface-group {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list interface-group-except {
               description "Range of values";
               type string;
             }
           }
         }
         list label {
           key name;
           ordered-by user;
           description "MPLS label bits";
           leaf name {
             description "Range of values between 0 and 1048575 in decimal or hexadecimal";
             type string {
               junos:posix-pattern "^([0-9]{1,6}|10[0-3][0-9][0-9][0-9][0-9]|104[0-7][0-9][0-9][0-9]|1048[0-4][0-9][0-9]|10485[0-6][0-9]|104857[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f]|0x[0-f][0-f][0-f][0-f][0-f]|0x[0-f][0-f][0-f][0-f][0-f][0-f])(-([0-9]{1,6}|10[0-3][0-9][0-9][0-9][0-9]|104[0-7][0-9][0-9][0-9]|1048[0-4][0-9][0-9]|10485[0-6][0-9]|104857[0-5]|0x[0-f][0-f][0-f][0-f]|0x[0-f]|0x[0-f][0-f]|0x[0-f][0-f][0-f]|0x[0-f][0-f][0-f][0-f][0-f]|0x[0-f][0-f][0-f][0-f][0-f][0-f]))?$";
               junos:pattern-message "Must be a numerical value or range between 0-1048575";
             }
           }
           uses apply-advanced;
         }
         choice exp_choice {
           case case_1 {
             leaf-list exp {
               description "Range of values between 0 and 7 in decimal, binary or hex";
               type string;
             }
           }
           case case_2 {
             leaf-list exp-except {
               description "Range of values between 0 and 7 in decimal, binary or hex";
               type string;
             }
           }
         }
         choice forwarding-class_choice {
           case case_1 {
             leaf-list forwarding-class {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list forwarding-class-except {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
         }
         choice loss-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list loss-priority-except {
               type enumeration {
                 enum "low" {
                   description "Loss priority low";
                 }
                 enum "high" {
                   description "Loss priority high";
                 }
                 enum "medium-low" {
                   description "Loss priority medium-low";
                 }
                 enum "medium-high" {
                   description "Loss priority medium-high";
                 }
               }
             }
           }
         }
         choice flex-mask_choice {
           case case_1 {
             container flexible-match-mask {
               description "Match flexible mask";
               uses match_mpls_flexible_mask;
             }
           }
         }
         choice policy-map_choice {
           case case_1 {
             leaf-list policy-map {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list policy-map-except {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         choice policer-choice {
           case case_1 {
             leaf policer {
               description "Name of policer to use to rate-limit traffic";
               junos:must "(!(\"firewall policer $$ aggregate\"))";
               junos:must-message "Cannot attach a aggregate policer to filter";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             container three-color-policer {
               junos:must "(!(\".. loss-priority\"))";
               junos:must-message "cannot support three-color-policer action if loss-priority is configured";
               description "Police the packet using a three-color-policer";
               uses apply-advanced;
               choice type-choice {
                 case case_1 {
                   leaf single-rate {
                     description "Name of single-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-rate\")";
                     junos:must-message "Referenced single-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_2 {
                   leaf single-packet-rate {
                     description "Name of single-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-packet-rate\")";
                     junos:must-message "Referenced single-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_3 {
                   leaf two-rate {
                     description "Name of two-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-rate\")";
                     junos:must-message "Referenced two-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_4 {
                   leaf two-packet-rate {
                     description "Name of two-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-packet-rate\")";
                     junos:must-message "Referenced two-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
               }
             }
           }
           case case_3 {
           }
         }
         choice policy-map-choice {
           case case_1 {
             leaf clear-policy-map {
               description "Clear the policy marking";
               type empty;
             }
           }
           case case_2 {
             leaf policy-map {
               description "Policy map action";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "referenced policy map must be defined";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         choice mplscnt {
           case case_1 {
           }
           case case_2 {
             leaf count {
               description "Count the packet in the named counter";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         leaf port-mirror-instance {
           description "Port-mirror the packet to specified instance";
           junos:must "(\"forwarding-options port-mirroring instance $$\")";
           junos:must-message "Referenced port-mirroring instance does not exist";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         choice designation {
           case case_1 {
           }
           case case_2 {
             leaf accept {
               description "Accept the packet";
               type empty;
             }
           }
           case case_3 {
             leaf discard {
               description "Discard the packet";
               type empty;
             }
           }
           case case_4 {
             leaf next {
               description "Continue to next term in a filter";
               type enumeration {
                 enum "term" {
                   description "Continue to next term in a filter";
                 }
               }
             }
           }
         }
       }
       container template {
         description "Refer a template";
         uses apply-advanced;
         leaf template-name {
           description "Template name";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
       }
     }
   }
   grouping match_mpls_flexible_mask {
     description "Define a flexible match";
     uses apply-advanced;
     leaf match-start {
       description "Start point to match in packet";
       type enumeration {
         enum "layer-3" {
           description "Layer-3 match start";
         }
         enum "payload" {
           description "Payload match start";
         }
       }
     }
     leaf byte-offset {
       description "Byte offset after the match start point";
       type union {
         type uint32;
         type string {
           pattern "<.*>|$.*";
         }
       }
     }
     leaf bit-offset {
       description "Bit offset after the (match-start + byte) offset";
       type union {
         type string {
           pattern "<.*>|$.*";
         }
         type uint32 {
           range "0 .. 7";
         }
       }
     }
     leaf bit-length {
       description "Length of the data to be matched in bits, not needed for string input";
       type union {
         type string {
           pattern "<.*>|$.*";
         }
         type uint32 {
           range "1 .. 128";
         }
       }
     }
     leaf mask-in-hex {
       description "Mask out bits in the packet data to be matched";
       type string {
         junos:posix-pattern "(^(0[xX])?[A-Fa-f0-9]{0,8}$)";
       }
     }
     leaf prefix {
       description "Value data/string to be matched";
       junos:must "((\".. flexible-mask-name\" || \".. match-start\"))";
       junos:must-message "To configure prefix, 'flexible-mask-name' or 'match-start' must be configured";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     leaf flexible-mask-name {
       description "Select a flexible match from predefined template field";
       junos:must "((!(\".. byte-offset\") && (!(\".. bit-offset\") && (!(\".. bit-length\") && !(\".. match-start\")))))";
       junos:must-message "To refer configured template, only prefix or prefix along with mask can be configured";
       type string;
     }
   }
   grouping mpls_template {
     leaf name {
       description "Template name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     container attributes {
       description "Template attributes";
       uses apply-advanced;
       leaf exp {
         description "Match MPLS EXP bits";
         type empty;
       }
       leaf exp-except {
         description "Do not match MPLS EXP bits";
         type empty;
       }
       leaf flexible-match-mask {
         description "Match flexible mask";
         type empty;
       }
       leaf flexible-match-range {
         description "Match flexible range";
         type empty;
       }
       leaf forwarding-class {
         description "Match forwarding class";
         type empty;
       }
       leaf forwarding-class-except {
         description "Do not match forwarding class";
         type empty;
       }
       leaf interface {
         description "Match interface name";
         type empty;
       }
       leaf interface-group {
         description "Match interface group";
         type empty;
       }
       leaf interface-set {
         description "Match interface in set";
         type empty;
       }
       leaf loss-priority {
         description "Match Loss Priority";
         type empty;
       }
       leaf loss-priority-except {
         description "Do not match Loss Priority";
         type empty;
       }
       leaf label {
         description "MPLS label bits";
         type empty;
       }
     }
   }
   grouping prefix_action {
     leaf name {
       description "Prefix action name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf policer {
       description "Police the packet using a set of named policer";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     leaf count {
       description "Enable counters";
       type empty;
     }
     leaf filter-specific {
       description "Filter specific, else term specific";
       type empty;
     }
     leaf subnet-prefix-length {
       description "Prefix length for the total address range";
       type union {
         type string {
           pattern "<.*>|$.*";
         }
         type uint32 {
           range "0 .. 32";
         }
       }
     }
     choice source_or_dest {
       case case_1 {
         leaf source-prefix-length {
           description "Source prefix range";
           type union {
             type string {
               pattern "<.*>|$.*";
             }
             type uint32 {
               range "0 .. 32";
             }
           }
         }
       }
       case case_2 {
         leaf destination-prefix-length {
           description "Destination prefix range";
           type union {
             type string {
               pattern "<.*>|$.*";
             }
             type uint32 {
               range "0 .. 32";
             }
           }
         }
       }
     }
   }
   grouping three-color-policer-type {
     description "Three-color policer";
     leaf name {
       description "Policer name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf filter-specific {
       description "Three color policer is filter-specific";
       junos:must "(!(\".. loss-priority\"))";
       junos:must-message "cannot support three-color-policer action if loss-priority is configured";
       type empty;
     }
     leaf logical-interface-policer {
       description "Policer is logical interface policer";
       junos:must "(!(\".. loss-priority\"))";
       junos:must-message "cannot support three-color-policer action if loss-priority is configured";
       type empty;
     }
     container action {
       junos:must "(!(\".. loss-priority\"))";
       junos:must-message "cannot support three-color-policer action if loss-priority is configured";
       description "Action for three-color policer";
       uses apply-advanced;
       list loss-priority {
         key name;
         ordered-by user;
         description "Loss priority for packet";
         uses three-color-policer-action;
       }
     }
     choice rate-type-choice {
       case case_1 {
         container single-rate {
           description "Single-rate policer";
           uses apply-advanced;
           choice mode-choice {
             case case_1 {
               leaf color-blind {
                 description "Color-blind mode";
                 type empty;
               }
             }
             case case_2 {
               leaf color-aware {
                 description "Color-aware mode";
                 type empty;
               }
             }
           }
           leaf committed-information-rate {
             description "Bandwidth allowed for committed traffic";
             units "bits per second";
             type string;
           }
           leaf committed-burst-size {
             description "Burst size allowed for committed traffic";
             units "bytes";
             type string;
           }
           leaf excess-burst-size {
             description "Burst size allowed for excess traffic";
             units "bytes";
             type string;
           }
         }
       }
       case case_2 {
       }
       case case_3 {
         container two-rate {
           presence "enable two-rate";
           description "Two-rate policer";
           uses apply-advanced;
           choice mode-choice {
             case case_1 {
               leaf color-blind {
                 description "Color-blind mode";
                 type empty;
               }
             }
             case case_2 {
               leaf color-aware {
                 description "Color-aware mode";
                 type empty;
               }
             }
           }
           leaf committed-information-rate {
             description "Bandwidth allowed for committed traffic";
             units "bits per second";
             type string;
           }
           leaf committed-burst-size {
             description "Burst size allowed for committed traffic  ";
             units "bytes";
             type string;
           }
           leaf peak-information-rate {
             description "Bandwidth allowed for peak traffic";
             units "bits per second";
             type string;
           }
           leaf peak-burst-size {
             description "Burst size allowed for peak traffic  ";
             units "bytes";
             type string;
           }
           container aggregate-policing {
             presence "enable aggregate-policing";
             description "Configure Aggregate Policer";
             uses apply-advanced;
             list policer {
               key name;
               ordered-by user;
               description "Two-color policer to be used as aggregate";
               max-elements 1;
               leaf name {
                 description "Name of two-color policer to use to aggregate police";
                 junos:must "(\"firewall policer $$\")";
                 junos:must-message "Referenced aggregate policer is not defined";
                 type string;
               }
               uses apply-advanced;
               leaf aggregate-sharing-mode {
                 description "Hierarchical Metering model";
                 type enumeration {
                   enum "hybrid" {
                     description "Child policer CIR rates are guaranteed rates and PIR rate are peak rates for member flow";
                   }
                 }
               }
             }
           }
         }
       }
       case case_4 {
       }
     }
   }
   grouping three-color-policer-action {
     description "Action for three-color policer";
     leaf name {
       description "Loss priority for packet";
       type enumeration {
         enum "high" {
           description "High loss priority";
         }
       }
     }
     uses apply-advanced;
     container then {
       description "Action to take if the rate limits are exceeded";
       uses apply-advanced;
       leaf discard {
         description "Discard the packet";
         type empty;
       }
     }
   }
   grouping to_fabric_object {
     description "Match traffic going to fabric";
     uses apply-advanced;
     leaf except {
       description "Match traffic switched locally and not going to fabric";
       type empty;
     }
   }
   grouping tunnel_end_point {
     description "Define a tunnel end point";
     leaf name {
       description "Tunnel end-point identifier (ASCII string)";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     choice l3-protocol {
       case case_1 {
         container ipv6 {
           presence "enable ipv6";
           description "Enter an IPv6 tunnel";
           uses apply-advanced;
           leaf source-address {
             description "Tunnel source address";
             type jt:ipv6addr;
           }
           leaf destination-address {
             description "Tunnel destination address";
             type jt:ipv6addr;
           }
         }
       }
       case case_2 {
         container ipv4 {
           presence "enable ipv4";
           description "Enter an IPv4 tunnel";
           uses apply-advanced;
           leaf source-address {
             description "Tunnel source address";
             type jt:ipv4addr;
           }
           leaf destination-address {
             description "Tunnel destination address";
             type jt:ipv4addr;
           }
         }
       }
     }
     choice tunnel-protocol {
       case case_1 {
         container gre {
           presence "enable gre";
           description "Tunnel is GRE";
           uses apply-advanced;
           leaf key {
             description "Key for authentication";
             type union {
               type uint32;
               type string {
                 pattern "<.*>|$.*";
               }
             }
           }
         }
       }
       case case_2 {
         container gre-in-udp {
           presence "enable gre-in-udp";
           description "Tunnel is GRE-in-UDP";
           uses apply-advanced;
           leaf source-port {
             description "UDP source port";
             type union {
               type string {
                 pattern "<.*>|$.*";
               }
               type uint32 {
                 range "0 .. 65535";
               }
             }
           }
           leaf destination-port {
             description "UDP destination port";
             type union {
               type string {
                 pattern "<.*>|$.*";
               }
               type uint32 {
                 range "0 .. 65535";
               }
             }
           }
           leaf key {
             description "GRE key for authentication";
             type union {
               type uint32;
               type string {
                 pattern "<.*>|$.*";
               }
             }
           }
         }
       }
     }
   }
   grouping vpls_filter {
     description "Define an VPLS firewall filter";
     leaf name {
       description "Filter name";
       type string {
         junos:posix-pattern "!^((__.*)|(.{65,}))$";
         junos:pattern-message "Must be a non-reserved string of 64 characters or less";
       }
     }
     uses apply-advanced;
     leaf-list accounting-profile {
       description "Accounting profile name";
       junos:must "(\"accounting-options filter-profile\")";
       junos:must-message "referenced accounting profile must be defined";
       type string;
     }
     leaf interface-specific {
       description "Defined counters are interface specific";
       type empty;
     }
     list term {
       key name;
       ordered-by user;
       description "Define a firewall term";
       leaf name {
         description "Term name";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       uses apply-advanced;
       leaf filter {
         description "Filter to include";
         junos:must "(\"firewall family vpls filter $$\")";
         junos:must-message "Referenced filter is not defined";
         junos:must "((!(\".. from\") && !(\".. then\")))";
         junos:must-message "Not compatible with 'from or then'";
         type string {
           junos:posix-pattern "!^((__.*)|(.{65,}))$";
           junos:pattern-message "Must be a non-reserved string of 64 characters or less";
         }
       }
       container from {
         description "Define match criteria";
         uses apply-advanced;
         choice interface-group_choice {
           case case_1 {
             leaf-list interface-group {
               description "Range of values";
               type string;
             }
           }
           case case_2 {
             leaf-list interface-group-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice ether-type_choice {
           case case_1 {
             leaf-list ether-type {
               type string;
             }
           }
           case case_2 {
             leaf-list ether-type-except {
               type string;
             }
           }
         }
         choice vlan-ether-type_choice {
           case case_1 {
             leaf-list vlan-ether-type {
               type string;
             }
           }
           case case_2 {
             leaf-list vlan-ether-type-except {
               type string;
             }
           }
         }
         list destination-mac-address {
           key name;
           ordered-by user;
           description "Destination MAC address";
           uses firewall_mac_addr_object;
         }
         list source-mac-address {
           key name;
           ordered-by user;
           description "Source MAC address";
           uses firewall_mac_addr_object;
         }
         choice forwarding-class_choice {
           case case_1 {
             leaf-list forwarding-class {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list forwarding-class-except {
               description "String name";
               type string {
                 junos:posix-pattern "^.{1,64}$";
                 junos:pattern-message "Must be string of 64 characters or less";
               }
             }
           }
         }
         choice loss-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list loss-priority-except {
               type enumeration {
                 enum "low" {
                   description "Loss priority low";
                 }
                 enum "high" {
                   description "Loss priority high";
                 }
                 enum "medium-low" {
                   description "Loss priority medium-low";
                 }
                 enum "medium-high" {
                   description "Loss priority medium-high";
                 }
               }
             }
           }
         }
         choice learn-vlan-id_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list learn-vlan-id-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice learn-vlan-1p-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list learn-vlan-1p-priority-except {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
         }
         choice user-vlan-id_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list user-vlan-id-except {
               description "Range of values";
               type string;
             }
           }
         }
         choice user-vlan-1p-priority_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list user-vlan-1p-priority-except {
               description "802.1p priority value 0-7";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 7";
                 }
               }
             }
           }
         }
         choice learn-vlan-dei_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list learn-vlan-dei-except {
               description "DEI value 0-1";
               type union {
                 type string {
                   pattern "<.*>|$.*";
                 }
                 type uint32 {
                   range "0 .. 1";
                 }
               }
             }
           }
         }
         choice traffic-type_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list traffic-type-except {
               type enumeration {
                 enum "broadcast" {
                   description "Packets with broadcast ethernet address";
                 }
                 enum "multicast" {
                   description "Packets with multicast ethernet address";
                 }
                 enum "unknown-unicast" {
                   description "Packets for which destination ethernet address has not been learnt";
                 }
                 enum "known-unicast" {
                   description "Packets for which destination ethernet address has been learnt";
                 }
               }
             }
           }
         }
         choice ip-protocol_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ip-protocol-except {
               type string;
             }
           }
         }
         choice dscp_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list dscp-except {
               type string;
             }
           }
         }
         choice ip-precedence_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ip-precedence-except {
               type string;
             }
           }
         }
         choice source-port_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list source-port-except {
               type string;
             }
           }
         }
         choice destination-port_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list destination-port-except {
               type string;
             }
           }
         }
         choice port_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list port-except {
               type string;
             }
           }
         }
         choice icmp-type_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list icmp-type-except {
               type string;
             }
           }
         }
         choice icmp-code_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list icmp-code-except {
               type string;
             }
           }
         }
         list interface {
           key name;
           ordered-by user;
           description "Match interface name";
           uses match_interface_object;
         }
         list interface-set {
           key name;
           ordered-by user;
           description "Match interface in set";
           uses match_interface_set_object;
         }
         choice ipv6-next-header_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ipv6-next-header-except {
               type string;
             }
           }
         }
         choice ipv6-payload-protocol_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ipv6-payload-protocol-except {
               type string;
             }
           }
         }
         choice ipv6-traffic-class_choice {
           case case_1 {
           }
           case case_2 {
             leaf-list ipv6-traffic-class-except {
               type string;
             }
           }
         }
         choice flex-mask_choice {
           case case_1 {
             container flexible-match-mask {
               description "Match flexible mask";
               uses match_L2_flexible_mask;
             }
           }
         }
         choice policy-map_choice {
           case case_1 {
             leaf-list policy-map {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             leaf-list policy-map-except {
               description "String name";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "Undefined policy-map instance";
               type string {
                 length "1 .. 64";
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
       }
       container then {
         description "Action to take if the 'from' condition is matched";
         uses apply-advanced;
         choice policer-choice {
           case case_1 {
             leaf policer {
               description "Name of policer to use to rate-limit traffic";
               junos:must "(!(\"firewall policer $$ aggregate\"))";
               junos:must-message "Cannot attach a aggregate policer to filter";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
           case case_2 {
             container three-color-policer {
               junos:must "(!(\".. loss-priority\"))";
               junos:must-message "cannot support three-color-policer action if loss-priority is configured";
               description "Police the packet using a three-color-policer";
               uses apply-advanced;
               choice type-choice {
                 case case_1 {
                   leaf single-rate {
                     description "Name of single-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-rate\")";
                     junos:must-message "Referenced single-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_2 {
                   leaf single-packet-rate {
                     description "Name of single-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ single-packet-rate\")";
                     junos:must-message "Referenced single-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_3 {
                   leaf two-rate {
                     description "Name of two-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-rate\")";
                     junos:must-message "Referenced two-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
                 case case_4 {
                   leaf two-packet-rate {
                     description "Name of two-packet-rate three-color policer to use to rate-limit traffic";
                     junos:must "(\"firewall three-color-policer $$ two-packet-rate\")";
                     junos:must-message "Referenced two-packet-rate policer does not exist";
                     type string {
                       junos:posix-pattern "!^((__.*)|(.{65,}))$";
                       junos:pattern-message "Must be a non-reserved string of 64 characters or less";
                     }
                   }
                 }
               }
             }
           }
           case case_3 {
           }
         }
         choice policy-map-choice {
           case case_1 {
             leaf clear-policy-map {
               description "Clear the policy marking";
               type empty;
             }
           }
           case case_2 {
             leaf policy-map {
               description "Policy map action";
               junos:must "(\"class-of-service policy-map $$\")";
               junos:must-message "referenced policy map must be defined";
               type string {
                 junos:posix-pattern "!^((__.*)|(.{65,}))$";
                 junos:pattern-message "Must be a non-reserved string of 64 characters or less";
               }
             }
           }
         }
         leaf count {
           description "Count the packet in the named counter";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf loss-priority {
           description "Packet's loss priority";
           type enumeration {
             enum "low" {
               description "Loss priority low";
             }
             enum "high" {
               description "Loss priority high";
             }
             enum "medium-low" {
               description "Loss priority medium-low";
             }
             enum "medium-high" {
               description "Loss priority medium-high";
             }
           }
         }
         leaf forwarding-class {
           description "Classify packet to forwarding class";
           type string {
             junos:posix-pattern "^.{1,64}$";
             junos:pattern-message "Must be string of 64 characters or less";
           }
         }
         choice designation {
           case case_1 {
             leaf accept {
               description "Accept the packet";
               type empty;
             }
           }
           case case_2 {
             leaf discard {
               description "Discard the packet";
               type empty;
             }
           }
           case case_3 {
             leaf next {
               description "Continue to next term in a filter";
               type enumeration {
                 enum "term" {
                   description "Continue to next term in a filter";
                 }
               }
             }
           }
         }
         leaf port-mirror-instance {
           description "Port-mirror the packet to specified instance";
           junos:must "(\"forwarding-options port-mirroring instance $$\")";
           junos:must-message "Referenced port-mirroring instance does not exist";
           type string {
             junos:posix-pattern "!^((__.*)|(.{65,}))$";
             junos:pattern-message "Must be a non-reserved string of 64 characters or less";
           }
         }
         leaf port-mirror {
           description "Port-mirror the packet";
           junos:must "(!(\".. port-mirror-instance\"))";
           junos:must-message "'port-mirror' and 'port-mirror-instance' are mutually exclusive";
           junos:must "(\"forwarding-options port-mirroring\")";
           junos:must-message "Configure 'port-mirroring' under 'forwarding-options'";
           type empty;
         }
       }
     }
   }
 }
