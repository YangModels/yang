module arcos-sr-policy {
  yang-version 1.1;
  namespace "http://yang.arrcus.com/arcos/sr/policy";
  prefix arc-sr-pol;

  import ietf-yang-types {
    prefix yang;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import openconfig-network-instance {
    prefix oc-netinst;
  }
  import openconfig-interfaces {
    prefix oc-if;
  }
  import openconfig-mpls-types {
    prefix oc-mpls-types;
  }
  import arcos-te {
    prefix arc-te;
  }
  import arcos-srv6-types {
    prefix arc-srv6-types;
  }
  import arcos-sr-policy-types {
    prefix arc-sr-pol-types;
  }

  organization
    "Arrcus, Inc.";

  contact
    "Arrcus, Inc.
    2077 Gateway Place
    Suite 400
    San Jose, CA 95110

    E-mail: yang-support@arrcus.com";

  description
    "This module contains definitions for the
    native ArcOS SRv6 domain.

    Copyright (c) 2016-2019 by Arrcus, Inc.
    All rights reserved.";

  revision 2024-06-30 {
    description
     "Add dynamic and constraints state container for paths in database";
  }

  revision 2024-05-02 {
    description
      "* Relaxed the candidate path uniqueness configuration
       * Changed explicit-nexthop constraint type to be specified
         per next-hop instead of a common one";
  }

  revision 2024-04-30 {
    description
      "Move dynamic and explicit containers to grouping and 
       constraint grouping using when statement";
  }

  revision 2024-04-19 {
    description
      "Add support for upper-bounds, explicit-nexthops, affinities
       and calculation constraints";
  }

  revision 2024-02-01 {
    description
      "Update segment-routing database sub-tree for MPLS SIDs";
  }
  revision 2022-10-25 {
    description
      "Initial version";
  }

  // Features
  feature capability-candidate-path-binding-sid {
    description
      "This feature enables the capability of specifying binding-sid
       for a candidate path.";
  }

  typedef dataplane-type {
    type enumeration {
      enum MPLS {
        value 1;
        description "Segment-routing MPLS";
      }
      enum SRV6 {
        value 2;
        description "Segment-routing v6";
      }
    }
    description "Dataplane type of the segments";
  }

  // Groupings
  grouping binding-sid {
    description
      "Binding SID configuration properties grouping";

    leaf dataplane {
      type dataplane-type;
      description
        "Dataplane type for the binding-sid";
    }

    uses mpls-label-value {
      when "dataplane = 'MPLS'";
    }

    uses srv6-sid-value {
      when "dataplane = 'SRV6'";
    }
  }

  grouping binding-sid-state {
    description
      "Binding SID state properties grouping";

    container state {
      config false;

      leaf alloc-mode {
        type arc-sr-pol-types:binding-sid-alloc-mode;
        description
          "Binding SID type";
      }

      leaf allocated-sid {
        type arc-sr-pol-types:sid-value-type;
        description
          "Allocated SID value for the Binding SID";
      }

      leaf oper-state {
        type arc-sr-pol-types:binding-sid-oper-state;
        description
          "Binding SID operational state";
      }
    }
  }

  grouping affinities {
    description
      "Grouping for affinities related configuration and state.";

    leaf-list exclude-any {
      type leafref {
        path "/oc-netinst:network-instances" +
             "/oc-netinst:network-instance/" +
             "arc-te:te/arc-te:admin-groups/" +
             "arc-te:admin-group/arc-te:name";
      }

      description
        "The link is excluded if it has any of these
         affinities.";
    }

    leaf-list include-any {
      type leafref {
        path "/oc-netinst:network-instances" +
             "/oc-netinst:network-instance/" +
             "arc-te:te/arc-te:admin-groups/" +
             "arc-te:admin-group/arc-te:name";
      }
      description
        "The link is accepted if it has any of these
         affinities";
    }

    leaf-list include-all {
      type leafref {
        path "/oc-netinst:network-instances" +
             "/oc-netinst:network-instance/" +
             "arc-te:te/arc-te:admin-groups/" +
             "arc-te:admin-group/arc-te:name";
      }
      description
        "The link is accepted if it has all these affinities";
    }
  }

  grouping affinities-state-info {
    container affinities {
      description
        "Affinity constraints on the computed dynamic path";
      container state {
        description
          "Container for affinities state.";
        uses affinities;
      }
    }
  }

  grouping calculation-constraint-attributes {
    leaf metric-type {
      type arc-sr-pol-types:metric-type;
      description
        "Metric type";
    }
  }

  grouping calculation-state-info {
    container path-calculation {
      description
        "Path caclulation constraint";
      container state {
        description
          "Path calculation constraint state";
        config false;
        uses calculation-constraint-attributes;
      }
    }
  }

  grouping calculation-constraint-info {
    container path-calculation {
      description
        "Path caclulation constraint";
      container config {
        description
          "Path calculation constraint configuration";
        uses calculation-constraint-attributes;
      }
      container state {
        description
          "Path calculation constraint state";
        config false;
        uses calculation-constraint-attributes;
      }
    }
  }

  grouping affinities-constraint-info {
    container affinities {
      description
        "Affinity constraints on the computed dynamic path";

      container config {
        description
          "Container for affinities configuration.";

        uses affinities;
      }

      container state {
        config false;
        description
          "Container for affinities state.";

        uses affinities;
      }
    }
  }

  grouping metric-bound-constraint-atrributes {
    leaf type {
      type arc-sr-pol-types:metric-filter-type;
      description
        "Metric type";
    }
    leaf metric {
      type uint32;
      default 0;
      description
        "Path is invalid if the cumulative metric exceeds this value.
         When set to 0, the maximum metric is unbounded";
    }
  }

  grouping metric-bounds-constraint-info {
    container cumulative-metrics {
      list cumulative-metric {
        key "type";
        leaf type {
          type leafref {
            path "../config/type";
          }
          description
            "Metric type";
        }
        description
          "Cumulative metric constraint";
        container config {
          description
            "Cumulative metric constraint configuration";
          uses metric-bound-constraint-atrributes;
        }
        container state {
          config false;
          description
            "Cumulative metric constraint state";
          uses metric-bound-constraint-atrributes;
        }
      }
    }
  }

  grouping bounds {
    description
      "Grouping for bounds configuration and state.";

    leaf maximum-hop-count {
      type uint8;
      description
        "Path is invalid if it has more hops than this value";
    }

    leaf maximum-segments {
      type uint8 {
        range "0..8";
      }
      description
        "Path is invalid when the segments derived are more than this value";
    }
  }

  grouping bounds-state-info {
    container upper-bounds {
      description
        "Upper-bound constraints on the computed dynamic path";

      container state {
        config false;
        description
          "Container for bounds state.";

        uses bounds;
      }

      container cumulative-metrics {
        list cumulative-metric {
          key "type";
          leaf type {
            type leafref {
              path "../state/type";
            }
            description
              "Metric type";
          }
          description
            "Cumulative metric constraint";
          container state {
            config false;
            description
              "Cumulative metric constraint state";
            uses metric-bound-constraint-atrributes;
          }
        }
      }
    }
  }

  grouping bounds-constraint-info {
    container upper-bounds {
      description
        "Upper-bound constraints on the computed dynamic path";

      container config {
        description
          "Container for bounds configuration.";

        uses bounds;
      }

      container state {
        config false;
        description
          "Container for bounds state.";

        uses bounds;
      }

      uses metric-bounds-constraint-info;
    }
  }

  grouping segment-rules-state-info {
    container segment-rules {
      description
        "Constraints on the segments to be used in the path.";

      container state {
        description
          "Container for segment rules state.";

        leaf sid-algorithm {
          type uint8;
          description
            "The prefix-sid algorithm to be used in path
              calculation.";
        }
      }
    }
  }

  grouping segment-rules-constraint-info {
    container segment-rules {
      description
        "Constraints on the segments to be used in the path.";

      container config {
        description
          "Container for segment rules configuration.";

        leaf sid-algorithm {
          type uint8 {
            range "0 | 128..255";
          }
          description
            "The prefix-sid algorithm to be used in path calculation.
             Algorithm 0 represents SPF";
        }
      }

      container state {
        config false;
        description
          "Container for segment rules state.";

        leaf sid-algorithm {
          type uint8;
          description
            "The prefix-sid algorithm to be used in path
              calculation.";
        }
      }
    }
  }

  typedef explicit-nexthop-type {
    type enumeration {
      enum NODE_ADDRESS {
        value 1;
      }
      enum LOCAL_REMOTE_ADDRESSES {
        value 2;
      }
    }
  }

  typedef nexthop-constraint-type {
    type enumeration {
      enum STRICT_HOP {
        value 1;
        description "Strict next-hop";
      }
      enum LOOSE_HOP {
        value 2;
        description "Loose next-hop";
      }
    }
  }

  grouping node-address-nexthop-attributes {
    leaf node-address {
      mandatory true;
      type inet:ip-address-no-zone;
      description "Node address as next-hop";
    }

    leaf constraint-type {
      type nexthop-constraint-type;
      default LOOSE_HOP;
      description "Node address constraint type";
    }
  }

  grouping node-address-nexthop {
    container node {
      description
        "Node address constraint information";
      container config {
        description
          "Node address constraint configuration";
        uses node-address-nexthop-attributes;
      }
      container state {
        config false;
        description
          "Node address constraint state";
        uses node-address-nexthop-attributes;
      }
    }
  }

  grouping local-remote-address-pair-nexthop-attributes {
    leaf local-address {
      type inet:ip-address-no-zone;
      mandatory true;
      description "Local address identifying the link";
    }
    leaf remote-address {
      type inet:ip-address-no-zone;
      mandatory true;
      description "Remote address indentifying the link";
    }
    leaf constraint-type {
      type nexthop-constraint-type;
      default STRICT_HOP;
      description "Link address pair constraint type";
    }
  }

  grouping local-remote-address-pair-nexthop {
    container link {
      description
        "Link address pair constraint information";
      container config {
        description
          "Link address pair constraint configuration";
        uses local-remote-address-pair-nexthop-attributes;
      }
      container state {
        config false;
        description
          "Link address pair constraint state";
        uses local-remote-address-pair-nexthop-attributes;
      }
    }
  }

  grouping explicit-nexthop-info {
    leaf type {
      type explicit-nexthop-type;
      mandatory true;
      description "Nexthop type";
    }
    leaf index {
      type uint8 {
        range "1..64";
      }
      description "Nexthop index";
    }
  }

  grouping explicit-nexthops-state-info {
    container explicit-nexthops {
      uses explicit-nexthops-state-list-info;
    }
  }

  grouping explicit-nexthops-state-list-info {
    container nexthops {
      list nexthop {
        key "index";
        leaf index {
          type leafref {
            path "../state/index";
          }
          description "Nexthop index";
        }
        container state {
          config false;
          uses explicit-nexthop-info;
          description "Nexthop state";
        }
        container node {
          when "../state/type = 'NODE_ADDRESS'";
          description
            "Node address constraint information";
          container state {
            config false;
            description
              "Node address constraint state";
            uses node-address-nexthop-attributes;
          }
        }
        container link {
          when "../state/type = 'LOCAL_REMOTE_ADDRESSES'";
          container state {
            config false;
            description
              "Link address pair constraint state";
            uses local-remote-address-pair-nexthop-attributes;
          }
        }
      }
    }
  }

  grouping explicit-nexthop-constraint-info {
    container explicit-nexthops {
      uses explicit-nexthop-constraint-list-info;
    }
  }

  grouping explicit-nexthop-constraint-list-info {
    container nexthops {
      list nexthop {
        key "index";
        leaf index {
          type leafref {
            path "../config/index";
          }
          description "Nexthop index";
        }
        container config {
          uses explicit-nexthop-info;
          description "Nexthop configuration";
        }
        container state {
          config false;
          uses explicit-nexthop-info;
          description "Nexthop state";
        }
        uses node-address-nexthop {
          when "config/type = 'NODE_ADDRESS'";
        }
        uses local-remote-address-pair-nexthop {
          when "config/type = 'LOCAL_REMOTE_ADDRESSES'";
        }
      }
    }
  }

  grouping disjoint-path {
    description
      "Grouping for disjoint path configuration and state.";

    leaf group-id {
      type uint32 {
        range "1..65535";
      }
      description "";
    }

    leaf disjointness-type {
      type identityref {
        base arc-sr-pol-types:path-disjointness;
      }
      description
        "Type of disjointness computation used to find the
         path";
    }

    leaf subgroup-id {
      type uint32 {
        range "1..65535";
      }
      description "";
    }
  }

  grouping disjoint-path-constraint-info {
    container disjoint-path {
      description
        "Path disjointness constraints";

      container config {
        description
          "Container for disjoint path configuration.";

        uses disjoint-path;
      }

      container state {
        config false;
        description
          "Container for disjoint path state.";

        uses disjoint-path;
      }
    }
  }

  grouping path-segment-list-attributes {
    description
      "Explicit candidate path's segment-list attributes";

    leaf name {
      type leafref {
        path "/oc-netinst:network-instances/oc-netinst:network-instance" +
             "/arc-sr-pol:sr-policy/arc-sr-pol:segment-lists" +
             "/arc-sr-pol:segment-list/arc-sr-pol:name";
      }
      description "Segment-list name";
    }

    leaf weight {
      type uint32 {
        range "1";
      }
      default 1;
      description
        "Segment-list weighted loadshare";
    }
  }

  grouping explicit-candidate-path {
    container segment-lists {
      description
        "Path segment list(s) properties";

      list segment-list {
        key "name";
        description
          "SR policy candidate path segment lists";

        leaf name {
          type leafref {
            path "../config/name";
          }
          description "Segment-list name";
        }

        container config {
          description
            "Container for segment lists configuration.";
          uses path-segment-list-attributes;
        }

        container state {
          config false;
          description
            "Container for segment lists state.";
          uses path-segment-list-attributes;
        }
      }
    }
  }

  grouping dynamic-path-constraints {
    container config {
      description
        "Container for dynamic candidate path configuration.";

      leaf dataplane {
        type dataplane-type;
        default SRV6;
        description
          "The dataplane type for the sid";
      }
    }

    container state {
      config false;
      description
        "Container for dynamic candidate path state.";

      leaf dataplane {
        type dataplane-type;
        description
          "The dataplane type for the sid";
      }
    }

    container constraints {
      description
        "Constraints for the dynamic path computation";

      /*
       * Atleast one of affinities, explicit-nexthop, sid-algorithm
       * to be specified
       */
      must "(segment-rules/config/sid-algorithm >= 0) or " +
           "(count(explicit-nexthops/nexthops/nexthop) > 0) or " +
           "(count(affinities/config/exclude-any) > 0) or " +
           "(count(affinities/config/include-any) > 0) or " +
           "(count(affinities/config/include-all) > 0)" {
        error-message "Atleast one of affinities (or) explicit-nexthop" +
                      " (or) segment-rules to be specified";
      }

      /*
       * sid-algorithm and metric-type cannot be specified together
       */
      must "not(segment-rules/config/sid-algorithm) or " +
           "not(path-calculation/config/metric-type)" {
        error-message "metric-type and sid-algorithm cannot be specified together";
      }

      /*
       * When affinity is specified, metric-type must be specified
       */
      must "(count(affinities/config/exclude-any) = 0) or " +
           "((count(affinities/config/exclude-any) > 0) and " +
           "(enum-value(path-calculation/config/metric-type) > 0))" {
        error-message "metric-type must be specified for affinities";
      }

      must "(count(affinities/config/include-any) = 0) or " +
           "((count(affinities/config/include-any) > 0) and " +
           "(enum-value(path-calculation/config/metric-type) > 0))" {
        error-message "metric-type must be specified for affinities";
      }

      must "(count(affinities/config/include-all) = 0) or " +
           "((count(affinities/config/include-all) > 0) and " +
           "(enum-value(path-calculation/config/metric-type) > 0))" {
        error-message "metric-type must be specified for affinities";
      }

      /*
       * Explicit next-hops constraint requires metric-type to be specified
       */
      must "((count(explicit-nexthops/nexthops/nexthop) = 0) or " +
           "(enum-value(path-calculation/config/metric-type) > 0))" {
        error-message "calculation metric-type has to be specified for " +
                      "explicit-nexthops constraint";
      }

      uses calculation-constraint-info;
      uses affinities-constraint-info;
      uses bounds-constraint-info;
      uses segment-rules-constraint-info;
      uses disjoint-path-constraint-info;
      uses explicit-nexthop-constraint-info;
    }
  }

  grouping segment-list-state {
    description
      "Grouping for segment-list state.";

    container state {
      leaf index {
        type uint32;
        description
          "Segment-list index.";
      }

      leaf valid {
        type boolean;
        description
          "Segment-list validity.";
      }

      leaf name {
        type string;
        description
          "Segment-list name.";
      }

      leaf dependent-count {
        type uint32;
        description
          "Dependant count for segment-list";
      }
    }

    container segments {
      description
        "Container for segments.";

      list segment {
        description
          "List of segments.";

        key index;

        leaf index {
          type leafref {
            path "../state/index";
          }
          description
            "Segment index.";
        }

        container state {
          leaf index {
            type uint8;
            description
              "Segment index.";
          }

          leaf valid {
            type boolean;
            description
              "Segment validity.";
          }

          leaf type {
            type arc-sr-pol-types:segment-type;
            mandatory true;
            description
              "Segment type";
          }
        }
        uses segment-value-state-only;
      }
    }

    container forwarding-paths {
      description
        "Forwarding state of paths";

      list forwarding-path {
        key "path-id";
        description
          "Forwarding path";

        leaf path-id {
          type leafref {
            path "../state/path-id";
          }
          description
            "Primary path id";
        }

        uses forward-path;
      }
    }
  }

  grouping forward-path {
    description
      "Grouping for forward path state.";

    container state {
      description
        "Forward path state.";

      leaf path-id {
        type uint8;
        description
          "Primary path id";
      }

      leaf dataplane {
        type dataplane-type;
        description
          "Dataplane type";
      }

      leaf-list mpls-label-stack {
        type oc-mpls-types:mpls-label;
        description
          "MPLS label value";
      }

      leaf-list srv6-sid-list {
        type inet:ipv6-address;
        description
          "SRv6 sid value";
      }

      leaf next-hop-address {
        type inet:ip-address;
        description
          "Nexthop address";
      }

      leaf next-hop-network-instance {
        type oc-netinst:network-instance-ref;
        description
          "Table ID for nexthop address";
      }

      leaf interface {
        type oc-if:base-interface-ref;
        description
          "Outgoing interface handle";
      }

      leaf protected {
        type boolean;
        description
          "Is this path protected ?";
      }

      leaf backup {
        type boolean;
        description
          "Is this path a backup ?";
      }

      leaf backup-path-id {
        type uint8;
        description
          "Backup path id";
      }

      leaf weight {
        type uint32;
        description
          "Path's weight for W-ECMP balancing";
      }
    }
  }

  grouping dynamic-constraints-state {
    container dynamic {
      container state {
        leaf dataplane {
          type dataplane-type;
        }
        description
          "Constraint state";
      }

      uses constraints-state;
    }
  }

  grouping constraints-state {
    container constraints {
      uses calculation-state-info;
      uses affinities-state-info;
      uses bounds-state-info;
      uses segment-rules-state-info;
      uses explicit-nexthops-state-info;
    }
  }

  grouping segment-lists-state {
    container segment-lists {
      description
        "Segment-lists of candidate-path.";

      list segment-list {
        description
          "List of segment-lists.";
        key "index";

        leaf index {
          type leafref {
            path "../state/index";
          }
          description
            "Segment-list index.";
        }

        container state {
          description
            "Segment-list state information.";

          leaf index {
            type uint32;
            description
              "Segment-list index.";
          }

          leaf name {
            type string;
            description
              "Segment-list name.";
          }

          leaf valid {
            type boolean;
            description
              "Segment-list validity.";
          }
        }
      }
    }
  }

  grouping candidate-path-rib {
    description
      "Grouping for candidate path state.";

    container binding-sid {
      uses binding-sid-state;
    }

    uses dynamic-constraints-state {
      when "state/type = 'DYNAMIC_SEGMENT_LIST'";
    }

    uses segment-lists-state;

    container forwarding-paths {
      description
        "Forwarding state of paths";

      list forwarding-path {
        key "path-id";
        description
          "Forwarding path";

        leaf path-id {
          type leafref {
            path "../state/path-id";
          }
          description
            "Primary path id";
        }

        uses forward-path;
      }
    }

    container state {
      leaf protocol-origin {
        type arc-sr-pol-types:protocol-origin-type;
        description
          "Instantiation mechanism used to create the candidate
           path";
      }

      leaf originator {
        type string;
        description
          "Identifier (concatenation of ASN and node-address)
           of the node that signalled/instantiated the candidate
           path on headend";
      }

      leaf discriminator {
        type uint32;
        description
          "Candidate path distinguisher";
      }

      leaf preference {
        type uint32;
        description
          "Candiate path's preference.";
      }

      leaf type {
        type arc-sr-pol-types:candidate-path-type;
        description
          "Candidate path type";
      }

      leaf best-candidate-path {
        type boolean;
        default 'false';
        description
          "True if the candidate path is the best candidate path,
          False otherwise";
      }

      leaf non-best-reason {
        type identityref {
          base arc-sr-pol-types:candidate-path-not-selected-reason;
        }
        description
          "Candidate path not selected reason";
      }

      leaf valid {
        type boolean;
        description
          "True if the segment-list is valid, False otherwise";
      }
    }
  }

  grouping candidate-path-attributes {
    leaf discriminator {
      type uint32;
      description
        "Candidate path distinguisher";
    }

    leaf preference {
      type uint32 {
        range "1..max";
      }
      default 100;
      description
        "Candidate path preference";
    }

    leaf originator-as {
      type uint32 {
        range "0..4294967295";
      }
      default 0;
      description
        "Candidate path originator AS";
    }

    leaf originator-address {
      type inet:ip-address;
      default 0.0.0.0;
      description
        "Candidate path Originator address";
    }

    leaf name {
      type string;
      description
        "Candidate path name";
    }

    leaf description {
      type string;
      description
        "Candidate path description";
    }

    leaf type {
      type arc-sr-pol-types:candidate-path-type;
      description
        "Candidate path type";
    }
  }


  grouping explicit-path {
    container explicit {
      description
        "Candidate path with explicitly defined set/s of
          segment-lists";
      uses explicit-candidate-path;
    }
  }

  grouping dynamic-path {
    container dynamic {
      description
        "Candidate path with dynamic computed segment-lists";
      uses dynamic-path-constraints;
    }
  }

  grouping candidate-paths {
    description
      "Grouping for candidate paths config and state.";

    container candidate-paths {
      description
        "SR policy candidate path(s) ";

      list candidate-path {
        key "discriminator";
        description
          "SR policy Candidate path(s) list entry";

        leaf discriminator {
          type leafref {
            path "../config/discriminator";
          }
        }

        container config {
          description
            "Container for candidate path configuration.";

          uses candidate-path-attributes;
        }

        container state {
          config false;
          description
            "Container for candidate path state.";

          uses candidate-path-attributes;
        }

        uses explicit-path {
          description
            "Candidate path with segment-lists specified
             explicitly";
          when "config/type = 'EXPLICIT_SEGMENT_LIST'";
        }

        uses dynamic-path {
          description
            "Candidate path with dynamic constraints to derive
             the segment-lists";
          when "config/type = 'DYNAMIC_SEGMENT_LIST'";
        }
      }
    }
  }

  grouping policy-attributes {
    description
      "Grouping for policy list.";

    leaf color {
      type uint32 {
        range "1..max";
      }
      description
        "Color associated with the policy";
    }

    leaf endpoint {
      type inet:ip-address;
      description
        "Policy end point IP address";
    }

    leaf name {
      type string {
        length "1..59";
      }
      description "SR policy name";
    }

    leaf description {
      type string;
      description
        "Description of the policy";
    }

    leaf enabled {
      type boolean;
      default true;
      description
        "SR policy enabled state, true for
         enabled, false for disabled.";
    }

    leaf priority {
      type uint8;
      default 128;
      description
        "Priority considered when policy is recomputed due to
         topology changes";
    }
  }

  grouping policy-state {
    description
      "Grouping for policy list state.";

    container binding-sid {
      uses binding-sid-state;
    }

    container candidate-paths {
      list candidate-path {
        key "protocol-origin originator discriminator";
        leaf protocol-origin {
          type leafref {
            path "../state/protocol-origin";
          }
          description
            "Instantiation mechanism used to create the candidate
             path";
        }

        leaf originator {
          type leafref {
            path "../state/originator";
          }
          description
            "Identifier (concatenation of ASN and node-address)
             of the node that signalled/instantiated the candidate
             path on headend";
        }

        leaf discriminator {
          type leafref {
            path "../state/discriminator";
          }
          description
            "Candidate path distinguisher";
        }

        uses candidate-path-rib;
      }
    }

    container counters {
      description
        "Counters containing stats related to forwarding";
      container state {
        leaf packets {
          type yang:zero-based-counter64;
          description
            "Number of packets forwarded";
        }

        leaf octets {
          type yang:zero-based-counter64;
          units "byte";
          description
            "Number of bytes forwarded";
        }
      }
    }

    container state {
      leaf color {
        type uint32;
        description
          "Color of SR Policy";
      }

      leaf endpoint {
        type inet:ip-address;
        description
          "Endpoint address of SR Policy";
      }

      leaf oper-state {
        type arc-sr-pol-types:policy-oper-state;
        description
          "SR policy operational state";
      }

      leaf transition-count {
        type uint32;
        description
          "Indicates number of up/down transitions";
      }

      leaf up-time {
        type yang:date-and-time;
        description
          "Policy up time in seconds";
      }

      leaf down-time {
        type yang:date-and-time;
        description
          "Policy down time in seconds";
      }

      leaf nexthop-id {
        type uint32;
        description
          "Forwarding path ID used in RIB";
      }
    }
  }

  grouping recursive-nexthop-database {
    container recursive-nexthops {
      list recursive-nexthop {
        key "id";

        leaf id {
          type leafref {
            path "../state/id";
          }
          description
            "Recursive nexthop ID";
        }
        container nexthop {
          container state {
            leaf address {
              type inet:ip-address;
              description
                "Nexthop address";
            }
          }
          container colors {
            list color {
              key "flags value";

              leaf flags {
                type leafref {
                  path "../state/flags";
                }
                description
                  "CO Flags";
              }

              leaf value {
                type leafref {
                  path "../state/value";
                }
                description
                  "Color value";
              }

              container state {
                leaf flags {
                  type uint16;
                  description
                    "CO Flags";
                }

                leaf value {
                  type uint32;
                  description
                    "Color value";
                }
              }
            }
          }
        }

        container state {
          leaf id {
            type string;
            description
              "Recursive nexthop ID";
          }

          leaf resolved {
            type boolean;
            description
              "Resolution state of the nexthop.";
          }

          leaf nexthop-id {
            type uint32;
            description
              "Recursive nexthop ID";
          }

          leaf resolving-policy-color {
            type uint32;
            description
              "Color of the SR-Policy resolving the nexthop";
          }

          leaf resolving-policy-endpoint {
            type inet:ip-address;
            description
              "Endpoint of the SR-Policy resolving the nexthop";
          }
        }
      }
    }
  }

  grouping sr-node-algo-info {
    container algorithms {
      list algorithm {
        key "id address";
        description "Node level information";
        leaf id {
          type leafref {
            path "../state/id";
          }
          description
            "Flexible algorithm identifier";
        }
        leaf address {
          type leafref {
            path "../state/address";
          }
          description
            "Node address";
        }

        container state {
          leaf id {
            type uint8;
            description
              "Algorithm identifier";
          }
          leaf address {
            type inet:ip-address;
            description
              "Node address";
          }
          leaf-list srv6-sids {
            type inet:ipv6-address;
            description
              "SRv6 SIDs";
          }
          leaf-list mpls-labels {
            type uint32;
            description
              "MPLS labels";
          }
        }
      }
    }
  }

  grouping sr-node-info {
    container nodes {
      list node {
        key "protocol id level";
        description
          "Node information";
        leaf protocol {
          type leafref {
            path "../state/protocol";
          }
          description
            "Protocol source";
        }
        leaf id {
          type leafref {
            path "../state/id";
          }
          description
            "Node ID";
        }
        leaf level {
          type leafref {
            path "../state/level";
          }
          description
            "Node participation level";
        }
        container state {
          leaf protocol {
            type string;
            description
              "Protocol source";
          }
          leaf id {
            type string;
            description
              "Node ID";
          }
          leaf level {
            type uint8;
            description
              "Node participation level";
          }
        }
        uses sr-node-algo-info;
      }
    }
  }

  grouping sr-route-algo-info {
    container algorithms {
      list algorithm {
        key "id";
        leaf id {
          type leafref {
            path "../state/id";
          }
          description
            "Segment routing algorithm";
        }
        container state {
          leaf id {
            type uint8;
            description
              "Segment routing algorithm";
          }
        }
        container protocols {
          list protocol {
            key "id";

            leaf id {
              type leafref {
                path "../state/id";
              }
            }
            container state {
              leaf id {
                type string;
                description
                  "Protocol ID";
              }
              leaf nexthop-id {
                type uint32;
                description
                  "Nexthop ID";
              }
            }
          }
        }
      }
    }
  }

  grouping sr-route-info {
    container routes {
      list route {
        key "prefix";
        description
          "Segment routing database";

        leaf prefix {
          type leafref {
            path "../state/prefix";
          }
          description
            "Route prefix";
        }
        container state {
          leaf prefix {
            type inet:ip-prefix;
            description
              "Route prefix";
          }
        }
        uses sr-route-algo-info;
      }
    }
  }

  grouping sr-label-info {
    container label-routes {
      list label-route {
        key "label";
        description
          "Segment routing label database";

        leaf label {
          type leafref {
            path "../state/label";
          }
          description
            "Label value";
        }
        container state {
          leaf label {
            type uint32;
            description
              "Label value";
          }
        }
        uses sr-route-algo-info;
      }
    }
  }

  grouping sr-nexthop-path-info {
    container paths {
      list path {
        key "id";

        leaf id {
          type leafref {
            path "../state/id";
          }
          description
            "Path ID";
        }

        container state {
          leaf id {
            type uint32;
            description "Path ID";
          }

          leaf address {
            type inet:ip-address;
            description
              "Nexthop address";
          }

          leaf-list srv6-sid-list {
            type inet:ipv6-address;
            description
              "SRv6 SID list";
          }

          leaf-list mpls-label-stack {
            type uint32;
            description
              "MPLS label stack";
          }

          leaf interface {
            type string;
            description
              "Outbound Interface name";
          }

          leaf metric {
            type uint32;
            description
              "Path metric";
          }

          leaf hop-count {
            type uint32;
            description
              "Hop count";
          }
        }
      }
    }
  }

  grouping sr-nexthop-info {
    container nexthops {
      list nexthop {
        key "protocol id";
        leaf protocol {
          type leafref {
            path "../state/protocol";
          }
          description
            "Protocol ID";
        }
        leaf id {
          type leafref {
            path "../state/id";
          }
          description
            "Nexthop ID";
        }
        container state {
          leaf protocol {
            type string;
            description "Protocol ID";
          }
          leaf id {
            type uint32;
            description
              "Nexthop ID";
          }
          leaf dependent-routes {
            type uint32;
            description
              "Dependant route count";
          }
          leaf dependent-label-routes {
            type uint32;
            description
              "Dependant label route count";
          }
        }
        uses sr-nexthop-path-info;
      }
    }
  }

  grouping segment-routing-database {
    container segment-routing {
      uses sr-node-info;
      uses sr-route-info;
      uses sr-label-info;
      uses sr-nexthop-info;
    }
  }

  grouping policy-database {
    container policies {
      list policy {
        key "endpoint color";
        description
          "SR Policy state";

        leaf color {
          type leafref {
            path "../state/color";
          }
          description
            "Color of SR Policy";
        }

        leaf endpoint {
          type leafref {
            path "../state/endpoint";
          }
          description
            "Endpoint address of SR Policy";
        }

        uses policy-state;
      }
    }
  }

  grouping segment-list-database {
    container segment-lists {
      description
        "Segment-lists of candidate-path.";

      list segment-list {
        description
          "List of segment-lists.";
        key "index";

        leaf index {
          type leafref {
            path "../state/index";
          }
          description
            "Segment-list index.";
        }
        uses segment-list-state;
      }
    }
  }

  grouping sr-policy-database {
    container database {
      config false;
      description
        "SR Policy state container";

      uses policy-database;
      uses segment-list-database;
      uses recursive-nexthop-database;
      uses segment-routing-database;
    }
  }

  grouping sr-policy-list {
    description
      "SR policy grouping";

    container policies {
      description
        "SR Policy container";

      list policy {
        key "endpoint color";
        unique "config/name";
        description
          "SR Policy properties";

        leaf endpoint {
          type leafref {
            path "../config/endpoint";
          }
        }

        leaf color {
          type leafref {
            path "../config/color";
          }
        }

        container binding-sid {
          container config {
            description
              "Binding-SID for the policy.";

            uses binding-sid;
          }
          container state {
            config false;
            description
              "Binding-SID for the policy.";

            uses binding-sid;
          }
        }

        container config {
          description
            "Container for config information of SR policies.";

          uses policy-attributes;
        }

        container state {
          config false;
          description
            "Container for state information of SR policies.";

          uses policy-attributes;
        }
        uses candidate-paths;
      }
    }
  }

  grouping dynamic-sr-policy {
    description
      "Dynamic SR Policy configuration";
    container dynamic-policy-colors {
      list dynamic-policy-color {
        key "color";

        leaf color {
          type leafref {
            path "../config/color";
          }
          description
            "Policy color";
        }

        container dynamic {
          description
            "Dynamic constraints configuration";
          uses dynamic-path-constraints;
        }

        container config {
          leaf color {
            type uint32;
            description
              "Policy color";
          }
        }

        container state {
          config false;
          leaf color {
            type uint32;
            description
              "Policy color";
          }
        }
        container dynamic-policies {
          config false;
          list dynamic-policy {
            key "endpoint";
            leaf endpoint {
              type leafref {
                path "../state/endpoint";
              }
              description "Endpoint address";
            }
            container state {
              leaf endpoint {
                type inet:ip-address;
                description "Endpoint address";
              }
              leaf-list recursive-nexthop {
                type string;
                description "Dependent RNH list";
              }
            }
          }
        }
      }
      description
        "Dynamic Policies configuration";
    }
  }

  grouping mpls-label-value {
    leaf mpls-label {
      type oc-mpls-types:mpls-label;
      mandatory true;
      description
        "MPLS label value";
    }
  }

  grouping srv6-sid-value {
    leaf srv6-sid {
      type arc-srv6-types:srv6-sid;
      mandatory true;
      description
        "SRv6 SID value";
    }
  }

  grouping algorithm-value {
    leaf algorithm {
      type uint8;
      default 0;
      description
        "Algorithm ID";
    }
  }

  grouping ipv4-prefix-value {
    leaf ipv4-prefix {
      type inet:ipv4-prefix;
      mandatory true;
      description
        "IPv4 prefix";
    }
  }

  grouping ipv6-global-prefix-value {
    leaf ipv6-global-prefix {
      type inet:ipv6-prefix;
      mandatory true;
      description
        "IPv6 global prefix";
    }
  }

  grouping interface-value {
    leaf interface {
      type uint32;
      mandatory true;
      description
        "Local interface name";
    }
  }

  grouping local-remote-ipv6-address-value {
    leaf local-ipv6-address {
      type inet:ipv6-address;
      mandatory true;
      description
        "Local IPv6 address";
    }
    leaf remote-ipv6-address {
      type inet:ipv6-address;
      mandatory true;
      description
        "Remote IPv6 address";
    }
  }

  grouping local-remote-ipv4-address-value {
    leaf local-ipv4-address {
      type inet:ipv4-address;
      mandatory true;
      description
        "Local IPv4 address";
    }
    leaf remote-ipv4-address {
      type inet:ipv4-address;
      mandatory true;
      description
        "Remote IPv4 address";
    }
  }

  grouping local-remote-interface-value {
    leaf local-interface {
      type uint32;
      mandatory true;
      description
        "Local Interface ID";
    }
    leaf remote-interface {
      type uint32;
      description
        "Remote Interface ID";
    }
  }

  grouping segment-value {
    description
      "Grouping of segment types";

    container segment-mpls-label {
      when "../config/type = 'MPLS_LABEL'";
      description
        "Type A: SR-MPLS Label";
      container config {
        uses mpls-label-value;
      }
      container state {
        config false;
        uses mpls-label-value;
      }
    }

    container segment-srv6-sid {
      when "../config/type = 'SRV6_SID'";
      description
        "Type B: SRv6 SID";
      container config {
        uses srv6-sid-value;
      }
      container state {
        config false;
        uses srv6-sid-value;
      }
    }

    container segment-ipv4-prefix {
      when "../config/type = 'IPV4_PREFIX'";
      description
        "Type C: IPv4 Prefix with optional SR Algorithm";
      container config {
        uses ipv4-prefix-value;
        uses algorithm-value;
      }
      container state {
        config false;
        uses ipv4-prefix-value;
        uses algorithm-value;
      }
    }

    container segment-ipv6-global-prefix-for-mpls {
      when "../config/type = 'IPV6_GLOBAL_PREFIX_MPLS'";
      description
        "Type D: IPv6 Global Prefix with optional SR Algorithm for SR-MPLS";
      container config {
        uses ipv6-global-prefix-value;
        uses algorithm-value;
      }
      container state {
        config false;
        uses ipv6-global-prefix-value;
        uses algorithm-value;
      }
    }

    container segment-ipv4-prefix-over-interface {
      when "../config/type = 'IPV4_PREFIX_OVER_INTERFACE'";
      description
        "Type E: IPv4 Prefix with Local Interface ID";
      container config {
        uses ipv4-prefix-value;
        uses interface-value;
      }
      container state {
        config false;
        uses ipv4-prefix-value;
        uses interface-value;
      }
    }

    container segment-ipv4-endpoints {
      when "../config/type = 'IPV4_ENDPOINTS'";
      description
        "Type F: IPv4 Addresses for link endpoints as Local, Remote pair";
      container config {
        uses local-remote-ipv4-address-value;
      }
      container state {
        config false;
        uses local-remote-ipv4-address-value;
      }
    }

    container segment-ipv6-prefix-interface-endpoints-for-mpls {
      when "../config/type = 'IPV6_PREFIX_INTERFACE_ENDPOINTS_MPLS'";
      description
        "Type G: IPv6 Prefix and Interface ID for link endpoints as
         Local, Remote pair for SR-MPLS";
      container config {
        uses local-remote-ipv6-address-value;
        uses local-remote-interface-value;
      }
      container state {
        config false;
        uses local-remote-ipv6-address-value;
        uses local-remote-interface-value;
      }
    }

    container segment-ipv6-address-endpoints-for-mpls {
      when "../config/type = 'IPV6_ADDRESS_ENDPOINTS_MPLS'";
      description
        "Type H: IPv6 Addresses for link endpoints as Local,
         Remote pair for SR-MPLS";
      container config {
        uses local-remote-ipv6-address-value;
      }
      container state {
        config false;
        uses local-remote-ipv6-address-value;
      }
    }

    container segment-ipv6-global-prefix-for-srv6 {
      when "../config/type = 'IPV6_GLOBAL_PREFIX_SRV6'";
      description
        "Type I: IPv6 Global Prefix with optional
         SR Algorithm for Srv6";
      container config {
        uses algorithm-value;
        uses ipv6-global-prefix-value;
      }
      container state {
        config false;
        uses algorithm-value;
        uses ipv6-global-prefix-value;
      }
    }

    container segment-ipv6-prefix-interface-endpoints-for-srv6 {
      when "../config/type = 'IPV6_PREFIX_INTERFACE_ENDPOINTS_SRV6'";
      description
        "Type J: IPv6 Prefix and Interface ID for link
         endpoints as Local, Remote pair for SRv6";
      container config {
        uses local-remote-ipv6-address-value;
        uses local-remote-interface-value;
        uses algorithm-value;
      }
      container state {
        config false;
        uses local-remote-ipv6-address-value;
        uses local-remote-interface-value;
        uses algorithm-value;
      }
    }

    container segment-ipv6-address-endpoints-for-srv6 {
      when "../config/type = 'IPV6_ADDRESS_ENDPOINTS_SRV6'";
      description
        "Type K: IPv6 Addresses for link endpoints as
         Local, Remote pair for SRv6";
      container config {
        uses local-remote-ipv6-address-value;
        uses algorithm-value;
      }
      container state {
        config false;
        uses local-remote-ipv6-address-value;
        uses algorithm-value;
      }
    }
  }

  grouping segment-value-state-only {
    description
      "Grouping of segment state types";

    container segment-mpls-label {
      when "../state/type = 'MPLS_LABEL'";
      description
        "Type A: SR-MPLS Label";
      container state {
        uses mpls-label-value;
      }
    }

    container segment-srv6-sid {
      when "../state/type = 'SRV6_SID'";
      description
        "Type B: SRv6 SID";
      container state {
        uses srv6-sid-value;
      }
    }

    container segment-ipv4-prefix {
      when "../state/type = 'IPV4_PREFIX'";
      description
        "Type C: IPv4 Prefix with optional SR Algorithm";
      container state {
        uses ipv4-prefix-value;
        uses algorithm-value;
      }
    }

    container segment-ipv6-global-prefix-for-mpls {
      when "../state/type = 'IPV6_GLOBAL_PREFIX_MPLS'";
      description
        "Type D: IPv6 Global Prefix with optional SR Algorithm for SR-MPLS";
      container state {
        uses ipv6-global-prefix-value;
        uses algorithm-value;
      }
    }

    container segment-ipv4-prefix-over-interface {
      when "../state/type = 'IPV4_PREFIX_OVER_INTERFACE'";
      description
        "Type E: IPv4 Prefix with Local Interface ID";
      container state {
        uses ipv4-prefix-value;
        uses interface-value;
      }
    }

    container segment-ipv4-endpoints {
      when "../state/type = 'IPV4_ENDPOINTS'";
      description
        "Type F: IPv4 Addresses for link endpoints as Local, Remote pair";
      container state {
        uses local-remote-ipv4-address-value;
      }
    }

    container segment-ipv6-prefix-interface-endpoints-for-mpls {
      when "../state/type = 'IPV6_PREFIX_INTERFACE_ENDPOINTS_MPLS'";
      description
        "Type G: IPv6 Prefix and Interface ID for link endpoints as
         Local, Remote pair for SR-MPLS";
      container state {
        uses local-remote-ipv6-address-value;
        uses local-remote-interface-value;
      }
    }

    container segment-ipv6-address-endpoints-for-mpls {
      when "../state/type = 'IPV6_ADDRESS_ENDPOINTS_MPLS'";
      description
        "Type H: IPv6 Addresses for link endpoints as Local,
         Remote pair for SR-MPLS";
      container state {
        uses local-remote-ipv6-address-value;
      }
    }

    container segment-ipv6-global-prefix-for-srv6 {
      when "../state/type = 'IPV6_GLOBAL_PREFIX_SRV6'";
      description
        "Type I: IPv6 Global Prefix with optional
         SR Algorithm for Srv6";
      container state {
        uses algorithm-value;
        uses ipv6-global-prefix-value;
      }
    }

    container segment-ipv6-prefix-interface-endpoints-for-srv6 {
      when "../state/type = 'IPV6_PREFIX_INTERFACE_ENDPOINTS_SRV6'";
      description
        "Type J: IPv6 Prefix and Interface ID for link
         endpoints as Local, Remote pair for SRv6";
      container state {
        uses local-remote-ipv6-address-value;
        uses local-remote-interface-value;
        uses algorithm-value;
      }
    }

    container segment-ipv6-address-endpoints-for-srv6 {
      when "../state/type = 'IPV6_ADDRESS_ENDPOINTS_SRV6'";
      description
        "Type K: IPv6 Addresses for link endpoints as
         Local, Remote pair for SRv6";
      container state {
        uses local-remote-ipv6-address-value;
        uses algorithm-value;
      }
    }
  }

  grouping segment-attributes {
    leaf index {
      type uint8;
      description
        "Segment index";
    }

    leaf validate {
      type boolean;
      default 'false';
      description
        "Indicates whether the segment should be validated.
         The default applies to all segments other than the
         first segment. For the first segment, validation
         is always done.";
    }

    leaf type {
      type arc-sr-pol-types:segment-type;
      mandatory true;
      must "(current() = 'SRV6_SID') or " +
           "(current() = 'MPLS_LABEL')" {
        error-message "Only SRv6 SID and MPLS label types are supported";
      }
      description
        "Segment type";
    }
  }

  grouping segments {
    container segments {
      description
        "Segments for given segment list";

      list segment {
        key "index";
        description
          "Segment/hop at the index";

        leaf index {
          type leafref {
            path "../config/index";
          }
        }

        container config {
          uses segment-attributes;
          description
            "Segment configuration";
        }

        container state {
          config false;
          uses segment-attributes;
          description
            "Segment state";
        }

        uses segment-value;
      }
    }
  }

  grouping explicit-binding-sid-rule-attributes {
    leaf dataplane {
      type dataplane-type;
      description
        "Dataplane type";
    }
    leaf rule {
      type arc-sr-pol-types:explicit-binding-sid-rule-type;
      description
        "Explicit binding sid rule";
    }
  }

  grouping explicit-binding-sid-rules {
    container explicit-binding-sid-rules {
      list explicit-binding-sid-rule {
        key "dataplane";

        leaf dataplane {
          type leafref {
            path "../config/dataplane";
          }
          description
            "Dataplane type for explicit binding sid rule";
        }
        container config {
          uses explicit-binding-sid-rule-attributes;
        }
        container state {
          config false;
          uses explicit-binding-sid-rule-attributes;
        }
      }
    }
  }

  grouping segment-list-global {
    container segment-lists {
      description
        "Segment-lists properties";

      list segment-list {
        key "name";
        description
          "Segment-list properties";

        leaf name {
          type leafref {
            path "../config/name";
          }
        }

        container config {
          description
            "Container for configuration of segment lists.";

          leaf name {
            type string;
            description
              "Segment-list name";
          }
        }

        container state {
          config false;
          description
            "Container for state of segment lists.";

          leaf name {
            type string;
            description "Segment-list name";
          }

          leaf index {
            type uint32;
            description "Index for the segment-list in database";
          }
        }
        uses segments;
      }
    }
  }

  grouping sr-policy {
    description
      "Top level grouping for SR policy.";

    container sr-policy {
      description
        "Container for SR policy configuration and management.";

      uses segment-list-global;
      uses explicit-binding-sid-rules;
      uses sr-policy-list;
      uses dynamic-sr-policy;
      uses sr-policy-database;
    }
  }

  augment "/oc-netinst:network-instances" +
          "/oc-netinst:network-instance" {
    uses sr-policy {
      when "current()/oc-netinst:name = 'default'" {
        description
          "SRv6 configuration is valid only in the default
           network instance.";
      }
    }
  }
}

